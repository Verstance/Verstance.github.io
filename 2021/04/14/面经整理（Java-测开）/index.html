<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    
    <title>
        面经整理（Java+测开） |
        
        Homgun&#39;s Blog
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <link rel="shortcut icon" href="/images/favicon.png">
    
    
<link rel="stylesheet" href="/css/style.css">

    <script id="hexo-configurations">
    let ILS = window.ILS || {};
    let CONFIG = {"hostname":"example.com","root":"/","localsearch":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"themeInfo":{"name":"ILS","version":"2.1.0","author":"XPoet","repository":"https://github.com/XPoet/hexo-theme-ils"},"toc":{"enable":true,"number":false,"expand_all":true},"back2top":{"enable":true},"path":"search.json"};
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
<div class="page-container">

    <header class="page-header">
        <div class="header-progress"></div>
    </header>

    <main class="page-main">

        <div class="page-main-content">

            <div class="page-main-content-top">
                <header class="header-wrapper">

    <div class="header-content">

        <a class="logo-title" href="/">
            Homgun&#39;s Blog
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        首页
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        归档
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/tags"
                    >
                        标签
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


            </div>

            <div class="page-main-content-middle">

                <main class="main-content normal-code-theme">

                    
                        <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <h3><a class="title-hover-animation">面经整理（Java+测开）</a></h3>
        </div>

        <div class="meta-info">
            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa fa-calendar-o"></i> 2021-04-14 22:38:03
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>
                    </li>
                
            </ul>
        </span>
    
    
    
        <span class="article-wordcount article-meta-item">
        <i class="fa fa-book"></i> <span>21.7k 字</span>
        </span>
    
    
</div>

        </div>

        <div class="article-content markdown-body">
            <h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5><p><strong><em>final关键字</em></strong>（**）</p>
<p>final用于修饰类、成员变量和成员方法。</p>
<ul>
<li><p>final修饰的类：不能被<strong>继承</strong>（String、StringBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被<strong>重写</strong>（这里需要注意的是不能被重写，但是可以被重载），所以不能同时用abstract和final修饰类（abstract修饰的类是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；</p>
</li>
<li><p>final修饰的方法：不能被<strong>重写</strong>，但是子类<strong>可以用</strong>父类中final修饰的方法；</p>
</li>
<li><p>final修饰的成员变量：是<strong>不可变</strong>的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是<strong>对象当中的内容是允许改变</strong>的。</p>
</li>
</ul>
<p><strong><em>Java8性能优化（字符串拼接）</em></strong></p>
<p>字符串拼接常用到的几种方式如下：</p>
<p>　　1、“+”拼接；</p>
<p>　　2、concat拼接；</p>
<p>　　3、StringBuilder（StringBuff）拼接。</p>
<p>其中第一种方式拼接字符串在我的视眼中是最常见的，孰不知第一种方式是最不值得提倡的（性能消耗大，效率低），concat是由String类提供的封装类性能较“+”好很多，相较于前两者StringBuilder的速度基本可以忽略，快太多了。</p>
<p>StringBuffer和StringBuilder的实现实现原理和操作基本上一致，主要差别是StringBuffer是由<strong>synchronized修饰</strong>，支持<strong>并发操作线程安全</strong>的类。而StringBuilder是不支持并发操作的，所以多线程时建议使用StringBuffer。单线程中StringBuilder的性能要好于StringBuffer。</p>
<p><strong><em>HashMap</em></strong>（***）</p>
<p><strong>数据结构</strong>：数组+链表（+红黑树）</p>
<p><strong>插入方式</strong>：头插→尾插</p>
<p><strong>冲突解决</strong>：拉链法 </p>
<p><strong><em>HashSet</em></strong></p>
<p><strong>实现原理</strong>：HashSet是基于HashMap实现的，都是一个存放链表的数组。它不保证存储元素的迭代顺序，允许使用null元素，不允许有重复元素。当向HashSet中添加对象时，首先调用此对象所在类的hashCode()方法，计算次对象的哈希值，此哈希值决定了此对象在HashSet中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。因此，如果想实现自定义去重，需要重写model的hashcode方法和equals方法。</p>
<p><strong>HashSet和HashMap的区别</strong>：<br>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对；</p>
<p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true。</p>
<p><strong><em>权限修饰符（可见性修饰符）</em></strong></p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内访问</th>
<th align="center">包内访问</th>
<th align="center">子类访问</th>
<th align="center">不同包访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>​    子类可以覆盖父类的 protected 方法，并把该方法的可见性改成 public。但是子类不能降低父类方法的可见性，即不能把父类的 public 方法的可见性改成 protected。</p>
<p><strong><em>线程实现</em></strong></p>
<p><strong>方式一：继承Thread类的方式</strong></p>
<ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类中的run()：将此线程要执行的操作声明在run()</li>
<li>创建Thread的子类的对象</li>
<li>调用此对象的start():①启动线程 ②调用当前线程的run()方法</li>
</ol>
<p><strong>方式二：实现Runnable接口的方式</strong></p>
<ol>
<li>创建一个实现Runnable接口的类</li>
<li>实现Runnable接口中的抽象方法：run():将创建的线程要执行的操作声明在此方法中</li>
<li>创建Runnable接口实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>调用Thread类中的start():① 启动线程 ② 调用线程的run() —&gt;调用Runnable接口实现类的run()</li>
</ol>
<p>以下两种方式是jdk1.5新增的！</p>
<p><strong>方式三：实现Callable接口</strong></p>
<p>说明：</p>
<ol>
<li>与使用Runnable相比， Callable功能更强大些</li>
<li>实现的call()方法相比run()方法，可以<strong>返回值</strong></li>
<li>方法可以抛出<strong>异常</strong></li>
<li>支持<strong>泛型</strong>的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ol>
<ul>
<li>Future接口可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<p><strong>方式四：使用线程池</strong></p>
<p>说明：</p>
<ul>
<li>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
</ul>
<p>好处：</p>
<ol>
<li> 提高响应<strong>速度</strong>（减少了创建新线程的时间）</li>
<li> 降低<strong>资源</strong>消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li> 便于线程<strong>管理</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式四</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 继承Thread</span></span><br><span class="line">		ThreadTest thread = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">		thread.setName(<span class="string">&quot;方式一&quot;</span>);</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现Runnable</span></span><br><span class="line">		RunnableTest runnableTest = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(runnableTest, <span class="string">&quot;方式二&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现Callable&lt;&gt; 有返回值</span></span><br><span class="line">		CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">		FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callableTest);</span><br><span class="line">		<span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;方式三&quot;</span>).start();</span><br><span class="line">		<span class="comment">// 返回值</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Integer integer = futureTask.get();</span><br><span class="line">			System.out.println(<span class="string">&quot;返回值（sum）：&quot;</span> + integer);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 线程池</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor) pool;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 可以做一些操作:</span></span><br><span class="line"><span class="comment">		 * corePoolSize：核心池的大小 </span></span><br><span class="line"><span class="comment">		 * maximumPoolSize：最大线程数</span></span><br><span class="line"><span class="comment">		 * keepAliveTime：线程没任务时最多保持多长时间后会终止</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开启线程</span></span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>线程池</em></strong></p>
<p><strong>理解</strong>：线程池是一种线程的使用模式。创建若干个可执行的线程放入一个池（容器）中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程并不会被销毁，而是仍然在线程池中等待下一个任务。</p>
<p><strong>好处</strong></p>
<ul>
<li><p>降低<strong>资源</strong>消耗。重复利用线程池中已经创建的线程，可以避免频繁地创建和销毁线程，从而减少资源消耗。</p>
</li>
<li><p>提高<strong>响应</strong>速度。由于线程池中有已经创建的线程，因此当任务到达时，可以直接执行，不需要等待线程创建。</p>
</li>
<li><p>提高线程的<strong>可管理</strong>性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
</li>
</ul>
<p><strong>使用</strong></p>
<p>可以通过 <strong>ThreadPoolExecutor 类创建线程池</strong>。ThreadPoolExecutor 类有 4 个构造方法，其中最一般化的构造方法包含 7 个参数。</p>
<p>corePoolSize：核心线程数，定义了最少可以同时运行的线程数量，当有新的任务时就会创建一个线程执行任务，当线程池中的线程数量达到 corePoolSize 之后，到达的任务进入阻塞队列。</p>
<p>maximumPoolSize：最大线程数，定义了线程池中最多能创建的线程数量。</p>
<p>keepAliveTime：等待时间，当线程池中的线程数量大于 corePoolSize 时，如果一个线程的空闲时间达到 keepAliveTime 时则会终止，直到线程池中的线程数不超过 corePoolSize。</p>
<p>unit：参数 keepAliveTime 的单位。</p>
<p>workQueue：阻塞队列，用来存储等待执行的任务。</p>
<p>threadFactory：创建线程的工厂。</p>
<p>handler：当拒绝处理任务时的策略。</p>
<p>可以通过<strong>方法 execute 向线程池提交任务</strong>。该方法被调用时，线程池会做如下操作。</p>
<ul>
<li><p>如果正在运行的线程数量小于 corePoolSize，则创建核心线程运行这个任务。</p>
</li>
<li><p>如果正在运行的线程数量大于或等于 corePoolSize，则将这个任务放入阻塞队列。</p>
</li>
<li><p>如果阻塞队列满了，而且正在运行的线程数量小于 maximumPoolSize，则创建非核心线程运行这个任务。</p>
</li>
<li><p>如果阻塞队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，则线程池抛出 RejectExecutionException 异常。</p>
</li>
</ul>
<p>上述操作中提到了两个概念，「核心线程」和「非核心线程」。核心线程和非核心线程的最大数目在创建线程池时被指定。核心线程和非核心线程的区别如下。</p>
<p>向线程池提交任务时，首先创建核心线程运行任务，直到核心线程数到达上限，然后将任务放入阻塞队列。</p>
<p>只有在核心线程数到达上限，且阻塞队列满的情况下，才会创建非核心线程运行任务。</p>
<p><strong><em>序列化</em></strong></p>
<p>​        把对象转换成字节序列的过程称为对象的序列化，把字节序列恢复成对象的过程称为对象的反序列化。</p>
<p>​        <code>Serializable</code> 接口的作用是标识一个对象是否可被序列化，只有当一个类实现了 Serializable 接口时，这个类的实例才是可序列化的。这个接口是<strong>标识接口</strong>，不包含任何数据域和方法。</p>
<p>​        关键字 <code>transient </code>的作用是指定数据域<strong>不被序列化</strong>。当一个数据域不能被序列化，或者不想对一个数据域序列化时，给这个数据域加上关键字<code> transient</code>，在序列化的过程中将忽略这个数据域。</p>
<h5 id="编程算法"><a href="#编程算法" class="headerlink" title="编程算法"></a>编程算法</h5><p><strong><em>快速排序</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr        待排序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftIndex  待排序列起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightIndex 待排序列结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = leftIndex;</span><br><span class="line">        <span class="keyword">int</span> right = rightIndex;</span><br><span class="line">        <span class="comment">//待排序的第一个元素作为基准值</span></span><br><span class="line">        <span class="keyword">int</span> key = arr[left];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左右两边交替扫描，直到left = right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= key) &#123;</span><br><span class="line">                <span class="comment">//从右往左扫描，找到第一个比基准值小的元素</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到这种元素将arr[right]放入arr[left]中</span></span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123;</span><br><span class="line">                <span class="comment">//从左往右扫描，找到第一个比基准值大的元素</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到这种元素将arr[left]放入arr[right]中</span></span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准值归位</span></span><br><span class="line">        arr[left] = key;</span><br><span class="line">        <span class="comment">//对基准值左边的元素进行递归排序</span></span><br><span class="line">        quickSort(arr, leftIndex, left - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//对基准值右边的元素进行递归排序。</span></span><br><span class="line">        quickSort(arr, right + <span class="number">1</span>, rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="实现细节（锁-JVM）"><a href="#实现细节（锁-JVM）" class="headerlink" title="实现细节（锁 / JVM）"></a>实现细节（锁 / JVM）</h5><p><strong><em>synchronized</em></strong></p>
<p>synchronized关键字用于为Java对象、方法、代码块提供线程安全的操作。</p>
<p> synchronized属于独占式的悲观锁，同时属于可重入锁。</p>
<p>在使用synchronized修饰对象时， 同一时刻只能有一个线程对该对象进行访问；在synchronized修饰方法、代码块时，同一 时刻只能有一个线程执行该方法体或代码块，其他线程只有等待当前线程执行完毕并释放锁资源后才能访问该对象或执行同步代码块。</p>
<p> Java中的每个对象都有个monitor对象，加锁就是在竞争monitor对象。对代码块加锁 是通过在前后分别加上monitorenter和monitorexit指令实现的，对方法是否加锁是通过一个 标记位来判断的。 </p>
<p><strong>作用范围</strong>：</p>
<p> ◎ synchronized作用于成员变量和非静态方法时，锁住的是对象的实例，即this对象。 </p>
<p>◎ synchronized作用于静态方法时，锁住的是Class实例，因为静态方法属于Class而不 属于对象。</p>
<p> ◎ synchronized作用于一个代码块时，锁住的是所有代码块中配置的对象。 </p>
<p><strong><em>锁升级</em></strong></p>
<p>偏向锁/轻量级锁/重量级锁</p>
<p>这三种锁是指锁的状态，并且是针对Synchronized。</p>
<p><strong>偏向锁</strong>是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
<p><strong>轻量级锁</strong>是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
<p><strong>重量级锁</strong>是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下 去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。 重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
<p><strong>自旋锁</strong></p>
<p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样 的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<p><strong><em>乐观锁</em></strong>（**）</p>
<p>​        乐观锁采用乐观的思想处理数据，在<strong>每次读取数据时都认为别人不会修改该数据，所以不会上锁</strong>，但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法。具体过程为：比较当前版本号与上一次的版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读、比较、写操作。</p>
<p>​         Java中的乐观锁大部分是通过CAS（Compare And Swap，比较和交换）操作实现的， CAS是一种<strong>原子更新操作</strong>，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。</p>
<p><strong><em>volatile / synchronized</em></strong></p>
<ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在代码块、方法和类级别的</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
</ul>
<p><strong><em>JVM体系结构</em></strong></p>
<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/1377269-20200115202410991-705795907.jpg" alt="img"></p>
<p>注：</p>
<ul>
<li><p>程序计数器是唯一不会出现 OutOfMemoryError 的内存区域。</p>
</li>
<li><p>虚拟机栈描述的是 Java 方法执行的内存模型。当一个方法被执行时会创建栈帧存入栈内，栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>
</li>
<li><p>虚拟机栈可能出现的两种异常是 StackOverflowError 和 OutOfMemoryError。</p>
</li>
<li><p>如果虚拟机栈不可以动态扩展，当线程请求的栈深度大于虚拟机所允许的深度时，将抛出 StackOverflowError 异常；<br>如果虚拟机栈可以动态扩展，当无法申请到足够的内存时，将抛出 OutOfMemoryError 异常。</p>
</li>
<li><p>堆是 Java 虚拟机管理的内存中最大的一块，其目的是存放对象实例，几乎所有的对象实例都在堆中分配内存。</p>
</li>
<li><p>静态变量存放在方法区。</p>
</li>
</ul>
<p><strong><em>垃圾回收</em></strong></p>
<p><strong>内存分配</strong></p>
<p>​        Java 堆可以分成新生代和老年代，新生代又可以细分成 Eden 区、From Survivor 区、To Survivor 区等。对于不同的对象，有相应的内存分配规则。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/image-20210409141536206.png" alt="image-20210409141536206"></p>
<ul>
<li><p>对象优先在 Eden 区分配<br>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
</li>
<li><p>大对象直接进入老年代<br>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间分配给大对象。</p>
<p>将大对象直接在老年代中分配的目的是避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p>
</li>
<li><p>长期存活的对象进入老年代<br>虚拟机采用分代收集的思想管理内存，因此需要识别每个对象应该放在新生代还是老年代。虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过第一次 Minor GC 之后仍然存活，将进入 Survivor 区，同时对象年龄变为 1，对象在 Survivor 区每经过一次 Minor GC 且存活，年龄就增加 1，增加到一定阈值时则进入老年代（阈值默认为 15）。</p>
</li>
<li><p>动态对象年龄判定<br>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p>
</li>
</ul>
<p><strong>回收策略</strong></p>
<p>Minor GC 和 Full GC<br><strong>Minor GC</strong> 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。</p>
<p><strong>Full GC</strong> 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC <strong>慢</strong>很多。</p>
<p><strong>参数调优</strong></p>
<p>内存参数</p>
<pre><code>-Xms1024m （堆初始化内存）     X-Memory Startup
-Xmx1024m （堆的最大内存）     X-Memory Maximum, 注意: 堆内存大小=年轻代(1/3)+老年代(2/3)
-Xmn256m （堆-年轻代大小）     X-Memory New, 注意: 老年代大小=Xmx-年轻代, 年轻代占比
-Xss256k （棧-最大深度大小）     X-Stack Size
-XX:MetaspaceSize=?m （元空间默认大小） , 注意: 元空间默认大小取决于系统内存,实测64bit-16G电脑, 默认30M
-XX:MaxMetaspaceSize=?m （元空间最大大小） , 注意: 只要不设置上限,只要电脑内存足够就会动态增加
-XX:SurvivorRatio=? （默认值:8, 即新生代分区比例默认 8:2, 即 Eden:S1:S2=8:1:1, S1约定于S2)
-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器） 
-XX:+PrintGCDetails （打印详细的GC日志）
注意:jdk1.8已经移除了-XX:PermSize 和  -XX:MaxPermGen，取而代之的是 Metaspace</code></pre>
<h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p><strong><em>单例模式</em></strong></p>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有<strong>单个对象</strong>被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>优点：</strong></p>
<ul>
<li>在内存里只有一个实例，<strong>减少了内存的开销</strong>，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>要求生产<strong>唯一</strong>序列号。</li>
<li>WEB 中的<strong>计数器</strong>，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要<strong>消耗的资源过多</strong>，比如 I/O 与数据库的连接等。</li>
</ul>
<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DCL懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton; <span class="comment">// volatile保证没有指令重排 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton(); <span class="comment">// 不是一个原子性操作，存在指令重排：1.分配内存空间 2.执行构造方法，初始化对象 3.对象指向空间</span></span><br><span class="line">         	&#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射破坏单例，但枚举能够避免单例模式被破坏（枚举类型反编译，发现枚举类型是有参构造）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Singleton instance = Singleton.getInstance();</span><br><span class="line">    Constructor&lt;Singleton&gt; declaredConstructor = Singleton.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">    declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Singleton instance2 = declaredConstructor.newInstance();</span><br><span class="line">    System.out.println(instance==instance2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Constructor&lt;Singleton&gt; declaredConstructor = SingletonEnum.class.getDeclaredConstructor(String.class,int.class); → Exception: Cannot reflectively create enum objects</span></span><br></pre></td></tr></table></figure>



<h5 id="框架（含前端）"><a href="#框架（含前端）" class="headerlink" title="框架（含前端）"></a>框架（含前端）</h5><p><strong><em>MVC</em></strong></p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li>Model（模型）代表一个<strong>存取数据的对象</strong>或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li>View（视图）代表模型包含的数据的<strong>可视化</strong>。</li>
<li>Controller（控制器）控制器作用于模型和视图上。它<strong>控制数据流向</strong>模型对象，并在数据变化时<strong>更新视图</strong>。它使视图与模型分离开。</li>
</ul>
<p><strong><em>Spring中Bean的作用域</em></strong></p>
<p>Spring IOC容器创建一个Bean实例时，可以为Bean指定实例的作用域，作用域包括singleton（单例模式）、prototype（原型模式）、request（HTTP请求）、session（会话）、global-session（全局会话）。</p>
<p><strong><em>Session / Cookie</em></strong></p>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p><strong>Cookie的缺点</strong>：</p>
<p>(1) 每个特定域名下的cookie数量有限：</p>
<p>IE6或IE6-(IE6以下版本)：最多20个cookie</p>
<p>IE7或IE7+(IE7以上版本)：最多50个cookie</p>
<p>FF:最多50个cookie</p>
<p>Opera:最多30个cookie</p>
<p>Chrome和safari没有硬性限制</p>
<p>当超过单个域名限制之后，再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会清理近期最少使用的cookie，FF会随机清理cookie；</p>
<p>(2) 存储量太小，只有4KB；</p>
<p>(3) 每次HTTP请求都会发送到服务端，影响获取资源的效率；</p>
<p>(4) 需要自己封装获取、设置、删除cookie的方法；</p>
<p><strong><em>表单重复提交</em></strong></p>
<p>​        表单重复提交会造成数据重复，<strong>增加服务器负载</strong>，严重甚至会造成服务器宕机。因此有效防止表单重复提交有一定的必要性。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>利用JavaScript防止表单重复提交<ul>
<li>对按钮进行控制：在第一次点提交的时候将button设置为disable。</li>
<li>做状态位进行标识：设置一个标志位了来判断是不是第一次提交。</li>
</ul>
</li>
<li>利用Session防止表单重复提交<ul>
<li>令牌（Token）：在服务器端生成一个<strong>唯一的随机标识号</strong>，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。</li>
</ul>
</li>
</ol>
<p><strong><em>SpringBoot / SpringMVC</em></strong></p>
<p>spring boot就是一个大框架里面包含了许许多多的东西，其中spring就是最核心的内容之一，当然也就包含spring mvc。</p>
<p>spring mvc 只是spring 处理web层请求的一个模块。</p>
<p><strong><em>SpringMVC 执行流程</em></strong></p>
<p>1、 首先用户发送请求到前端控制器，前端控制器根据请求信息（如 URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；</p>
<p>2、 页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在 Spring Web MVC 中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个 ModelAndView（模型数据和逻辑视图名）；</p>
<p>3、 前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；</p>
<p>4、 前端控制器再次收回控制权，将响应返回给用户。</p>
<p><strong>JavaScript中let和var区别</strong></p>
<p>1、作用域不同</p>
<p>var是函数作用域，let是块作用域。</p>
<p>在函数中声明了var，整个函数内都是有效的，比如说在for循环内定义的一个var变量，实际上其在for循环以外也是可以访问的</p>
<p>而let由于是块作用域，所以如果在块作用域内定义的变量，比如说在for循环内，在其外面是不可被访问的，所以for循环推荐用let</p>
<p>2、let不能在定义之前访问该变量，但是var可以。</p>
<p>let必须先声明，在使用。而var先使用后声明也行，只不过直接使用但没有定义的时候，其值是undefined。var有一个变量提升的过程，当整个函数作用域被创建的时候，实际上var定义的变量都会被创建，并且如果此时没有初始化的话，则默认为初始化一个undefined</p>
<p>3、let不能被重新定义，但是var是可以的</p>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p><strong><em>Redis</em></strong></p>
<p>​        Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p>
<ul>
<li>基于内存运行，性能高效</li>
<li>支持分布式，理论上可以无限扩展</li>
<li>key-value存储系统</li>
<li>开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</li>
</ul>
<p>​        相比于其他数据库类型，Redis具备的特点是：</p>
<ul>
<li>C/S通讯模型</li>
<li>单进程单线程模型</li>
<li>丰富的数据类型</li>
<li>操作具有原子性</li>
<li>持久化</li>
<li>高并发读写</li>
<li>支持lua脚本</li>
</ul>
<p>​        Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。</p>
<p><strong>数据结构</strong></p>
<p>​        Redis提供的数据类型主要分为5种自有类型和一种自定义类型，这5种自有类型包括：字符串类型、哈希类型、列表类型、集合类型和顺序集合类型。</p>
<ul>
<li><p>字符串（String）类型：</p>
<p>它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。</p>
</li>
<li><p>哈希（Hash）类型：</p>
<p>该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。</p>
</li>
<li><p>列表（List）类型：<br>该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。</p>
</li>
<li><p>集合（Set）类型：<br>Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。</p>
</li>
<li><p>顺序集合（Zset）类型：<br>ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。</p>
</li>
</ul>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210409173546.jpg"></p>
<p><strong>持久化方法</strong></p>
<p>​        由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是<strong>RDB持久化</strong>（原理是将Reids在内存中的数据库记录<strong>定时dump到磁盘</strong>上的RDB持久化），另外一种是<strong>AOF（append only file）持久化</strong>（原理是将Reids的<strong>操作日志以追加的方式写入文件</strong>）。</p>
<p><strong><em>RDB</em></strong>的优点：简称“3更”</p>
<ol>
<li><p>体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件</p>
</li>
<li><p>恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存</p>
</li>
<li><p>性能更高:父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>故障丢失:因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。</p>
</li>
<li><p>耐久性差:相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。</p>
</li>
</ol>
<p><strong><em>AOF</em></strong>的优点：</p>
<ol>
<li><p>数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，咱们也最多丢失一秒数据</p>
</li>
<li><p>自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>性能相对较差：它的操作模式决定了它会对redis的性能有所损耗</p>
</li>
<li><p>体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。</p>
</li>
<li><p>恢复速度更慢：</p>
</li>
</ol>
<p><strong>过期策略</strong></p>
<p>三种过期策略：定时删除、惰性删除、定期删除。</p>
<p>Redis采用的过期策略：惰性删除+定期删除</p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作。</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>分布式锁</em></strong></p>
<p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。</p>
<p><strong>具备条件</strong>：</p>
<ul>
<li><p>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</p>
</li>
<li><p>高可用的获取锁与释放锁；</p>
</li>
<li><p>高性能的获取锁与释放锁；</p>
</li>
<li><p>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）；</p>
</li>
<li><p>具备锁失效机制，防止死锁具备非阻塞锁特性，即没有获取到锁将直接返</p>
<p>回获取锁失败。</p>
</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li><p>基于数据库实现分布式锁；</p>
<p>​        基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建<strong>唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p>
</li>
<li><p>基于缓存（Redis等）实现；</p>
<p>实现思想：</p>
<p>（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p>
<p>（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p>
<p>（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p>
</li>
<li><p>基于Zookeeper实现。</p>
<p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个<strong>分层</strong>的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p>
<p>（1）创建一个目录mylock；<br>（2）线程A想获取锁就在mylock目录下创建临时顺序节点；<br>（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；<br>（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</p>
<p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p>
<p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p>
</li>
</ul>
<p><strong><em>ElasticSearch</em></strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/elasticsearch">https://www.elastic.co/cn/products/elasticsearch</a></p>
<p>Elasticsearch是一个采用Restful API标准的高扩展性和高可用性的实时数据分析的全文搜索工具。</p>
<p><strong>优势</strong>：</p>
<ol>
<li><p>弹性、高可用</p>
</li>
<li><p>可预见，可信</p>
</li>
<li><p>简单透明</p>
</li>
</ol>
<p>与关系数据库的对比</p>
<table>
<thead>
<tr>
<th>关系型数据库（MySQL）</th>
<th>非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td>数据库database</td>
<td>索引 index</td>
</tr>
<tr>
<td>表 table</td>
<td>类型 type</td>
</tr>
<tr>
<td>数据行 row</td>
<td>文档 document</td>
</tr>
<tr>
<td>数据列 column</td>
<td>字段 field</td>
</tr>
</tbody></table>
<p><strong>小结</strong>：</p>
<ol>
<li><p>ElasticSearch其实就是<strong>非关系型数据库</strong>，非关系型数据库是相对关系型数据库而言的。</p>
</li>
<li><p>非关系型数据库存储的是非结构化的数据，非结构化数据包括<strong>文本、图片、音频</strong>。</p>
</li>
<li><p>结构化的数据就是数字符号，数字符号得用关系型数据库去存储，也就是我们常用的mysql、oracle、db2。</p>
</li>
</ol>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p><strong><em>TCP / UDP</em></strong></p>
<p>用户数据报协议 UDP是面向<strong>无连接</strong>的，<strong>尽最大可能</strong>交付，没有拥塞控制，面向<strong>报文</strong>，支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>传输控制协议 TCP是面向<strong>连接</strong>的，提供<strong>可靠</strong>交付，有流量控制，<strong>拥塞控制</strong>，提供全双工通信，面向<strong>字节流</strong>，每一条 TCP 连接只能是<strong>点对点</strong>的（一对一）。</p>
<p> TCP应用场景：</p>
<p>效率要求相对低，但对<strong>准确性</strong>要求相对高的场景。因为传输中需要对数据确认、重发、 排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。</p>
<p>UDP应用场景：</p>
<p><strong>效率</strong>要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。</p>
<p>UDP为何快？</p>
<p>不需要建立连接<br>对于收到的数据，不用给出确认<br>没有超时重发机制<br>没有流量控制和拥塞控制</p>
<p><strong><em>IP数据包结构</em></strong></p>
<p>IP协议提供<strong>不可靠无连接</strong>的数据报传输服务，IP层提供的服务是通过IP层对数据报的封装与拆封来实现的。IP数据报的格式分为<strong>报头区</strong>和<strong>数据区</strong>两大部分，其中报头区是为了正确传输高层数据而加的各种<strong>控制信息</strong>，数据区包括高层协议需要传输的数据。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5573582_1279195143KN73.png"></p>
<p>IP 协议主要有以下几个作用：</p>
<p><strong>寻址和路由</strong>：在IP 数据包中会携带<strong>源 IP 地址</strong>和<strong>目的 IP 地址</strong>来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据<strong>路由表</strong>选择合适的路径。IP 协议根据<strong>路由选择协议</strong>提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。<br><strong>分段与重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，在<strong>不同的网络</strong>中<strong>数据包的最大长度限制</strong>是不同的，IP 协议通过给每个 IP 数据包分配一个<strong>标识符</strong>以及<strong>分段与组装的相关信息</strong>，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以<strong>独立</strong>地在网络中进行<strong>转发</strong>，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</p>
<p><strong><em>三次挥手，四次握手</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/0_131271823564Rx.gif" alt="img"></p>
<p><strong>三次握手</strong></p>
<p>三次握手的目的是建立<strong>可靠</strong>的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p><strong>四次挥手</strong></p>
<p><em>CLOSE-WAIT</em>状态问题：</p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了<strong>让服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送FIN 连接释放报文。</p>
<p><em>TIME-WAIT</em> 状态问题：</p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<p>确保<strong>最后一个确认报文</strong>能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一 个新的连接<strong>不会出现旧的连接请求报文</strong>。</p>
<p>通信双方建立TCP连接后，<strong>主动关闭</strong>连接的一方就会进入TIME_WAIT状态。</p>
<p><strong><em>HTTP / HTTPS</em></strong>（**）</p>
<ul>
<li><p>HTTP 协议以<strong>明文</strong>方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是<strong>加密</strong>的，安全性较好。</p>
</li>
<li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 <strong>80</strong> 端口，后者是 <strong>443</strong> 端口。</p>
</li>
<li><p>HTTPS 协议需要到<strong>数字认证机构</strong>（Certificate Authority, CA）申请证书，一般需要一定的<strong>费用</strong>。</p>
</li>
<li><p>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 <strong>SSL 协商过程</strong>。</p>
</li>
</ul>
<p><strong>HTTPS运作过程</strong></p>
<p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 <strong>443 端口</strong>，发送的信息主要包括自身所<strong>支持的算法</strong>列表和<strong>密钥长度</strong>等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它的<strong>密钥组件</strong>一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含<strong>数字证书</strong>的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的<strong>公钥</strong>等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个<strong>回应报文</strong>，报文中包含一个客户端生成的<strong>随机密码串</strong>，称为 pre_master_secre，并且该报文是经过证书中的<strong>公钥加密过</strong>的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 <strong>finish 报文</strong>，这次握手中包含第一次握手至今所有报文的<strong>整体校验值</strong>，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
<p><strong>SSL协议作用</strong></p>
<p>​        SSL能使用户/服务器应用之间的通信不被攻击者<strong>窃听</strong>，并且始终对服务器进行<strong>认证</strong>，还可选择对用户进行认证。SSL协议要求建立在可靠的传输层协议（TCP）之上。SSL协议的优势在于它是与应用层协议<strong>独立无关</strong>的，高层的应用层协议（例如：HTTP，FTP，TELNET等）能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成<strong>加密算法</strong>、<strong>通信密钥</strong>的协商及<strong>服务器认证</strong>工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p>
<p><strong><em>常见状态码</em></strong></p>
<p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。HTTP 状态码共有 5 种类型：</p>
<p>分类    分类描述<br>1XX    指示信息–表示请求正在处理<br>2XX    成功–表示请求已被成功处理完毕<br>3XX    重定向–要完成的请求需要进行附加操作<br>4XX    客户端错误–请求有语法错误或者请求无法实现，服务器无法处理请求<br>5XX    服务器端错误–服务器处理请求出现错误</p>
<p>常见的状态码： 200、301、302、403、404、500、503</p>
<p>状态码    描述<br><strong>200</strong> 请求被成功处理<br><strong>301</strong> <strong>永久</strong>性重定向<br><strong>302</strong> <strong>临时</strong>性重定向<br>304 未修改。告诉客户端可以复用缓存。<br><strong>400</strong> 请求出错：由于<strong>语法格式 / 参数</strong>有误，服务器无法理解。<br>401 未授权：当前请求需要用户<strong>验证</strong>。<br><strong>403</strong> 没有访问<strong>权限</strong>（服务器已经理解请求，但是拒绝执行它）。<br><strong>404</strong> 没有对应资源（一般是输入的url并不合法）。<br>405 不允许此方法（get/post/put/delete/请求用混淆了）。<br>406 不可接受，请求的资源的内容特性无法满足<strong>请求头</strong>中的条件，因而无法生成响应实体。<br>407 需要代理身份验证，与401响应类似，只不过客户端必须在<strong>代理</strong>服务器上进行身份验证。<br>412 前提条件失败：在服务器上测试前提条件时，部分请求标题字段中所给定的前提条件估计为FALSE。客户机将前提条件放置在当前资源元信息（标题字段数据）中，以防止所请求的方法被误用到其他资源。<br>414 Request-URI 太长<br><strong>500</strong> 服务器内部错误（一般是服务器代码错误）。<br>501 未实现，Web 服务器不支持实现此请求所需的功能。<br><strong>502</strong> 网关出错，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到<strong>无效</strong>的响应。<br><strong>503</strong> 服务器停机，由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常。<br>504 网关超时，充当网关或代理的服务器，未<strong>及时</strong>从远端服务器获取请求</p>
<p><strong><em>特殊的IP地址</em></strong></p>
<p>一、0.0.0.0</p>
<p>严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。</p>
<p>二、255.255.255.255</p>
<p>限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。</p>
<p>三、127.0.0.1</p>
<p>本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。</p>
<p>四、224.0.0.1</p>
<p>组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP(Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。</p>
<p>五、169.254.X.X</p>
<p>如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</p>
<p>六、10.X.X.X、172.16.X.X～172.31.X.X、192.168.X.X</p>
<p>私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。</p>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p><strong><em>进程调度算法</em></strong></p>
<p>a）先来先去服务</p>
<p>b）时间片轮转法</p>
<p>c）短作业优先</p>
<p>d）高响应比优先调度算法（既考虑作业等待时间又考虑作业运行时间）</p>
<p>e）多级反馈队列调度算法（既能使高优先级的作业得到响应又能使短作业迅速完成）</p>
<p>f）优先级调度</p>
<p><strong><em>进程 / 线程</em></strong>（**）</p>
<p>a）进程是<strong>资源分配</strong>的最小单位，线程是<strong>任务执行</strong>的最小单位。</p>
<p>b）进程有自己的<strong>独立</strong>地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是<strong>共享</strong>进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p>
<p>c）线程之间的<strong>通信</strong>更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC）进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>
<p>d）但是多进程程序更<strong>健壮</strong>，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>
<p><strong><em>分页 / 分段</em></strong></p>
<p>分段和分页其实都是一种对<strong>地址</strong>的划分或者映射的方式。 两者的区别主要有以下几点：</p>
<p>1)页是信息的<strong>物理</strong>单位，分页是为实现<strong>离散</strong>分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于<strong>系统管理</strong>的需要，而不是用户的需要（也是<strong>对用户透明</strong>的）。段是信息的<strong>逻辑</strong>单位，它含有一组其意义相对完整的信息（比如数据段、代码段和堆栈段等）。分段的目的是为了能更好的满足<strong>用户</strong>的需要（用户也是可以使用的）。</p>
<p>2)页的大小<strong>固定</strong>且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。</p>
<p>3)分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符（线性地址的16进制表示），即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名（比如数据段、代码段和堆栈段等），又需给出段内地址。</p>
<p>4)页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p><strong><em>Linux常用命令</em></strong>（**）</p>
<p>pwd：显示当前所在位置</p>
<p>sudo + 其他命令：以系统管理者的身份执行指令</p>
<p>grep：要搜索的字符串 要搜索的文件 –color （高亮）</p>
<p>ps - ef/ps aux：查看当前系统正在运行进程</p>
<p>查看特定的进程（查看包括redis的进程）： ps aux|grep redis / pgrep redis -a</p>
<p>kill -9 进程pid ： 杀死进程（-9 表示强制终止）</p>
<p>find 目录 参数 ：find /home -name “*.txt”  </p>
<p>ls 或者 ll ：查看目录信息（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）</p>
<p>free : 显示<strong>系统内存</strong>的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存</p>
<p>tar -zcvf 打包压缩后的文件名 要打包压缩的文件 : 打包并压缩文件，一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 .tar.gz</p>
<p>tar -xvf 压缩文件 - C 解压的位置 : 解压压缩包</p>
<p>wget : 是从远程下载的工具</p>
<p>vmstat : 虚拟内存性能监控、CPU 监控。</p>
<p>top : 常用来监控Linux的<strong>系统状况</strong>，比如CPU、内存的使用，显示系统上正在运行的进程。</p>
<p>load average：系统负载，就是进程队列的长度。当这个值&gt;cpu核心数的时候就说明有进程在等待处理了，是负载过重。</p>
<p><strong><em>创建新进程</em></strong>在Linux的下是由父进程来完成的，创建完成的新进程是子进程。</p>
<p>新进程的地址空间有两种可能性：</p>
<p>子进程是父进程的复制品（除了PID和task_struct是子进程自己的，其余的都从父进程复制而来）<br>子进程装入另一个程序。<br>在Linux下的fork函数用于创建一个新的进程，使用fork函数来创建一个进程时，子进程只是完全复制父进程的资源。这样得到的子进程和父进程是独立的，具有良好的并发性。但是进程间通信需要专门的机制。</p>
<p>fork函数调用一次，会返回两个函数值，对于父进程而言，返回的是子进程的PID（因为一个父进程可能有多个子进程，并且没有一个函数可以使父进程获取其所有的子进程ID），对于子进程返回值是0（这样就能区分父子进程，子进程是可以通过getppid来获取父进程的ID），如果进程创建失败，那么返回给父进程-1。</p>
<p>现在的Linux操作系统采用了copy-on-write技术（COW），即：如果父进程和子进程中任意一个尝试修改某些区域的值，那么内核会为修改区域的那部分内存制作一个副本，一般都是虚拟内存的一页。否则不进行复制操作，比如在fork的子进程中只是调用exec函数来执行另外一个可执行文件，那么事实上就没有必要复制父进程的资源，这样会造成大量的开销浪费。</p>
<p>fork()函数创建的子进程和父进程的执行顺序理论上是不确定的（因为取决于OS的调度策略）。</p>
<p>总结一下：fork函数创建的子进程是父进程的复制，子进程和父进程并发执行</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><strong><em>关系型 / 非关系型数据库</em></strong></p>
<p><strong>1 关系型数据库</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/1013528-20170926113945323-238845177.png" alt="img"></p>
<p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。<br>优点：<br>1、易于维护：都是使用表结构，格式一致；<br>2、使用方便：SQL语言通用，可用于复杂查询；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。<br>缺点：<br>1、<strong>读写性能</strong>比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，<strong>灵活</strong>度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</p>
<p><strong>2 非关系型数据库</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/1013528-20170926114007198-781865994.png" alt="img"></p>
<p>非关系型数据库严格上不是一种数据库，应该是一种<strong>数据结构化存储方法的集合</strong>，可以是文档或者键值对等。<br>优点：<br>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、成本低：nosql数据库部署简单，基本都是开源软件。</p>
<p>缺点：<br>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p>
<p><strong><em>查询语句</em></strong></p>
<p>查询同时选修了选修课1和选修课2的学生学号：</p>
<p>select Sno from sc where Cno in (‘课1’,’课2’) group by Sno having count(*)=2</p>
<p><strong><em>数据库设计三大范式</em></strong></p>
<p>第一范式确保每列保持原子性；</p>
<p>第二范式确保每列都和主键相关，消除非主属性对码的部分依赖；</p>
<p>第三范式确保每列都和主键直接相关，消除非主属性对码的传递依赖。</p>
<p>注：没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。</p>
<p>具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 订单和订单项、相册浏览次数和照片的浏览次数。</p>
<p><strong><em>索引</em></strong></p>
<p><strong>目的</strong>：使查询数据效率快。</p>
<p><strong>分类</strong></p>
<ol>
<li>聚集索引（主键索引）：所有行数都会按照主键索引进行排序。</li>
<li> 非聚集索引：就是给普通字段加上索引。</li>
<li> 联合索引：就是好几个字段组成的索引，称为联合索引。</li>
</ol>
<p><strong>不走索引的情况</strong></p>
<ol>
<li><p>like语句中%在前面的不走索引，在后面的走索引；</p>
</li>
<li><p>用索引列进行计算的，不走索引；</p>
</li>
<li><p>对索引列用函数了，不走索引；</p>
</li>
<li><p>索引列用了!= 不走索引。</p>
</li>
</ol>
<p><strong>B+树</strong></p>
<p>B+树就是为了解决数据量大的时候存储在外存储器时候，查找效率低的问题。</p>
<p>B+树的特点：</p>
<ol>
<li>中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。</li>
<li>所有的中间节点在子节点中要么是最大的元素要么是最小的元素 。</li>
<li>叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。</li>
</ol>
<p>B+树的优势：</p>
<ol>
<li>单个节点可以存储更多的数据，减少<strong>I/O</strong>的次数。</li>
<li>查找性能更<strong>稳定</strong>，因为都是要查找到叶子结点。</li>
<li>叶子结点形成了有序<strong>链表</strong>，便于查询。</li>
</ol>
<p><strong>重复数据加索引</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/35158-20180628110430497-1856877204.png" alt="img"></p>
<p>a、非聚簇索引存储了对主键的引用，如果select字段不在非聚簇索引内，就需要跳到主键索引（上图中从右边的索引树跳到左边的索引树），再获取select字段值</p>
<p>b、如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢</p>
<p>c、如果where值重复率高的字段，select用了limit，只查较少数据，也就是跳的次数很少的情况下，还是可以建索引的（后来想想也没必要，limit限制了数量，全表扫描也很快，除非字段值是排序的，必须扫描完前面的所有值）</p>
<p>d、如果没有3这个前提，则不建议在值重复率高的字段上建索引，因为查询效率低，还需要维护索引</p>
<p><strong><em>4种隔离级别</em></strong></p>
<p>​        数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。</p>
<p><strong>脏读、不可重复读、幻象读</strong>　　</p>
<p>　　脏读：指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。<br>　　不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。<br>　　幻读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</p>
<hr>
<p> <strong>读未提交 （Read uncommitted）</strong></p>
<p>　　读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p>
<p>　　在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。</p>
<hr>
<p> <strong>读提交（Read Committed）</strong> → 脏读</p>
<p>　　 读提交，顾名思义，就是只能读到已经提交了的内容。</p>
<p>​         这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显式的加锁。</p>
<p>　　那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
<p>　　这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”</p>
<p>　　假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而”快照读”就可以完成<strong>高并发</strong>的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。</p>
<hr>
<p>**可重复读(Repeated Read)**→不可重复读</p>
<p>　　可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。</p>
<p>　　不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p>
<p>　　在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“<strong>修改</strong>操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“<strong>插入或者删除</strong>操作（Insert or Delete）”而产生的。</p>
<hr>
<p><strong>序列化 Serializable</strong></p>
<p>　　这是数据库最高的隔离级别，这种级别下，事务“<strong>串行化</strong>顺序执行”，也就是一个一个排队执行。这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
<hr>
<p>值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。</p>
<p><strong><em>数据库引擎</em></strong></p>
<p>​        数据库引擎简单来说就是一个”数据库发动机”。当你访问数据库时，不管是手工访问，还是程序访问，都不是直接读写数据库文件，而是通过数据库引擎去访问数据库文件。以关系型数据库为例，你发SQL语句给数据库引擎， 数据库引擎解释SQL语句，提取出你需要的数据返回给你。因此，对访问者来说，数据库引擎就是SQL语句的<strong>解释器</strong>。</p>
<p>  正式来说，数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可以<strong>控制访问权限并快速处理事务</strong>，从而满足企业内大多数需要处理大量数据的应用程序的要求，这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<p>​        你能用的数据库引擎取决于mysql在安装的时候是如何被<strong>编译</strong>的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下,MYSQL支持三个引擎:<strong>ISAM、MYISAM和HEAP</strong>。另外两种类型<strong>INNODB和BERKLEY（BDB）</strong>，也常常可以使用。</p>
<p>​        <strong>MyISAM</strong>是MySQL的ISAM扩展格式。除了提供ISAM里所没有的<strong>索引</strong> （ISAM允许没有任何索引和主键的表存在，索引都是保存行的地址）和字段管理的大量功能， MyISAM还使用一种表格锁定的机制（<strong>表级锁</strong>），来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。 MYISAM强调了<strong>快速读取操作</strong> ，这可能就是为什么MySQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。</p>
<p>​        <strong>InnoDB</strong>数据库引擎是早就Mysql灵活性的技术的直接产品，这项技术就是mysql+api，在使用mysql的时候，你所面对的每一个挑战几乎都源于isam和myisam数据库引擎不支持事务处理也不支持外键。InnoDB要比isam和myisam引擎<strong>慢</strong>，innoDB为mysql表提供了<strong>acid事务支持</strong>，系统崩溃修复能力和多版本并发控制的<strong>行级锁</strong>，该引擎提供了行级锁和外键约束，所以InnoDB是事务型数据库首选的引擎。采用B+树实现，索引与数据存储在同一文件中。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/image-20210419232705108.png" alt="image-20210419232705108"></p>
<p><strong><em>测试流程</em></strong></p>
<p>需求分析→测试计划→测试设计→测试环境搭建→测试执行→测试记录→缺陷管理→软件评估→测试总结→测试维护</p>
<p><strong><em>测试分类</em></strong></p>
<p>1、按开发阶段：单元测试、集成测试、系统测试、验收测试<br>2、按测试实施组织：α、β、第三方<br>3、按测试执行方式：静态测试、动态测试<br>4、按是否查看代码：黑盒测试、白盒测试、灰盒测试<br>5、按是否手工执行划分：手工测试、自动化测试<br>6、按测试对象划分：性能测试、安全测试、兼容性测试、文档测试、易用性测试（用户体验测试）、业务测试、界面测试、安装测试（功能测试、接口测试）<br>7、按测试地域划分：本地化测试、国际化测试</p>
<p><strong><em>冒烟测试</em></strong></p>
<p>1.冒烟测试是什么？</p>
<p>　　针对每个版本或每次<strong>需求变更</strong>后，在正式测试前，对产品或系统的一次<strong>简单</strong>的验证性测试。</p>
<p>2.冒烟测试的目的</p>
<p>　　为正式测试前，验证是否产品或系统的<strong>主要需求或预置条件</strong>是否存在bug。</p>
<p>3.冒烟测试怎么做？</p>
<p>　　最好的方法，设计出<strong>自动化测试脚本</strong>，每一次版本更新后都可以去执行脚本验证一下。</p>
<p><strong><em>常用自动化测试工具</em></strong></p>
<p>1、Appium</p>
<p>官网：<a target="_blank" rel="noopener" href="http://appium.io/">http://appium.io</a></p>
<p>AppUI自动化测试</p>
<p>Appium 是一个移动端自动化测试开源工具，支持iOS 和Android 平台，支持Python、Java 等语言，即同一套Java 或Python 脚本可以同时运行在iOS 和Android平台，Appium 是一个C/S 架构，核心是一个 Web 服务器，它提供了一套 REST 的接口。当收到客户端的连接后，就会监听到命令，然后在移动设备上执行这些命令，最后将执行结果放在 HTTP 响应中返还给客户端。</p>
<p>License：免费</p>
<p>2、Selenium</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.seleniumhq.org/download/">https://www.seleniumhq.org/download/</a></p>
<p>WebUI自动化测试</p>
<p>Selenium是一个用于Web应用程序测试的工具，Selenium已经成为Web自动化测试工程师的首选。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE(7、8、9)、Mozilla Firefox、Mozilla Suite等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。Selenium 是ThoughtWorks专门为Web应用程序编写的一个验收测试工具。其升级版本为Webdriver。</p>
<p>License：免费</p>
<p>3、Postman</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.getpostman.com/">https://www.getpostman.com</a></p>
<p>接口测试</p>
<p> Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。不仅如此，它还提供测试数据和环境配置数据的导入导出，付费的 Post Cloud 用户还能够创建自己的 Team Library 用来团队协作式的测试，并能够将自己的测试收藏夹和用例数据分享给团队。</p>
<p>License：免费</p>
<p>4、Soapui</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.soapui.org/">https://www.soapui.org</a></p>
<p>接口测试</p>
<p>SoapUI提供了所有所需的工具来测试和完善的测试。总览标签给你一个项目的所有内容和全面的看法。只需一次点击，您可以添加任何数量的断言为验证传入的消息TestStep。使用功能强大的HTTP监视器记录，分析甚至修改客户机 - 服务器通信，因为它发生。和SoapUI临带来了更专业和先进的功能，保持遥遥领先其他测试工具。轻松创建和运行数据驱动测试。该数据源TestStep读取测试数据从任何外部来源 - Excel中，XML，JDBC，文件，等等 - 到标准SoapUI属性。</p>
<p>License：免费</p>
<p>5、Robot Framework</p>
<p>官网：<a target="_blank" rel="noopener" href="http://robotframework.org/">http://robotframework.org</a>  </p>
<p>WebUI自动化测试，接口测试，APP测试</p>
<p>   Robot Framework是一款python编写的功能自动化测试框架。具备良好的可扩展性，支持关键字驱动，可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。主要用于轮次很多的验收测试和验收测试驱动开发。</p>
<p>Robot framework为不同的自动化测试需求提供了不同的框架。它的测试能力可以通过 Python 和 Java 测试库得到扩展。Selenium WebDriver 是 Robot Framework 中内置的流行库。</p>
<p>Robot Framework 不仅仅是网页测试工具，同样可以用来做 Android 和 iOS 的自动化测试。对于关键字测试驱动熟悉的测试员可以轻松上手 Robot Framework。</p>
<p>License：免费  </p>
<p>6、QTP</p>
<p>官网：<a target="_blank" rel="noopener" href="https://software.microfocus.com/en-us/products/unified-functional-automated-testing/overview">https://software.microfocus.com/en-us/products/unified-functional-automated-testing/overview</a></p>
<p>WebUI自动化测试，接口测试，APP测试</p>
<p>HP QuickTest Professional 提供符合所有主要应用软件环境的功能测试和回归测试的自动化。采用关键字驱动的理念以简化测试用例的创建和维护。它让用户可以直接录制屏幕上的操作流程，自动生成功能测试或者回归测试用例。专业的测试者也可以通过提供的内置脚本和调试环境来取得对测试和对象属性的完全控制。目前版本名为Unified Functional Testing，简称UFT。可以测试非常多的应用，比如接口API，Web services，桌面程序，Web系统，手机APP。</p>
<p>License：商业</p>
<p>7、Jmeter</p>
<p>官网：<a target="_blank" rel="noopener" href="https://jmeter.apache.org/">https://jmeter.apache.org</a></p>
<p>接口测试，性能测试</p>
<p>JMeter是Apache组织的开放源代码项目，它是功能和性能测试的工具，100%的用java实现；</p>
<p>JMeter可以用于测试静态或者动态资源的性能（文件、Servlets、Perl脚本、java对象、数据库和查询、ftp服务器或者其他的资源）。JMeter用于模拟在服务器、网络或者其他对象上附加高负载以测试他们提供服务的受压能力，或者分析他们提供的服务在不同负载条件下的总性能情况。你可以用JMeter提供的图形化界面分析性能指标或者在高负载情况下测试服务器/脚本/对象的行为。</p>
<p>使用Jmeter做接口测试需要注意一点，小心使用“用户定义变量”，Jmeter组件有优先级的，如果多个线程同时执行的时候，“用户定义变量”组件定义的变量可能会乱套。</p>
<p>License：免费</p>
<p>8、Loadrunner</p>
<p>官网：<a target="_blank" rel="noopener" href="https://software.microfocus.com/en-us/products/loadrunner-load-testing/overview">https://software.microfocus.com/en-us/products/loadrunner-load-testing/overview</a></p>
<p>性能测试</p>
<p>LoadRunner，是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner能够对整个企业架构进行测试。企业使用LoadRunner能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期。 LoadRunner可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。</p>
<p>License：商业</p>
<p>9、Monkey</p>
<p>App稳定性测试</p>
<p>软件附带在sdk中，适用于android和ios，通过adb shell，生成用户或系统的伪随机事件，压力测试结果：崩溃crash，无响应anr。</p>
<p>License：免费</p>
<p>10、GT</p>
<p>官网：<a target="_blank" rel="noopener" href="http://gt.qq.com/index.html">http://gt.qq.com/index.html</a></p>
<p>App性能测试</p>
<p>GT（随身调）是APP的随身调测平台，它是直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)。利用GT，仅凭一部手机，无需连接电脑，您即可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。</p>
<p>License：免费</p>
<p>11、Appscan</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/downloads/r/appscan/">https://www.ibm.com/developerworks/downloads/r/appscan/</a></p>
<p>安全测试</p>
<p>IBM Security AppScan 是一个适合安全专家的 Web 应用程序和 Web 服务渗透测试解决方案，对现代 Web 应用程序和服务执行自动化的动态应用程序安全测试 (DAST) 和交互式应用程序安全测试 (IAST)，支持 Web 2.0、JavaScript 和 AJAX 框架的全面的 JavaScript 执行引擎，涵盖 XML 和 JSON 基础架构的 SOAP 和 REST Web 服务测试支持 WS-Security 标准、XML 加密和 XML 签名，详细的漏洞公告和修复建议。</p>
<p>License：免费</p>
<p>12、Jenkins</p>
<p>官网：<a target="_blank" rel="noopener" href="https://jenkins.io/">https://jenkins.io</a></p>
<p>持续集成</p>
<p>自动化构建 编译，部署，任务执行，测试报告，邮件通知等。</p>
<p>License：免费</p>
<p><strong><em>Junit @Before @After</em></strong></p>
<p>@Before修饰的方法，会在测试方法之前被自动执行，所有测试方法在执行之前都会执行该方法</p>
<p>@After修饰的方法，会在测试方法执行之后自动被执行，在所有测试方法执行完之后，都会自动执行该方法</p>
<p>无论测试方法是否会出现异常，这两个修饰的方法总是会自动执行的。</p>
<p><strong><em>测试用例</em></strong></p>
<p><strong>设计方法</strong>：等价类划分法、边界值分析法、错误推测法、判定表法、正交实验法。</p>
<p><strong>点赞（抖音）</strong></p>
<ol>
<li>未点赞时，点赞按钮为浅色或灰色；点赞之后为深色或填满。</li>
<li>点赞为零时，不显示点赞数。</li>
<li>点赞大于零时，显示点赞数。</li>
<li>当点赞数过大时，达到千或万（有时百），需考虑简化点赞数，如1k或1w（跟手机屏幕也有关系）。</li>
<li>取消点赞时，点赞数需跟着减少。</li>
<li>每人每天点赞次数，按业务设置上限。</li>
<li>点赞到达上限时，是否有提示用户点赞达到上限。</li>
</ol>
<p><strong>搜索</strong></p>
<p>1：不输入任何字符，点击搜索按钮，一般搜索出网站所有的信息</p>
<p>2：一般搜索输入框中的有<strong>文章</strong>显示，当鼠标点击时，文章消失</p>
<p>3：输入全角/半角中文字符（一个字符、超长字符、已经信息字符）</p>
<p>4：输入全角/半角英文字符（一个字符、超长字符、已经信息字符）</p>
<p>5：输入全角/半角特殊字符~!@#$%^&amp;*()_+|{}:”&lt;&gt;?.,;’[]=-(注意单引号经常会发现bug)</p>
<p>6：输入全角/半角中英文空格</p>
<p>7：输入html语言</p>
<p>8：输入特殊字符串NULL、null、&amp;nbsp空格的转义字 符；&lt;scrīpt&gt;&lt;/scrīpt&gt;；<br>；<tr>；<td>；&lt; /tr&gt;；</td>；</html>；</body>；</table></p>
<p>9：输入javascript</p>
<p><strong>电梯</strong></p>
<p>测试电梯能否实现正常的上升和下降功能，每层是否都可以停靠。</p>
<p>每层停靠楼层是否与所按的楼层一致</p>
<p>电梯按键在按下时是否点亮按键灯</p>
<p>电梯在每个楼层的上行和下行的申请是否可以有效</p>
<p>电梯满负载的时候，是否会忽略其他楼层外部的上行和下行申请</p>
<p>电梯的两边按钮是否都可以使用，三列按钮。</p>
<p>电梯的楼层选择是否可以取消电梯门的打开，关闭是否正常关闭（自动关闭）。</p>
<p>报警装置是否可用。</p>
<p>（满载）超重时是否能强制关门超重时重新挪动一下人员是否可以上下行与另外一部电梯之间是否协作良好。</p>
<p>（算法）电梯的灯光是否满足看书的要求联系外界的电话是否可用通风状况如何，人多的时候是否会很热，通风不畅（排气扇）</p>
<p>电梯里面的摄像头是否可用，拍摄是否清晰</p>
<p>门不夹人伸手的话，应该不会强制关门管理员可以和内部人通话在各种场合下，可以强制开门运行中时，不能按开门键，不会强制开门在不同情况下（如：有人挡着、马上关门的时候、停电的时候、没有请求的时候…），一直按开门键和关门键从电梯外部可以强制开门</p>
<p><strong>购物车</strong></p>
<p>功能性测试:</p>
<p>1.购物车是否可以添加商品</p>
<p>2.购物车的优惠券是否可以使用</p>
<p>3.购物车的计算结果是否正确</p>
<p>4.如果使用购物券购物车里面的价格是否发送改变</p>
<p>5.未登录时购物车是否可以正常显示</p>
<p>6.如果没有登录会不会让你登录之后才可以使用</p>
<p>7.所有的页面链接功能是否正常，是否可以正确跳转到指定页面</p>
<p>8.商品没有勾选时结算按钮是否可以点击</p>
<p>9.购物车页面时用户是否可以取消订单，或者进入订单和客服进行聊天</p>
<p>10.卖家在线时是否显示在线</p>
<p>11.购物车添加的商品是否可以有数量上限</p>
<p>12.购物车点击几件商品时点击结算会不会跳转到支付页面</p>
<p>13.是否可以批量删除商品</p>
<p>14.如果没有在指定时间下单，订单会不会自动失效并在购物车清除该商品信息</p>
<p>15.可否对添加的商品是否可以进行 增加</p>
<p>16.商品信息过长是否可以显示完整</p>
<p>17.商品是否可以进行收藏并推荐相似的商品（宝贝）</p>
<p>18.购物车中的降价商品，库存紧张商品是否成功分类<br>19.购物车商品降价时，购物车是否显示降价信息</p>
<p>性能性测试:</p>
<p>20.打开购物车这个页面需要多长时间</p>
<p>21.弱网时是否还可以进行添加商品，计算商品的价格并且可以正常结算</p>
<p>22.无网状态下是否提醒请检测你的网络设置</p>
<p>23.用户过多会不会使购物车服务器崩溃</p>
<p>24.编辑购物车：删除、添加商品需要的时间。</p>
<p>25.在购物车页面选择需要购买的商品进行结算的时候，结算金额可不可以实时显示。</p>
<p>26.清空失效商品需要的时间。</p>
<p>兼容性测试</p>
<p>27.ios:不同型号，不同ios的手机系统的耗电情况，打开速度，安装后是否闪退，卸载</p>
<p>28.安卓：不同品牌，不同型号，不同的安卓系统，手机系统的耗电情况，打开速度，安装后是否闪退，卸载<br>29.web端的打开速度</p>
<p>界面测试</p>
<p>30.购物车界面是否完善</p>
<p>31.各个功能的设计是否美观 ，大小是否合适</p>
<p>32.页面的功能按钮可以正常显示。</p>
<p>33.商品的最下方显示失效宝贝。</p>
<p>34.页面的最低端显示“你可能喜欢”</p>
<p>35.购物车中如果存在有商品降价、库存不足、限购件数等，在商品详情的下面，会有对应的字体展示</p>
<p>安全性测试</p>
<p>36.用户实名认证后个人信息是否会泄露</p>
<p>37.是否需要绑定手机号</p>
<p>易用性测试</p>
<p>38.是否方便人们操作</p>
<p>39.是否有免密码支付功能</p>
<p>40.是否具有青少年模式</p>
<p><strong><em>测试场景</em></strong></p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><strong><em>Git常用命令</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/bg2015120901.png" alt="img"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong><em>自我介绍</em></strong></p>
<p>优缺点：严谨，认真，计划 （同理心） / 想太多，行动力不足 （优柔寡断）</p>
<p>阅读书籍：亲密关系</p>
<p>职业规划：测试 / 开发</p>
<p>最失败的事：高考</p>
<p><strong><em>项目介绍</em></strong></p>
<p><strong>项目一：基于 SSM 框架的在线学习系统</strong></p>
<p>基本介绍：</p>
<p>项目难点：</p>
<p>解决方法：</p>
<p><strong>项目二：人脸识别考勤报表系统</strong></p>
<p>基本介绍：</p>
<p>项目难点：</p>
<p>解决方法：</p>
<p><strong><em>拓展知识</em></strong></p>
<p><strong>CDN</strong></p>
<p><strong>全称</strong>:Content Delivery Network或Content Ddistribute Network，即<strong>内容分发网络</strong></p>
<p><strong>基本思路</strong>：</p>
<p>尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置<strong>节点服务器</strong>所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户<strong>最近的服务节点</strong>上。</p>
<p><strong>目的</strong>：</p>
<p>解决因分布、带宽、服务器性能带来的<strong>访问延迟</strong>问题，适用于站点加速、点播、直播等场景。使用户可<strong>就近取得所需内容</strong>，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。</p>
<p>控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。</p>

        </div>

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev btn"
                           rel="prev"
                           href="/2021/04/24/JVM%E6%8E%A2%E7%A9%B6/"
                        >
                            <i class="fa fa-chevron-left"></i>
                            <span class="post-nav-title-item">JVM探究</span>
                            <span class="post-nav-item">上一篇</span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next btn"
                           rel="next"
                           href="/2021/03/20/SpringBoot%E6%95%99%E7%A8%8B/"
                        >
                            <span class="post-nav-title-item">SpringBoot教程</span>
                            <span class="post-nav-item">下一篇</span>
                            <i class="fa fa-chevron-right"></i>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                    

                </main>

            </div>

            <div class="page-main-content-bottom">
                <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy; 2021 <i class="fa fa-heart-o"></i> <a href="/">Homgun</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a
                    href="https://github.com/XPoet/hexo-theme-ils" target="_blank">ILS v2.1.0</a>
        </div>
    </div>
</footer>

            </div>
        </div>
    </main>

    <div class="sidebar-tools">
        <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fa fa-search"></i>
            </li>
        

        

        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa fa-outdent"></i>
            </li>
        

    </ul>
</div>

    </div>

    <div class="sidebar-tools-2">
        <div class="tools2-container">

    <button class="tools-button">
        <i class="fa fa-plus"></i>
    </button>

    <ul class="tools-wrapper">
        <!-- back2top -->
        
            <li class="tools-item scroll-to-bottom">
                <i class="fa fa-arrow-down"></i>
            </li>
            <li class="tools-item scroll-to-top">
                <i class="fa fa-arrow-up"></i>
            </li>
        

        <!-- mode toggle -->
        <li class="tools-item mode-toggle">
            <i class="fa fa-moon-o"></i>
        </li>

        <!-- rss -->
        


    </ul>
</div>

    </div>


    <!-- page aside -->
    <aside class="page-aside">
        
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java"><span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95"><span class="nav-text">编程算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%88%E9%94%81-JVM%EF%BC%89"><span class="nav-text">实现细节（锁 &#x2F; JVM）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%EF%BC%88%E5%90%AB%E5%89%8D%E7%AB%AF%EF%BC%89"><span class="nav-text">框架（含前端）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-text">分布式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-text">网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-text">工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol>
    </div>
</div>
        
    </aside>

</div>



    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fa fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="/js/utils.js"></script>
<script src="/js/header-shrink.js"></script>
<script src="/js/dark-light-toggle.js"></script>
<script src="/js/main.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/back2top.js"></script>





    
<script src="/js/left-side-toggle.js"></script>


    
        
<script src="/js/code-copy.js"></script>

    

    
        
<script src="/lib/anime.min.js"></script>
<script src="/js/toc.js"></script>

    


</body>
</html>
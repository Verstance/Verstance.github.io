<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    
    <title>
        面试整理（Java+测开） |
        
        Homgun&#39;s Blog
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <link rel="shortcut icon" href="/images/favicon.png">
    
    
<link rel="stylesheet" href="/css/style.css">

    <script id="hexo-configurations">
    let ILS = window.ILS || {};
    let CONFIG = {"hostname":"example.com","root":"/","localsearch":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"themeInfo":{"name":"ILS","version":"2.1.0","author":"XPoet","repository":"https://github.com/XPoet/hexo-theme-ils"},"toc":{"enable":true,"number":false,"expand_all":true},"back2top":{"enable":true},"path":"search.json"};
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
<div class="page-container">

    <header class="page-header">
        <div class="header-progress"></div>
    </header>

    <main class="page-main">

        <div class="page-main-content">

            <div class="page-main-content-top">
                <header class="header-wrapper">

    <div class="header-content">

        <a class="logo-title" href="/">
            Homgun&#39;s Blog
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        首页
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        归档
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/tags"
                    >
                        标签
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


            </div>

            <div class="page-main-content-middle">

                <main class="main-content normal-code-theme">

                    
                        <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <h3><a class="title-hover-animation">面试整理（Java+测开）</a></h3>
        </div>

        <div class="meta-info">
            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa fa-calendar-o"></i> 2021-04-14 22:38:03
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%B5%8B%E8%AF%95/">测试</a>
                    </li>
                
            </ul>
        </span>
    
    
    
        <span class="article-wordcount article-meta-item">
        <i class="fa fa-book"></i> <span>37.4k 字</span>
        </span>
    
    
</div>

        </div>

        <div class="article-content markdown-body">
            <h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5><p><strong><em>C++ / Java / Python</em></strong> </p>
<p>首先，C++、Java和Python都是面向对象的编程语言，也都是<strong>强类型</strong>语言。</p>
<p>C++更接近于底层，方便直接操作内存。C++有<strong>指针</strong>的概念，但是由于指针在使用的过程中，如果没有处理好，容易出现空指针和野指针，带来一些麻烦，因此Java去掉了指针的功能，规避了指针使用中可能存在的混乱情况。</p>
<p>Java在C++的基础上又做了更高级的封装，具有良好的平台间的<strong>可移植性</strong>。C++一次编写到处编译，而Java一次编译到处运行。Java中的功能C++都能够实现，只是相对来说在编程方面会比较复杂一些。</p>
<p>C++ 编译成本地机器码, 可以由操作系统直接运行，<strong>运行效率</strong>较高。Java 编译成字节码，需由Java虚拟机读取运行， 所以效率偏低，但可通过JIT提高运行效率。</p>
<p><strong>垃圾回收</strong>方面，C++需要程序员自己回收，对内存进行良好的管理，而Java则不需要程序员自己完成这个工作，有自己的垃圾回收机制。</p>
<p>Python比较容易学习，<strong>语法</strong>很简单，融入了很多现代编程语言的特性。python的<strong>库</strong>非常丰富，可以迅速地开发程序，无论是网站还是小游戏都非常方便。不过，python的脚本的运行效率较低，不适合对运行效率要求较高的程序。</p>
<p><strong><em>JDK / JRE / JVM</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5c4525d700015dc612800720.jpg" alt="img"></p>
<p>JDK是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。JVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。<br>JVM体系结构与运行原理：<br>Java语言写的源程序通过Java编译器，<strong>编译</strong>成与<strong>平台无关</strong>的‘<strong>字节码</strong>程序’(.class文件，也就是0，1二进制程序)，然后在OS之上的Java解释器中<strong>解释执行</strong>。</p>
<p><strong><em>final关键字</em></strong>（***）</p>
<p>final用于修饰类、成员变量和成员方法。</p>
<ul>
<li>final修饰的类：不能被<strong>继承</strong>（String、StringBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被<strong>重写</strong>（这里需要注意的是不能被重写，但是可以被重载），所以不能同时用abstract和final修饰类（abstract修饰的类是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；</li>
<li>final修饰的方法：不能被<strong>重写</strong>，但是子类<strong>可以用</strong>父类中final修饰的方法；</li>
<li>final修饰的成员变量：是<strong>不可变</strong>的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是<strong>对象当中的内容是允许改变</strong>的。</li>
</ul>
<p><strong><em>static关键字</em></strong></p>
<p>JAVA类在加载时类信息、全局变量和方法、静态变量、final修饰的变量会被存到<strong>方法区</strong>，局部变量存储在栈内存中，当实例化一个对象时就将非static修饰的方法和变量复制到堆内存中以便对象引用，线程则被加载到寄存器运行。</p>
<p>所以static修饰的变量和方法是独立于对象而存在的，不产生副本，可以直接用类名来调用。</p>
<p>一.static修饰的变量<br>static修饰的变量当且仅当<strong>类被加载</strong>时初始化。而非static变量在实例化对象时被初始化，产生多个副本，多个对象不互相影响。<strong>局部变量不能被static修饰</strong></p>
<p>二.static修饰的方法<br>被static修饰的方法内部不能调用非static的变量和方法，非static方法内部可以调用static变量的方法和变量。</p>
<p>三.static修饰的内部类</p>
<p>普通类是不允许声明为静态的，只有内部类才可以。</p>
<p>被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。</p>
<p>需要注意的是当一个内部类没有使用static修饰的时候，是不能直接使用内部类创建对象，须要先使用外部类对象点new内部类对象（outerObject.new InnerClass() → new OuterClass.InnerClass() ）。</p>
<p>四.static修饰的代码块<br>static修饰的代码块在且只在类被加载时<strong>执行一次</strong>。</p>
<p>执行顺序：static代码块<strong>优于</strong>构造块优于构造方法。</p>
<p><strong><em>抽象类 / 接口</em></strong>　　</p>
<p>1）抽象类可以提供成员方法的<strong>实现细节</strong>，而接口中只能存在public abstract 方法；</p>
<p>2）抽象类中的成员变量可以是<strong>各种类型</strong>的，而接口中的成员变量只能是public static final类型的；</p>
<p>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有<strong>静态</strong>代码块和静态方法；</p>
<p>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p><strong><em>HashMap</em></strong>（***）</p>
<p><strong>数据结构</strong>：数组+链表（+红黑树）</p>
<p><strong>插入方式</strong>：头插→尾插</p>
<p><strong>冲突解决</strong>：拉链法 </p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/622ed3ed0001bf4011700540.jpg" alt="img"></p>
<p><strong><em>HashSet</em></strong></p>
<p><strong>实现原理</strong>：HashSet是基于HashMap实现的，都是一个存放链表的数组。它不保证存储元素的迭代顺序，允许使用null元素，不允许有重复元素。当向HashSet中添加对象时，首先调用此对象所在类的hashCode()方法，计算次对象的哈希值，此哈希值决定了此对象在HashSet中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。因此，如果想实现自定义去重，需要重写model的hashcode方法和equals方法。</p>
<p><strong>HashSet和HashMap的区别</strong>：<br>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对；</p>
<p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true。</p>
<p><strong>线程不安全</strong></p>
<p><code>HashMap</code>的线程不安全体现在会造成<strong>死循环</strong>、<strong>数据丢失</strong>、<strong>数据覆盖</strong>这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖这样的问题。</p>
<p><code>HashMap</code>的线程不安全主要是发生在扩容函数中，即根源是在<code>transfer</code>函数中；</p>
<p>JDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，1.8的源码中不存在<code>transfer</code>函数，因为JDK1.8直接在<code>resize</code>函数中完成了数据迁移。而且JDK1.8在进行元素插入时使用的是<strong>尾插法</strong>。</p>
<p><strong>ConcurrentHashMap</strong></p>
<p>​        与HashMap不同，ConcurrentHashMap采用<strong>分段锁</strong>的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每 个Segment均继承自ReentrantLock并单独加锁，所以每次进行加锁操作时锁住的都是一个 Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。 </p>
<p>​        在ConcurrentHashMap中有个concurrencyLevel参数表示并行级别，默认是 16，也就是 说ConcurrentHashMap<strong>默认由 16个Segments组成</strong>，在这种情况下最多同时支持 16个线程并 发执行写操作，只要它们的操作分布在不同的Segment上即可。并行级别concurrencyLevel 可以在初始化时设置，一旦初始化就不可更改。ConcurrentHashMap的每个Segment内部的 数据结构都和HashMap相同。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200e2960001672819201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200e2f700011c0519201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200e35c0001834d19201080.jpg" alt="img"></p>
<p><strong><em>权限修饰符（可见性修饰符）</em></strong></p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内访问</th>
<th align="center">包内访问</th>
<th align="center">子类访问</th>
<th align="center">不同包访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center"><strong>默认</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"><strong>×</strong></td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>​    子类可以覆盖父类的 protected 方法，并把该方法的可见性改成 public。但是子类<strong>不能降低父类方法的可见性</strong>，即不能把父类的 public 方法的可见性改成 protected。</p>
<p><strong><em>序列化</em></strong></p>
<p>​        把对象转换成字节序列的过程称为对象的序列化，把字节序列恢复成对象的过程称为对象的反序列化。</p>
<p>​        <code>Serializable</code> 接口的作用是标识一个对象是否可被序列化，只有当一个类实现了 Serializable 接口时，这个类的实例才是可序列化的。这个接口是<strong>标识接口</strong>，不包含任何数据域和方法。</p>
<p>​        关键字 <code>transient </code>的作用是指定数据域<strong>不被序列化</strong>。当一个数据域不能被序列化，或者不想对一个数据域序列化时，给这个数据域加上关键字<code> transient</code>，在序列化的过程中将忽略这个数据域。</p>
<p><strong><em>注解作用</em></strong></p>
<ul>
<li>内置注解可以实现<strong>编译检查</strong>（@Override：重写父类方法 @Deprecated：不推荐使用 @SuppressWarnings(“all”)：抑制警告）；</li>
<li>注解可以附加在package, class, method, field等上面，添加额外的辅助信息（元数据），可以通过<strong>反射机制</strong>编程实现对这些<strong>元数据</strong>的访问；</li>
<li>注解的功能类似于代码中的注释，所不同的是注解使得Java源代码可以包含功能性的实现代码，不仅提供代码功能的说明，而且<strong>实现程序功能</strong>的重要组成部分；</li>
<li>Java注解已经在很多框架中得到了广泛的使用，用来<strong>简化程序中的配置</strong>，减少配置文件的数量。（比较常见的是Spring等框架中的<strong>基于注解配置</strong>。）</li>
</ul>
<p><strong><em>BIO / NIO / AIO</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200f8d70001744919201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200f91900019a1d19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200f9b5000168c319201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6200faf0000194ee19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6077dc6800017a1619201080.jpg" alt="img"></p>
<p>BIO适用于连接数小且固定的架构，NIO适用于连接数多且连接短的架构（比如聊天服务器），NIO适用于连接数多且连接长的架构（比如相册服务器）。</p>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p><strong><em>线程实现</em></strong></p>
<p><strong>方式一：继承Thread类的方式</strong></p>
<ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类中的run()：将此线程要执行的操作声明在run()</li>
<li>创建Thread的子类的对象</li>
<li>调用此对象的start():①启动线程 ②调用当前线程的run()方法</li>
</ol>
<p><strong>方式二：实现Runnable接口的方式</strong></p>
<ol>
<li>创建一个实现Runnable接口的类</li>
<li>实现Runnable接口中的抽象方法：run():将创建的线程要执行的操作声明在此方法中</li>
<li>创建Runnable接口实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>调用Thread类中的start():① 启动线程 ② 调用线程的run() —&gt;调用Runnable接口实现类的run()</li>
</ol>
<p>实现Runnable好处：</p>
<ol>
<li>避免了继承Thread类的<strong>单继承</strong>的局限性。</li>
<li>Runable接口出现更符合<strong>面向对象</strong>，将线程单独进行对象的封装。</li>
<li>Runnable接口出现，降低了线程对象和线程任务的<strong>耦合性</strong>。</li>
</ol>
<p>所以创建线程的方式常使用Runnable接口。</p>
<p>以下两种方式是jdk1.5新增的！</p>
<p><strong>方式三：实现Callable接口</strong></p>
<p>说明：</p>
<ol>
<li>与使用Runnable相比， Callable功能更强大些</li>
<li>实现的call()方法相比run()方法，可以<strong>返回值</strong></li>
<li>方法可以抛出<strong>异常</strong></li>
<li>支持<strong>泛型</strong>的返回值</li>
<li>需要借助FutureTask类，比如获取<strong>返回结果</strong></li>
</ol>
<ul>
<li>Future接口可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<p><strong>方式四：使用线程池</strong></p>
<p>说明：</p>
<ul>
<li>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
</ul>
<p>好处：</p>
<ol>
<li> 提高响应<strong>速度</strong>（减少了创建新线程的时间）</li>
<li> 降低<strong>资源</strong>消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li> 便于线程<strong>管理</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式四</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 继承Thread</span></span><br><span class="line">		ThreadTest thread = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">		thread.setName(<span class="string">&quot;方式一&quot;</span>);</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现Runnable</span></span><br><span class="line">		RunnableTest runnableTest = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(runnableTest, <span class="string">&quot;方式二&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现Callable&lt;&gt; 有返回值</span></span><br><span class="line">		CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">		FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callableTest);</span><br><span class="line">		<span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;方式三&quot;</span>).start();</span><br><span class="line">		<span class="comment">// 返回值</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Integer integer = futureTask.get();</span><br><span class="line">			System.out.println(<span class="string">&quot;返回值（sum）：&quot;</span> + integer);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 线程池</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor) pool;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 可以做一些操作:</span></span><br><span class="line"><span class="comment">		 * corePoolSize：核心池的大小 </span></span><br><span class="line"><span class="comment">		 * maximumPoolSize：最大线程数</span></span><br><span class="line"><span class="comment">		 * keepAliveTime：线程没任务时最多保持多长时间后会终止</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开启线程</span></span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> ThreadPool());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>线程池</em></strong></p>
<p><strong>理解</strong>：线程池是一种线程的使用模式。创建若干个可执行的线程放入一个池（容器）中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程并不会被销毁，而是仍然在线程池中等待下一个任务。</p>
<p><strong>好处</strong></p>
<ul>
<li><p>降低<strong>资源</strong>消耗。重复利用线程池中已经创建的线程，可以避免频繁地创建和销毁线程，从而减少资源消耗。</p>
</li>
<li><p>提高<strong>响应</strong>速度。由于线程池中有已经创建的线程，因此当任务到达时，可以直接执行，不需要等待线程创建。</p>
</li>
<li><p>提高线程的<strong>可管理</strong>性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
</li>
</ul>
<p><strong>使用</strong></p>
<p>可以通过 <strong>ThreadPoolExecutor 类创建线程池</strong>。ThreadPoolExecutor 类有 4 个构造方法，其中最一般化的构造方法包含 7 个参数。</p>
<p>corePoolSize：核心线程数，定义了最少可以同时运行的线程数量，当有新的任务时就会创建一个线程执行任务，当线程池中的线程数量达到 corePoolSize 之后，到达的任务进入阻塞队列。</p>
<p>maximumPoolSize：最大线程数，定义了线程池中最多能创建的线程数量。</p>
<p>keepAliveTime：等待时间，当线程池中的线程数量大于 corePoolSize 时，如果一个线程的空闲时间达到 keepAliveTime 时则会终止，直到线程池中的线程数不超过 corePoolSize。</p>
<p>unit：参数 keepAliveTime 的单位。</p>
<p>workQueue：阻塞队列，用来存储等待执行的任务。</p>
<p>threadFactory：创建线程的工厂。</p>
<p>handler：当拒绝处理任务时的策略。</p>
<p>可以通过<strong>方法 execute 向线程池提交任务</strong>。该方法被调用时，线程池会做如下操作。</p>
<ul>
<li><p>如果正在运行的线程数量小于 corePoolSize，则创建核心线程运行这个任务。</p>
</li>
<li><p>如果正在运行的线程数量大于或等于 corePoolSize，则将这个任务放入阻塞队列。</p>
</li>
<li><p>如果阻塞队列满了，而且正在运行的线程数量小于 maximumPoolSize，则创建非核心线程运行这个任务。</p>
</li>
<li><p>如果阻塞队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，则线程池抛出 RejectExecutionException 异常。</p>
</li>
</ul>
<p>上述操作中提到了两个概念，「核心线程」和「非核心线程」。核心线程和非核心线程的最大数目在创建线程池时被指定。核心线程和非核心线程的区别如下。</p>
<p>向线程池提交任务时，首先创建核心线程运行任务，直到核心线程数到达上限，然后将任务放入阻塞队列。</p>
<p>只有在核心线程数到达上限，且阻塞队列满的情况下，才会创建非核心线程运行任务。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60779c2e0001dbb419201080.jpg" alt="img"></p>
<p><strong><em>线程状态</em></strong></p>
<ol>
<li><p>**新建(NEW)**：新创建了一个线程对象。</p>
</li>
<li><p>**可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p>**运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p>**阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
</li>
</ol>
<blockquote>
<p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
</blockquote>
<ol start="5">
<li>**死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ol>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60768dba0001cbb017281080.jpg" alt="img"></p>
<p><strong><em>synchronized</em></strong></p>
<p>synchronized关键字用于为Java对象、方法、代码块提供线程安全的操作。</p>
<p>synchronized属于独占式的悲观锁，同时属于可重入锁。</p>
<p>在使用synchronized修饰对象时， 同一时刻只能有一个线程对该对象进行访问；在synchronized修饰方法、代码块时，同一时刻只能有一个线程执行该方法体或代码块，其他线程只有等待当前线程执行完毕并释放锁资源后才能访问该对象或执行同步代码块。</p>
<p> Java中的每个对象都有个monitor对象，加锁就是在竞争monitor对象。对代码块加锁 是通过在前后分别加上monitorenter和monitorexit指令实现的，对方法是否加锁是通过一个 标记位来判断的。 </p>
<p><strong>作用范围</strong>：</p>
<p> ◎ synchronized作用于成员变量和非静态方法时，锁住的是对象的实例，即this对象。 </p>
<p>◎ synchronized作用于静态方法时，锁住的是Class实例，因为静态方法属于Class而不 属于对象。</p>
<p> ◎ synchronized作用于一个代码块时，锁住的是所有代码块中配置的对象。 </p>
<p><strong>静态方法 / 非静态方法</strong></p>
<p>1.Synchronized修饰非静态方法，实际上是<strong>对调用该方法的对象加锁</strong>，俗称“对象锁”。</p>
<p>情况1：同一个对象在两个线程中分别访问该对象的两个同步方法</p>
<p>结果：会产生互斥。</p>
<p>解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。</p>
<p><strong>情况2</strong>：<strong>不同对象</strong>在两个线程中调用同一个同步方法</p>
<p>结果：不会产生互斥。</p>
<p>解释：因为是两个对象，<strong>锁针对的是对象</strong>，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，</p>
<p>2.Synchronized修饰静态方法，实际上是<strong>对该类对象加锁</strong>，俗称“类锁”。</p>
<p>情况1：用类直接在两个线程中调用两个不同的同步方法</p>
<p>结果：会产生互斥。</p>
<p>解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。</p>
<p>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。</p>
<p>情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法</p>
<p>结果：会产生互斥。</p>
<p>解释：因为是一个对象调用，同上。</p>
<p><strong>情况3</strong>：一个对象在两个线程中分别调用<strong>一个静态同步方法和一个非静态同步方法</strong></p>
<p>结果：不会产生互斥。</p>
<p>解释：因为虽然是一个对象调用，但是两个方法的<strong>锁类型不同</strong>，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/601a7fb80001add317281080.jpg" alt="img"></p>
<p><strong><em>锁升级</em></strong></p>
<p>偏向锁/轻量级锁/重量级锁</p>
<p>这三种锁是指锁的状态，并且是针对Synchronized。</p>
<p><strong>偏向锁</strong>是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
<p><strong>轻量级锁</strong>是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
<p><strong>重量级锁</strong>是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。 重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6076d2b50001315c19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/608a5d3d0001cd5e19201080.jpg" alt="img"></p>
<p><strong><em>锁</em></strong></p>
<p>(synchronized、juc 提供的锁如 ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore等)</p>
<p>公平锁/非公平锁 (重要)</p>
<p>可重入锁</p>
<p>独享锁/共享锁 (重要)</p>
<p>互斥锁/读写锁</p>
<p>乐观锁/悲观锁 (重要)</p>
<p>偏向锁/轻量级锁/重量级锁 (重要)</p>
<p>自旋锁</p>
<p><strong><em>乐观锁 / 悲观锁</em></strong><br>乐观锁与悲观锁区别在于看待并发同步的角度。悲观锁对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p>
<p>乐观锁适用于多读的应用类型，这样可以<strong>提高吞吐量</strong>。在Java中java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>乐观锁适用于写比较少的情况下（多读场景），一般多写的场景下用悲观锁就比较合适，一 般会经常<strong>产生冲突</strong>，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能。</p>
<p><strong><em>自旋锁</em></strong></p>
<p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样 的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<p><strong><em>乐观锁</em></strong>（**）</p>
<p>​        乐观锁采用乐观的思想处理数据，在<strong>每次读取数据时都认为别人不会修改该数据，所以不会上锁</strong>，但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法。具体过程为：比较当前版本号与上一次的版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读、比较、写操作。</p>
<p>​         Java中的乐观锁大部分是通过CAS（Compare And Swap，比较和交换）操作实现的， CAS是一种<strong>原子更新操作</strong>，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。</p>
<p><strong><em>volatile / synchronized</em></strong></p>
<ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在代码块、方法和类级别的</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
</ul>
<p><strong><em>sleep / wait</em></strong></p>
<p><strong>语法区别</strong>：</p>
<p>sleep是Thread类的方法，wait是Object的方法</p>
<p>sleep方法可以在任何地方使用</p>
<p>wait方法只能在synchronized方法或synchronized块中使用（获取锁了才能释放锁）</p>
<p><strong>本质区别</strong>：</p>
<p>Thread.sleep只会让出cpu，不会改变锁行为</p>
<p>Object.wait不仅让出cpu，还会释放已经占有的同步资源锁</p>
<p><strong><em>notify / notifyAll</em></strong></p>
<p>两个概念：</p>
<ul>
<li><p>锁池EntryList：等待此对象锁释放的地方就是该对象的锁池</p>
</li>
<li><p>等待池WaitSet：线程A调用了某个对象的wait方法，就会释放该对象的锁，同时线程A就进入到了该对象的等待池，等待池中的线程不会去竞争该对象锁</p>
</li>
</ul>
<p>notifyAll会让<strong>所有</strong>处于等待池中的线程全部进入锁池去<strong>竞争获取锁的机会</strong>；</p>
<p>而notify只会<strong>随机选取一个</strong>等待池中的线程进入锁池去竞争。</p>
<p><strong><em>JUC包</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/61c1232c0001b54d06400360.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/61ae4e240001b4f819201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/61c1232f0001410906400360.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/608802340001d75419201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6088024700014a6719201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6088025c0001348619201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6088026a000166ef19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/608802750001fb7c19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/608802e8000126a719201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/608803240001c0c019201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6088033d000116f219201080.jpg" alt="img"></p>
<h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h5><p><strong><em>一次编译，到处执行</em></strong></p>
<p>JVM是一个java虚拟机，所谓的java虚拟机就是和普通的虚拟机一样，拥有自己的CPU，RAM之类的。我们所使用的操作系统是Windows的操作系统，Windows操作系统支持的可执行文件是EXE文件，也就是说在Windows的操作系统上只有EXE的文件是可以直接被操作系统解释为底层机器语言并进行运行的。而java虚拟机可以支持的是.class的可执行文件，在java的虚拟机中遇到.class的文件就可以直接<strong>翻译成java虚拟机所能识别的底层机器语言</strong>并进行执行。这就是JVM的机制，正是因为java的这种机制才实现了java的跨平台，在不同的平台上安装能够在相应平台上运行的虚拟机，然后在java虚拟机中运行java的源程序，“一次编译，多次执行”就此实现了。</p>
<p>所以java的跨平台是离不开虚拟机的支持的。虚拟机充当着java源程序和操作系统之间的中介，不同的操作系统只需要寻找相应的中介就可以实现在不同的操作系统上运行。而java的编译只是吧.java文件编译为.class字节码文件而已，然后把字节码交给虚拟机去执行。</p>
<p>虚拟机在执行的时候是读一句字节码文件人后解释一句给操作系统听，这就是为什么java是解释型的语言。</p>
<p>所谓的编译型的语言是指这种语言被编译之后生成的是可以直接供操作系统执行的010101文件，像C，C++都是编译型的，java因为中间有JVM这么个东西所以是解释型的。</p>
<p><strong><em>JVM体系结构</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/608808b700011d4e19201080.jpg" alt="img"></p>
<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/1377269-20200115202410991-705795907.jpg" alt="img"></p>
<p>注：</p>
<ul>
<li><p>程序计数器是唯一不会出现 OutOfMemoryError 的内存区域。</p>
</li>
<li><p>虚拟机栈描述的是 Java <strong>方法</strong>执行的内存模型。当一个方法被执行时会创建栈帧存入栈内，栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>
</li>
<li><p>虚拟机栈可能出现的两种异常是 StackOverflowError 和 OutOfMemoryError。</p>
</li>
<li><p>如果虚拟机栈不可以动态扩展，当线程请求的栈深度大于虚拟机所允许的深度时，将抛出 StackOverflowError 异常；<br>如果虚拟机栈可以动态扩展，当无法申请到足够的内存时，将抛出 OutOfMemoryError 异常。</p>
</li>
<li><p>堆是 Java 虚拟机管理的内存中最大的一块，其目的是存放对象实例，几乎所有的对象实例都在堆中分配内存。</p>
</li>
<li><p>静态变量存放在方法区。</p>
</li>
</ul>
<p><strong><em>引用类型</em></strong></p>
<p>在Java中一切皆对象，<strong>对象</strong>的操作是通过该对象的引用（Reference）实现的，Java中 的引用类型有4种，分别为强引用、软引用、弱引用和虚引用。 </p>
<p>（1）强引用：在Java中最常见的就是强引用。在把一个对象赋给一个引用变量时， 这个引用变量就是一个强引用。有强引用的对象一定为可达性状态，所以不会被垃圾回收 机制回收。因此，强引用是造成Java内存泄漏（Memory Link）的主要原因。 </p>
<p>（2）软引用：软引用通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。 </p>
<p>（3）弱引用：弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。 </p>
<p>（4）虚引用：虚引用通过PhantomReference类实现，虚引用和引用队列联合使用， 主要用于跟踪对象的垃圾回收状态。</p>
<p><strong><em>内存泄露</em></strong></p>
<p><strong>原因</strong></p>
<p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。</p>
<p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p>
<p><strong>1、静态集合类引起内存泄漏：</strong></p>
<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>
<p><strong>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</strong></p>
<p><strong>3、监听器</strong></p>
<p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
<p><strong>4、各种连接</strong></p>
<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p>
<p><strong>5、内部类和外部模块的引用</strong></p>
<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：</p>
<p>public void registerMsg(Object b);</p>
<p>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>
<p><strong>6、单例模式</strong></p>
<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</p>
<p><strong><em>垃圾回收</em></strong></p>
<p><strong>内存分配</strong></p>
<p>​        Java 堆可以分成新生代和老年代，新生代又可以细分成 Eden 区、From Survivor 区、To Survivor 区等。对于不同的对象，有相应的内存分配规则。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/image-20210409141536206.png" alt="image-20210409141536206"></p>
<ul>
<li><p>对象优先在 Eden 区分配<br>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
</li>
<li><p>大对象直接进入老年代<br>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间分配给大对象。</p>
<p>将大对象直接在老年代中分配的目的是避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p>
</li>
<li><p>长期存活的对象进入老年代<br>虚拟机采用分代收集的思想管理内存，因此需要识别每个对象应该放在新生代还是老年代。虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过第一次 Minor GC 之后仍然存活，将进入 Survivor 区，同时对象年龄变为 1，对象在 Survivor 区每经过一次 Minor GC 且存活，年龄就增加 1，增加到一定阈值时则进入老年代（阈值默认为 15）。</p>
</li>
<li><p>动态对象年龄判定<br>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p>
</li>
</ul>
<p><strong>回收策略</strong></p>
<p>Minor GC 和 Full GC<br><strong>Minor GC</strong> 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。</p>
<p><strong>Full GC</strong> 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC <strong>慢</strong>很多。</p>
<p><strong>参数调优</strong></p>
<p>内存参数</p>
<pre><code>-Xms1024m （堆初始化内存）     X-Memory Startup
-Xmx1024m （堆的最大内存）     X-Memory Maximum, 注意: 堆内存大小=年轻代(1/3)+老年代(2/3)
-Xmn256m （堆-年轻代大小）     X-Memory New, 注意: 老年代大小=Xmx-年轻代, 年轻代占比
-Xss256k （棧-最大深度大小）     X-Stack Size
-XX:MetaspaceSize=?m （元空间默认大小） , 注意: 元空间默认大小取决于系统内存,实测64bit-16G电脑, 默认30M
-XX:MaxMetaspaceSize=?m （元空间最大大小） , 注意: 只要不设置上限,只要电脑内存足够就会动态增加
-XX:SurvivorRatio=? （默认值:8, 即新生代分区比例默认 8:2, 即 Eden:S1:S2=8:1:1, S1约定于S2)
-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器） 
-XX:+PrintGCDetails （打印详细的GC日志）
注意:jdk1.8已经移除了-XX:PermSize 和  -XX:MaxPermGen，取而代之的是 Metaspace</code></pre>
<h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p><strong><em>单例模式</em></strong></p>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有<strong>单个对象</strong>被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>优点：</strong></p>
<ul>
<li>在内存里只有一个实例，<strong>减少了内存的开销</strong>，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>要求生产<strong>唯一</strong>序列号。</li>
<li>WEB 中的<strong>计数器</strong>，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要<strong>消耗的资源过多</strong>，比如 I/O 与数据库的连接等。</li>
</ul>
<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DCL懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton; <span class="comment">// volatile保证没有指令重排 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton(); <span class="comment">// 不是一个原子性操作，存在指令重排：1.分配内存空间 2.执行构造方法，初始化对象 3.对象指向空间</span></span><br><span class="line">         	&#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射破坏单例，但枚举能够避免单例模式被破坏（枚举类型反编译，发现枚举类型是有参构造）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Singleton instance = Singleton.getInstance();</span><br><span class="line">    Constructor&lt;Singleton&gt; declaredConstructor = Singleton.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">    declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Singleton instance2 = declaredConstructor.newInstance();</span><br><span class="line">    System.out.println(instance==instance2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Constructor&lt;Singleton&gt; declaredConstructor = SingletonEnum.class.getDeclaredConstructor(String.class,int.class); → Exception: Cannot reflectively create enum objects</span></span><br></pre></td></tr></table></figure>



<p><strong><em>工厂模式</em></strong></p>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。通过工厂模式实现了<strong>创建者和调用者的分离</strong>。</p>
<p><strong>优点：</strong> </p>
<ul>
<li>一个调用者想创建一个对象，只要知道其<strong>名称</strong>就可以了。 </li>
<li><strong>扩展</strong>性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的<strong>接口</strong>。</li>
</ul>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>JDK中的Calendar的getInstance方法</li>
<li>JDBC中的Connection对象的获取</li>
<li>Spring中IOC容器创建管理bean对象</li>
<li>反射中Class对象的newInstance方法</li>
</ul>
<p>简单工厂模式（Simple Factory），常用！</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/09067f878916c0e4377bfadc82afc248_720w.jpg" alt="img"></p>
<p><strong><em>动态代理</em></strong></p>
<ul>
<li><p>动态代理和静态代理角色一样</p>
</li>
<li><p>动态代理的代理类是动态生成的，不是直接写好的</p>
</li>
<li><p>动态代理分为两大类：基于接口的动态代理，基于类的动态代理</p>
<ul>
<li><p>基于接口——JDK动态代理</p>
</li>
<li><p>基于类：cglib</p>
<p>​        CGLIB是一个强大的、高性能的<strong>代码生成库</strong>。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供<strong>方法拦截操作</strong>。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。</p>
<p>​        CGLIB代理主要通过对<strong>字节码</strong>的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个<strong>普通类、没有接口</strong>，那么Java动态代理就没法使用了。</p>
</li>
<li><p>Java字节码实现：JAVAssist</p>
</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy，InvocationHandler</p>
<p>【InvocationHandler：调用处理程序】</p>
<p>InvocationHandler是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, 方法 method, Object[] args)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//参数</span></span></span><br><span class="line"><span class="function"><span class="comment">//proxy - 调用该方法的代理实例</span></span></span><br><span class="line"><span class="function"><span class="comment">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span></span></span><br><span class="line"><span class="function"><span class="comment">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span></span></span><br></pre></td></tr></table></figure>

<p>【Proxy  : 代理】</p>
<p>Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理对象的超类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="comment">//public static Object newProxyInstance(Classloader loader,类&lt;&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException</span></span><br><span class="line"><span class="comment">//loader - 类加载器来定义代理类</span></span><br><span class="line"><span class="comment">//interfaces - 代理类实现的接口列表</span></span><br><span class="line"><span class="comment">//h - 调度方法调用的调用处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>Rent - 抽象角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host  - 真实角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色：房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyInvocationHandler - 代理角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.rent = rent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">               rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line">   <span class="comment">// 处理代理实例上的方法调用并返回结果</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       seeHouse();</span><br><span class="line">       <span class="comment">//核心：本质利用反射实现！</span></span><br><span class="line">       Object result = method.invoke(rent, args);</span><br><span class="line">       fare();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//看房</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//收中介费</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client - 租客</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//真实角色</span></span><br><span class="line">       Host host = <span class="keyword">new</span> Host();</span><br><span class="line">       <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">       ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">       pih.setRent(host); <span class="comment">//将真实角色放置进去！</span></span><br><span class="line">       Rent proxy = (Rent)pih.getProxy(); <span class="comment">//动态生成对应的代理类！</span></span><br><span class="line">       proxy.rent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：一个动态代理 , 一般代理某<strong>一类业务</strong> , 一个动态代理可以代理多个类，代理的是接口！</p>
<p>动态代理的好处：</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 ；</li>
<li><strong>公共的业务</strong>由代理来完成 ，实现了业务的分工 ；</li>
<li>公共业务发生扩展时变得更加集中和方便 ；</li>
<li>一个动态代理 , 一般代理某一类业务；</li>
<li>一个动态代理可以代理多个类，代理的是<strong>接口</strong>。</li>
</ul>
<h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p><strong><em>MVC</em></strong></p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li>Model（模型）代表一个<strong>存取数据的对象</strong>或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li>View（视图）代表模型包含的数据的<strong>可视化</strong>。</li>
<li>Controller（控制器）控制器作用于模型和视图上。它<strong>控制数据流向</strong>模型对象，并在数据变化时<strong>更新视图</strong>。它使视图与模型分离开。</li>
</ul>
<p><strong><em>Spring中Bean的作用域</em></strong></p>
<p>Spring IOC容器创建一个Bean实例时，可以为Bean指定实例的作用域，作用域包括singleton（单例模式）、prototype（原型模式）、request（HTTP请求）、session（会话）、global-session（全局会话）。</p>
<p><strong><em>Session / Cookie</em></strong></p>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p><strong>Cookie的缺点</strong>：</p>
<p>(1) 每个特定域名下的cookie数量有限：</p>
<p>IE6或IE6-(IE6以下版本)：最多20个cookie</p>
<p>IE7或IE7+(IE7以上版本)：最多50个cookie</p>
<p>FF:最多50个cookie</p>
<p>Opera:最多30个cookie</p>
<p>Chrome和safari没有硬性限制</p>
<p>当超过单个域名限制之后，再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会清理近期最少使用的cookie，FF会随机清理cookie；</p>
<p>(2) 存储量太小，只有4KB；</p>
<p>(3) 每次HTTP请求都会发送到服务端，影响获取资源的效率；</p>
<p>(4) 需要自己封装获取、设置、删除cookie的方法；</p>
<p><strong><em>表单重复提交</em></strong></p>
<p>​        表单重复提交会造成数据重复，<strong>增加服务器负载</strong>，严重甚至会造成服务器宕机。因此有效防止表单重复提交有一定的必要性。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>利用JavaScript防止表单重复提交<ul>
<li>对按钮进行控制：在第一次点提交的时候将button设置为disable。</li>
<li>做状态位进行标识：设置一个标志位了来判断是不是第一次提交。</li>
</ul>
</li>
<li>利用Session防止表单重复提交<ul>
<li>令牌（Token）：在服务器端生成一个<strong>唯一的随机标识号</strong>，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。</li>
</ul>
</li>
</ol>
<p><strong><em>SpringBoot / SpringMVC</em></strong></p>
<p>spring boot就是一个大框架里面包含了许许多多的东西，其中spring就是最核心的内容之一，当然也就包含spring mvc。</p>
<p>spring mvc 只是spring 处理web层请求的一个模块。</p>
<p><strong><em>SpringMVC 执行流程</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5220087-3c0f59d3c39a12dd.png" alt="img"></p>
<p>1、 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。<br>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller<br>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet<br>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。<br>6、DispatcherServlet将模型数据填充到视图中<br>7、DispatcherServlet将结果响应给用户</p>
<p><strong><em>AOP</em></strong></p>
<p><strong>概念</strong></p>
<p><strong>Joinpoint（连接点）：</strong>程序执行时的某个特定的点，在Spring中就是某一个方法的执行 。<br><strong>Pointcut（切点）：</strong>说的通俗点，spring中AOP的切点就是指一些方法的集合，而这些方法是需要被增强、被代理的。一般都是按照一定的约定规则来表示的，如正则表达式等。切点是由一类连接点组成。<br><strong>Advice（通知)：</strong>还是说的通俗点，就是在指定切点上要干些什么。Advice定义横切逻辑，Spring中支持5种类型的Advice。<br><strong>Advisor（通知器)：</strong>其实就是切点和通知的结合 。</p>
<p><strong>实现</strong></p>
<p>1.经典的基于代理的AOP（CGLIB动态代理）</p>
<p>2.@AspectJ注解驱动的切面（注解实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointcut</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Before(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;签名:&quot;</span>+jp.getSignature());</span><br><span class="line">       <span class="comment">//执行目标方法proceed</span></span><br><span class="line">       Object proceed = jp.proceed();</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.纯POJO切面（实现Spring增强类的接口）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.注入式AspectJ切面（自定义切入类）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong><em>JavaScript中let和var区别</em></strong></p>
<p>1、作用域不同</p>
<p>var是函数作用域，let是块作用域。</p>
<p>在函数中声明了var，整个函数内都是有效的，比如说在for循环内定义的一个var变量，实际上其在for循环以外也是可以访问的</p>
<p>而let由于是块作用域，所以如果在块作用域内定义的变量，比如说在for循环内，在其外面是不可被访问的，所以for循环推荐用let</p>
<p>2、let不能在定义之前访问该变量，但是var可以。</p>
<p>let必须先声明，在使用。而var先使用后声明也行，只不过直接使用但没有定义的时候，其值是undefined。var有一个变量提升的过程，当整个函数作用域被创建的时候，实际上var定义的变量都会被创建，并且如果此时没有初始化的话，则默认为初始化一个undefined</p>
<p>3、let不能被重新定义，但是var是可以的</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><strong>JavaSE</strong></p>
<p><strong><em>HashMap</em></strong></p>
<p><strong><em>RecurrentHashMap</em></strong></p>
<p><strong><em>LinkedHashMap</em></strong></p>
<p><strong>Mybatis</strong></p>
<p><strong><em>selectOne</em></strong></p>
<p><strong>SpringBoot</strong></p>
<p><strong><em>@SpringBootApplication</em></strong></p>
<p><strong>Shiro</strong></p>
<p><strong><em>SecurityUtils.getSubject()</em></strong></p>
<h5 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h5><p><strong><em>快速排序</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 分割数组，找到分割点</span></span><br><span class="line">        <span class="keyword">int</span> point = partition(list, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用，对左子数组进行快速排序</span></span><br><span class="line">        quickSort(list, left, point - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归调用，对右子数组进行快速排序</span></span><br><span class="line">        quickSort(list, point + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割数组，找到分割点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用数组的第一个元素作为基准数</span></span><br><span class="line">    <span class="keyword">int</span> first = list[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; list[right] &gt;= first) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        swap(list, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; list[left] &lt;= first) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        swap(list, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回分割点所在的位置</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组中两个位置的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = list[left];</span><br><span class="line">        list[left] = list[right];</span><br><span class="line">        list[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>单例模式</em></strong></p>
<p>DCL懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton; <span class="comment">// volatile保证没有指令重排 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton(); <span class="comment">// 不是一个原子性操作，存在指令重排：1.分配内存空间 2.执行构造方法，初始化对象 3.对象指向空间</span></span><br><span class="line">         	&#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a>Java框架</h4><p><strong><em>Spring</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60827c3d0001d8e719201080.jpg" alt="img"></p>
<p>Spring家族体系：</p>
<p>Spring Core–&gt;SringMVC</p>
<p>Spring Data–&gt;数据访问</p>
<p>Spring Boot–&gt;多封装即用组件，便于开发</p>
<p>Spring Cloud–&gt;云服务</p>
<p><strong>IOC原理</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60827e170001fbb819201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60827e39000143e219201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60ad15080001f00d19201080.jpg" alt="img"></p>
<p>IOC是依赖倒置原则的具体实现， 通过依赖注入的方式来实现控制翻转：具体操作是把底层类作为参数传给上层类，实现上层对下层的控制，而这个过程可以称为DI，DI 可以通过 set注入，接口注入，注解注入 来实现。整个过程中，Spring 的IOC 容器是最核心的，他管理着bean的生命周期 控制着bean的依赖注入，为依赖注入实现简化了操作，首先它会自动对代码进行初始化。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5f51904b0001f70519201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60ad152600015fdb19201080.jpg" alt="img"></p>
<p><strong>SpringIOC</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62021aed0001f54219201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62021b0e0001d90c19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62021bf60001aaea19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62021d600001ddcb19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62021ea1000109e419201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62021e3f0001f72f19201080.jpg" alt="img"></p>
<p><strong>refresh</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5ca3d1800001cb5119201080.jpg" alt="img"></p>
<p>SpringApplication.class文件→ApplicationContext 方法→refreshContext方法：</p>
<p>refreshContext方法→refresh方法→afterRefresh（空方法可扩展）</p>
<p>refresh()→</p>
<p><code>this.prepareRefresh();</code></p>
<ol>
<li>设置spring容器的启动时间（撤销关闭状态，开启活跃状态）</li>
<li>初始化属性元信息initPropertySource()</li>
<li>验证环境中必须存在的属性</li>
</ol>
<p><code>ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</code></p>
<p><code>this.prepareBeanFactory(beanFactory);</code></p>
<p>获取BeanFactory实例，并对BeanFactory进行相关的设置，为后续的使用做准备：</p>
<ol>
<li><p>设置ClassLoader用来加载Bean</p>
</li>
<li><p>设置表达式解析器等</p>
</li>
</ol>
<p><code>this.postProcessBeanFactory(beanFactory);</code></p>
<p>模板方法，让不同的spring容器自定义扩展自己的加载方法，方法体为空</p>
<p><strong><code>this.invokeBeanFactoryPostProcessors(beanFactory);</code></strong></p>
<p>调用工厂后处理器处理解析各类Bean标签，扫描Bean文件，并解析成一个个的Bean，这里的Bean只是被加载到spring容器当中，由于spring容器的懒加载，这些Bean仅仅只是加载到容器，并没有连接和初始化，当程序需要使用到该Bean的时候，才会将bean连接和初始化</p>
<p><code>this.registerBeanPostProcessors(beanFactory);</code></p>
<p>在容器中找出实现BeanPostProcessors接口的bean，设置到BeanFactory的属性之中，最后bean被实例化的时候会调用BeanPostProcessors（bean的后置处理器，与AOP相关）</p>
<p><code>this.initMessageSource();</code></p>
<p>加载国际化信息</p>
<p><code>this.initApplicationEventMulticaster();</code></p>
<p>初始化事件的广播器，用于事件的发布</p>
<p><code>this.onRefresh();</code></p>
<p>模板方法：让不同的spring容器自定义扩展自己的加载方法，方法体为空</p>
<p><code>this.registerListeners();</code></p>
<p>注册监听器</p>
<p><code>this.finishBeanFactoryInitialization(beanFactory);</code></p>
<p>实例化BeanFactory中已经被注册但是没有实例化的所有bean（懒加载不需要被实例化）</p>
<p><code>this.finishRefresh();</code></p>
<p>初始化生命周期处理器等相关的事情</p>
<p><strong>Bean</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62022c47000165d019201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62022cb400015ccc19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62022ce2000125b119201080.jpg" alt="img"></p>
<p><strong>AOP</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6202307800014a2819201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/620230a40001e47219201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/620232bb0001e08a19201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/620232d70001822919201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6202333800014a8219201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/620233c60001dc5119201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/62023699000106b719201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/6202380d000183de19201080.jpg" alt="img"></p>
<p><strong>事务传播行为</strong>（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。<br>例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/620238f009448f9105000299.jpg" alt="img"></p>
<p><strong><em>Redis</em></strong></p>
<p>​        Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p>
<ul>
<li>基于内存运行，性能高效</li>
<li>支持分布式，理论上可以无限扩展</li>
<li>key-value存储系统</li>
<li>开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</li>
</ul>
<p>​        相比于其他数据库类型，Redis具备的特点是：</p>
<ul>
<li>C/S通讯模型</li>
<li>单进程单线程模型</li>
<li>丰富的数据类型</li>
<li>操作具有原子性</li>
<li>持久化</li>
<li>高并发读写</li>
<li>支持lua脚本</li>
</ul>
<p>​        Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。</p>
<p>Redis(缓存中间件)<br>术语<br>缓存穿透 –&gt; 缓存层查不到相关数据，去相应数据库里查询数据。<br>缓存回种 –&gt; 穿透缓存查询到数据，回写到缓存层<br>缓存熔断 –&gt; 存储层不可用，直接有缓存层返回<br>QPS –&gt; 每秒查询的次数</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5f2cb86c00013d2819201080.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5f2cbd920001dc8a19201080-500-284.jpg" alt="img"></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5f2cbdc0000124b319201080-500-284.jpg" alt="img"></p>
<p><strong>数据结构</strong></p>
<p>​        Redis提供的数据类型主要分为5种自有类型和一种自定义类型，这5种自有类型包括：字符串类型、哈希类型、列表类型、集合类型和顺序集合类型。</p>
<ul>
<li><p>字符串（String）类型：</p>
<p>它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。</p>
</li>
<li><p>哈希（Hash）类型：</p>
<p>该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。</p>
</li>
<li><p>列表（List）类型：<br>该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。</p>
</li>
<li><p>集合（Set）类型：<br>Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。</p>
</li>
<li><p>顺序集合（Zset）类型：<br>ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。</p>
</li>
</ul>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210409173546.jpg"></p>
<p><strong>持久化方法</strong></p>
<p>​        由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是<strong>RDB持久化</strong>（原理是将Reids在内存中的数据库记录<strong>定时dump到磁盘</strong>上的RDB持久化），另外一种是<strong>AOF（append only file）持久化</strong>（原理是将Reids的<strong>操作日志以追加的方式写入文件</strong>）。</p>
<p><strong><em>RDB</em></strong>的优点：简称“3更”</p>
<ol>
<li><p>体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件</p>
</li>
<li><p>恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存</p>
</li>
<li><p>性能更高:父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>故障丢失:因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。</p>
</li>
<li><p>耐久性差:相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。</p>
</li>
</ol>
<p><strong><em>AOF</em></strong>的优点：</p>
<ol>
<li><p>数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，咱们也最多丢失一秒数据</p>
</li>
<li><p>自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>性能相对较差：它的操作模式决定了它会对redis的性能有所损耗</p>
</li>
<li><p>体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。</p>
</li>
<li><p>恢复速度更慢：</p>
</li>
</ol>
<p><strong>过期策略</strong></p>
<p>三种过期策略：定时删除、惰性删除、定期删除。</p>
<p>Redis采用的过期策略：惰性删除+定期删除</p>
<ul>
<li>惰性删除流程<ul>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作。</li>
</ul>
</li>
<li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<ul>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<ul>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><em>分布式锁</em></strong></p>
<p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。</p>
<p><strong>具备条件</strong>：</p>
<ul>
<li><p>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</p>
</li>
<li><p>高可用的获取锁与释放锁；</p>
</li>
<li><p>高性能的获取锁与释放锁；</p>
</li>
<li><p>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）；</p>
</li>
<li><p>具备锁失效机制，防止死锁具备非阻塞锁特性，即没有获取到锁将直接返</p>
<p>回获取锁失败。</p>
</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li><p>基于数据库实现分布式锁；</p>
<p>​        基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建<strong>唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p>
</li>
<li><p>基于缓存（Redis等）实现；</p>
<p>实现思想：</p>
<p>（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p>
<p>（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p>
<p>（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p>
</li>
<li><p>基于Zookeeper实现。</p>
<p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个<strong>分层</strong>的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p>
<p>（1）创建一个目录mylock；<br>（2）线程A想获取锁就在mylock目录下创建临时顺序节点；<br>（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；<br>（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</p>
<p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p>
<p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p>
</li>
</ul>
<p><strong><em>ElasticSearch</em></strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/elasticsearch">https://www.elastic.co/cn/products/elasticsearch</a></p>
<p>Elasticsearch是一个采用Restful API标准的高扩展性和高可用性的实时数据分析的全文搜索工具。</p>
<p><strong>优势</strong>：</p>
<ol>
<li><p>弹性、高可用</p>
</li>
<li><p>可预见，可信</p>
</li>
<li><p>简单透明</p>
</li>
</ol>
<p>与关系数据库的对比</p>
<table>
<thead>
<tr>
<th>关系型数据库（MySQL）</th>
<th>非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td>数据库database</td>
<td>索引 index</td>
</tr>
<tr>
<td>表 table</td>
<td>类型 type</td>
</tr>
<tr>
<td>数据行 row</td>
<td>文档 document</td>
</tr>
<tr>
<td>数据列 column</td>
<td>字段 field</td>
</tr>
</tbody></table>
<p><strong>小结</strong>：</p>
<ol>
<li><p>ElasticSearch其实就是<strong>非关系型数据库</strong>，非关系型数据库是相对关系型数据库而言的。</p>
</li>
<li><p>非关系型数据库存储的是非结构化的数据，非结构化数据包括<strong>文本、图片、音频</strong>。</p>
</li>
<li><p>结构化的数据就是数字符号，数字符号得用关系型数据库去存储，也就是我们常用的mysql、oracle、db2。</p>
</li>
</ol>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p><strong><em>OSI网络模型</em></strong></p>
<p>1.物理层（网卡）： 定义的硬件设备标准，用于计算机之间的数据传输，传输bit流。<br>2.数据链路层（交换机）：数据帧，对bit数据格式化，校验。目的是保障数据传输可靠性<br>3.网络层（路由选择，点到点）：IP寻址，通过IP连接网络上的计算机。<br>4.传输层（端到端）：建立了主机端到端的链接。tcp、udp。ipv6传输效率高就和这层有关。<br>5.会话层（会话控制）：管理不同设备之间通信<br>6.表示层（数据格式转化）：对应用层数据编码和数据格式转换，保障不同设备之间通信（windows和linux）。<br>7.应用层：提供应用接口，为用户直接提供各种网络服务。</p>
<p><strong><em>TCP / UDP</em></strong></p>
<p>用户数据报协议 UDP是面向<strong>无连接</strong>的，<strong>尽最大可能</strong>交付，没有拥塞控制，面向<strong>报文</strong>，支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>传输控制协议 TCP是面向<strong>连接</strong>的，提供<strong>可靠</strong>交付，有流量控制，<strong>拥塞控制</strong>，提供全双工通信，面向<strong>字节流</strong>，每一条 TCP 连接只能是<strong>点对点</strong>的（一对一）。</p>
<p> TCP应用场景：</p>
<p>效率要求相对低，但对<strong>准确性</strong>要求相对高的场景。因为传输中需要对数据确认、重发、 排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。</p>
<p>UDP应用场景：</p>
<p><strong>效率</strong>要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。</p>
<p>UDP为何快？</p>
<p>不需要建立连接<br>对于收到的数据，不用给出确认<br>没有超时重发机制<br>没有流量控制和拥塞控制</p>
<p><strong><em>IP数据包结构</em></strong></p>
<p>IP协议提供<strong>不可靠无连接</strong>的数据报传输服务，IP层提供的服务是通过IP层对数据报的封装与拆封来实现的。IP数据报的格式分为<strong>报头区</strong>和<strong>数据区</strong>两大部分，其中报头区是为了正确传输高层数据而加的各种<strong>控制信息</strong>，数据区包括高层协议需要传输的数据。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/5573582_1279195143KN73.png"></p>
<p>IP 协议主要有以下几个作用：</p>
<p><strong>寻址和路由</strong>：在IP 数据包中会携带<strong>源 IP 地址</strong>和<strong>目的 IP 地址</strong>来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据<strong>路由表</strong>选择合适的路径。IP 协议根据<strong>路由选择协议</strong>提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。<br><strong>分段与重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，在<strong>不同的网络</strong>中<strong>数据包的最大长度限制</strong>是不同的，IP 协议通过给每个 IP 数据包分配一个<strong>标识符</strong>以及<strong>分段与组装的相关信息</strong>，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以<strong>独立</strong>地在网络中进行<strong>转发</strong>，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</p>
<p><strong><em>HTTP</em></strong></p>
<p>HTTP协议的<strong>主要特点</strong>可概括如下：</p>
<p>1.支持客户/服务器模式。</p>
<p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>
<p>4.<strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>5.<strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>无连接：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。因为传输具有突发性、瞬时性，而大部分通道实际上会很空闲、无端占用资源。Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>
<p>无状态：对于事务处理<strong>没有记忆能力</strong>，服务器不知道客户端是什么状态，这意味着每个请求都是<strong>独立</strong>的，Keep-Alive 没能改变这个结果。优点在于解放了服务器，每一次请求“点到为止”不会造成不必要<strong>连接占用</strong>，缺点在于每次请求会传输<strong>大量重复</strong>的内容信息。客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。</p>
<p>HTTP<strong>数据包</strong></p>
<p>请求报文</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/20190728203947549.png" alt="img"></p>
<p> 1.请求行：由3部分组成，分别为：请求方法、URL以及协议版本，之间由空格分隔，请求方法包括GET、POST等。协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1。</p>
<p>2.请求头部包含很多<strong>客户端环境</strong>以及请求正文的有用信息。请求头部由“关键字：值”对组成，每行一堆，关键字和值之间使用英文“：”分隔。</p>
<p>3.空行，这一行非常重要，必不可少。表示请求头部结束，下面就是请求正文。</p>
<p>4.请求正文：可选部分，比如GET请求就没有请求正文；POST比如以提交表单数据方式为请求正文。</p>
<p>响应报文</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/20190728204114903.png" alt="img"></p>
<p>(1)状态行由由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔。</p>
<p>(2)响应头部与请求头部类似，也包含了很多有用的信息。      </p>
<p>(3)空行，这一行非常重要，必不可少。表示响应头部结束。</p>
<p>(4)响应正文，服务器返回的文档，最常见的为HTML网页。</p>
<p>HTTP<strong>版本</strong></p>
<p>1991年　　HTTP/0.9 仅支持GET请求，不支持请求头</p>
<p>1996年　　HTTP/1.0 默认<strong>短连接</strong>（一次请求建议一次TCP连接，请求完就断开），支持GET、POST、 HEAD请求</p>
<p>1999年　　HTTP/1.1 默认<strong>长连接</strong>（一次TCP连接可以多次请求）；支持PUT、DELETE、PATCH等六种请求；增加host头，支持<strong>虚拟主机</strong>；支持<strong>断点续传</strong>功能。</p>
<p>2015年　　HTTP/2.0 多路复用，降低开销（一次TCP连接可以处理多个请求）；服务器<strong>主动推送</strong>（相关资源一个请求全部推送）；解析基于<strong>二进制</strong>，解析错误少，更高效（HTTP/1.X解析基于文本）；报头压缩，降低开销。</p>
<p><strong><em>三次挥手，四次握手</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/0_131271823564Rx.gif" alt="img"></p>
<p><strong>三次握手</strong></p>
<p>三次握手的目的是建立<strong>可靠</strong>的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p><strong>四次挥手</strong></p>
<p><em>CLOSE-WAIT</em>状态问题：</p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了<strong>让服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送FIN 连接释放报文。</p>
<p><em>TIME-WAIT</em> 状态问题：</p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<p>确保<strong>最后一个确认报文</strong>能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一 个新的连接<strong>不会出现旧的连接请求报文</strong>。</p>
<p>通信双方建立TCP连接后，<strong>主动关闭</strong>连接的一方就会进入TIME_WAIT状态。</p>
<p><strong><em>HTTP / HTTPS</em></strong>（**）</p>
<ul>
<li><p>HTTP 协议以<strong>明文</strong>方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是<strong>加密</strong>的，安全性较好。</p>
</li>
<li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 <strong>80</strong> 端口，后者是 <strong>443</strong> 端口。</p>
</li>
<li><p>HTTPS 协议需要到<strong>数字认证机构</strong>（Certificate Authority, CA）申请证书，一般需要一定的<strong>费用</strong>。</p>
</li>
<li><p>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 <strong>SSL 协商过程</strong>。</p>
</li>
</ul>
<p><strong>HTTPS运作过程</strong></p>
<p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 <strong>443 端口</strong>，发送的信息主要包括自身所<strong>支持的算法</strong>列表和<strong>密钥长度</strong>等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它的<strong>密钥组件</strong>一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含<strong>数字证书</strong>的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的<strong>公钥</strong>等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个<strong>回应报文</strong>，报文中包含一个客户端生成的<strong>随机密码串</strong>，称为 pre_master_secre，并且该报文是经过证书中的<strong>公钥加密过</strong>的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 <strong>finish 报文</strong>，这次握手中包含第一次握手至今所有报文的<strong>整体校验值</strong>，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
<p><strong>SSL协议作用</strong></p>
<p>​        SSL能使用户/服务器应用之间的通信不被攻击者<strong>窃听</strong>，并且始终对服务器进行<strong>认证</strong>，还可选择对用户进行认证。SSL协议要求建立在可靠的传输层协议（TCP）之上。SSL协议的优势在于它是与应用层协议<strong>独立无关</strong>的，高层的应用层协议（例如：HTTP，FTP，TELNET等）能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成<strong>加密算法</strong>、<strong>通信密钥</strong>的协商及<strong>服务器认证</strong>工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p>
<p><strong><em>常见状态码</em></strong></p>
<p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。HTTP 状态码共有 5 种类型：</p>
<p>分类    分类描述<br>1XX    指示信息–表示请求正在处理<br>2XX    成功–表示请求已被成功处理完毕<br>3XX    重定向–要完成的请求需要进行附加操作<br>4XX    客户端错误–请求有语法错误或者请求无法实现，服务器无法处理请求<br>5XX    服务器端错误–服务器处理请求出现错误</p>
<p>常见的状态码： 200、301、302、403、404、500、503</p>
<p>状态码    描述<br><strong>200</strong> 请求被成功处理<br><strong>301</strong> <strong>永久</strong>性重定向<br><strong>302</strong> <strong>临时</strong>性重定向<br>304 未修改。告诉客户端可以复用缓存。<br><strong>400</strong> 请求出错：由于<strong>语法格式 / 参数</strong>有误，服务器无法理解。<br>401 未授权：当前请求需要用户<strong>验证</strong>。<br><strong>403</strong> 没有访问<strong>权限</strong>（服务器已经理解请求，但是拒绝执行它）。<br><strong>404</strong> 没有对应资源（一般是输入的url并不合法）。<br>405 不允许此方法（get/post/put/delete/请求用混淆了）。<br>406 不可接受，请求的资源的内容特性无法满足<strong>请求头</strong>中的条件，因而无法生成响应实体。<br>407 需要代理身份验证，与401响应类似，只不过客户端必须在<strong>代理</strong>服务器上进行身份验证。<br>412 前提条件失败：在服务器上测试前提条件时，部分请求标题字段中所给定的前提条件估计为FALSE。客户机将前提条件放置在当前资源元信息（标题字段数据）中，以防止所请求的方法被误用到其他资源。<br>414 Request-URI 太长<br><strong>500</strong> 服务器内部错误（一般是服务器代码错误）。<br>501 未实现，Web 服务器不支持实现此请求所需的功能。<br><strong>502</strong> 网关出错，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到<strong>无效</strong>的响应。<br><strong>503</strong> 服务器停机，由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常。<br>504 网关超时，充当网关或代理的服务器，未<strong>及时</strong>从远端服务器获取请求</p>
<p><strong><em>特殊的IP地址</em></strong></p>
<p>一、0.0.0.0</p>
<p>严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。</p>
<p>二、255.255.255.255</p>
<p>限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。</p>
<p>三、127.0.0.1</p>
<p>本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。</p>
<p>四、224.0.0.1</p>
<p>组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP(Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。</p>
<p>五、169.254.X.X</p>
<p>如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</p>
<p>六、10.X.X.X、172.16.X.X～172.31.X.X、192.168.X.X</p>
<p>私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。</p>
<p><strong><em>网络安全</em></strong></p>
<p><strong><em>XSS / CSRF</em></strong></p>
<p><code>XSS</code>：跨站脚本（<code>Cross-site scripting</code>）<br>通过提交或其他方式例如发布评论，其中含有<code>HTML</code>或<code>JavaScript</code>的代码，如果服务器没有过滤掉这些脚本，这些脚本在一些情况下就可能会运行。</p>
<ol>
<li>避免<code>XSS</code>的方法之一就是<strong>过滤</strong>用户提供的内容，如<code>&lt;,&gt;,script</code>;</li>
<li><code>cookie</code>设置<code>HttpOnly</code>属性</li>
</ol>
<p><code>CSRF</code>：跨站请求伪造（<code>Cross-site request forgery</code>）<br>是一种劫持受信任用户向服务器发送非预期请求的攻击方式，即在用户登陆某个平台化拿到用户的登陆凭证后发送伪造请求</p>
<ol>
<li>防范<code>CSRF</code>的方法之一就是通过<strong>验证码</strong></li>
<li><code>Referer Check</code>，根据 <code>HTTP</code> 协议，在<code>HTTP </code>头中有一个字段叫 <code>Referer</code>，它记录了该 <code>HTTP</code> 请求的来源地址。通过 <code>Referer Check</code>，可以检查请求是否来自<strong>合法的”源”</strong>。</li>
<li>添加<code>token</code>验证，可以在 <code>HTTP </code>请求中以参数的形式加入一个随机产生的<code>token</code>，该<code>token</code>不存在与<code>cookie</code>中，并在服务器端建立一个拦截器来验证这个 <code>token</code>，如果请求中没有 <code>token </code>或者 <code>token</code> 内容不正确，则认为可能是 <code>CSRF </code>攻击而拒绝该请求。</li>
</ol>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p><strong><em>进程调度算法</em></strong></p>
<p>a）先来先去服务</p>
<p>b）时间片轮转法</p>
<p>c）短作业优先</p>
<p>d）高响应比优先调度算法（既考虑作业等待时间又考虑作业运行时间）</p>
<p>e）多级反馈队列调度算法（既能使高优先级的作业得到响应又能使短作业迅速完成）</p>
<p>f）优先级调度</p>
<p><strong><em>进程 / 线程</em></strong>（**）</p>
<p>a）进程是<strong>资源分配</strong>的最小单位，线程是<strong>任务执行</strong>的最小单位。</p>
<p>b）进程有自己的<strong>独立</strong>地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是<strong>共享</strong>进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p>
<p>c）线程之间的<strong>通信</strong>更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC）进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>
<p>d）但是多进程程序更<strong>健壮</strong>，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>
<p><strong><em>多进程</em></strong></p>
<p>优点：<br>可以<strong>并行</strong>的执行多个任务，提高运行效率，（可利用计算机多核），空间独立，<strong>数据安全</strong>，创建方便</p>
<p>缺点：<br>进程的创建和销毁过程需要消耗较多的计算机资源，<br>在需要频繁创建和删除较多进程的情况下，资源消耗过多，不适宜使用多进程完成任务；<br>不过进程池技术可以解决频繁创建和删除多进程。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/20180922100220239" alt="在这里插入图片描述"></p>
<p>1）需要频繁创建销毁的优先用线程</p>
<p>原因请看上面的对比。</p>
<p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p>
<p>2）需要进行大量计算的优先使用线程</p>
<p>所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。</p>
<p>这种原则最常见的是图像处理、算法处理。</p>
<p>3）强相关的处理用线程，弱相关的处理用进程</p>
<p>什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。</p>
<p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p>
<p>当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。</p>
<p>4）可能要扩展到多机分布的用进程，多核分布的用线程</p>
<p>原因请看上面对比。</p>
<p>5）都满足需求的情况下，用你最熟悉、最拿手的方式</p>
<p>至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。</p>
<p>需要提醒的是：虽然我给了这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。</p>
<p><strong><em>线程通信</em></strong></p>
<p>线程通信主要可以分为三种方式，分别为<strong>共享内存</strong>、<strong>消息传递</strong>和<strong>管道流</strong>。每种方式有不同的方法来实现</p>
<ul>
<li>共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。</li>
</ul>
<blockquote>
<p>volatile共享内存</p>
</blockquote>
<ul>
<li>消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。</li>
</ul>
<blockquote>
<p>wait/notify等待通知方式<br>join方式</p>
</blockquote>
<ul>
<li>管道流</li>
</ul>
<blockquote>
<p>管道输入/输出流的形式</p>
</blockquote>
<p> <strong><em>进程通信</em></strong></p>
<p>实际上只有进程间需要通信,同一进程的线程共享地址空间,没有通信的必要，但要做好同步/互斥,保护共享的全局变量。</p>
<p>管道( pipe )：<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p>有名管道 (namedpipe) ：<br>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>消息队列( messagequeue ) ：<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>信号 (signal ) ：<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<p>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
<p><strong><em>分页 / 分段</em></strong></p>
<p>分段和分页其实都是一种对<strong>地址</strong>的划分或者映射的方式。 两者的区别主要有以下几点：</p>
<p>1)页是信息的<strong>物理</strong>单位，分页是为实现<strong>离散</strong>分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于<strong>系统管理</strong>的需要，而不是用户的需要（也是<strong>对用户透明</strong>的）。段是信息的<strong>逻辑</strong>单位，它含有一组其意义相对完整的信息（比如数据段、代码段和堆栈段等）。分段的目的是为了能更好的满足<strong>用户</strong>的需要（用户也是可以使用的）。</p>
<p>2)页的大小<strong>固定</strong>且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。</p>
<p>3)分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符（线性地址的16进制表示），即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名（比如数据段、代码段和堆栈段等），又需给出段内地址。</p>
<p>4)页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限。</p>
<p><strong><em>死锁</em></strong></p>
<p><strong>解决方法</strong></p>
<p>死锁预防： 破坏导致死锁必要条件中的任意一个就可以预防死锁。例如：</p>
<p>（1） 破坏保持和等待条件： <strong>一次性申请所有资源</strong>，之后不再申请资源，如果不满足资源条件则得不到资源分配。</p>
<p>（2） 破坏不可剥夺条件： 当一个进程获得某个不可剥夺的资源时，提出新的资源申请，若<strong>不满足，则释放所有资源</strong>。</p>
<p>（3） 破坏循环等待条件： 按某一<strong>顺序申请资源</strong>，释放资源则反序释放。</p>
<p>死锁避免： 进程在每次申请资源时<strong>判断</strong>这些操作是否安全。（银行家算法，系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。）</p>
<p>死锁检测： 判断系统是否属于死锁的状态，如果是，则执行死锁解除策略。</p>
<p>死锁解除： 将某进程所占资源进行<strong>强制回收</strong>，然后分配给其他进程。（与死锁检测结合使用的）</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p><strong><em>Linux常用命令</em></strong>（**）</p>
<p>pwd：显示当前所在位置</p>
<p>sudo + 其他命令：以系统管理者的身份执行指令</p>
<p>grep：要搜索的字符串 要搜索的文件 –color （高亮）</p>
<p>​     -o 正则表达式匹配的字符串 -v 筛除</p>
<p>awk：’条件{print $X,Y}’ 文件（筛选）</p>
<p>​    awk -F “,” ‘{print $2}’ 文件</p>
<p>​    awk ‘{enginearr[$1]++}END{for(i in enginearr) print i “\t” enginearr[i]}’</p>
<p>sed：-i ‘s/^Str\.$/String\;/g’ 文件（批量替换文本内容）</p>
<p>ps - ef/ps aux：查看当前系统正在运行进程</p>
<p><strong>查看特定的进程（查看包括redis的进程）： ps aux|grep redis / pgrep redis -a</strong></p>
<p><strong>kill -9 进程pid ： 杀死进程（-9 表示强制终止）</strong></p>
<p>find 目录 参数 ：find /home -name “*.txt”  </p>
<p>ls 或者 ll ：查看目录信息（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）</p>
<p>free : 显示<strong>系统内存</strong>的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存</p>
<p>tar -zcvf 打包压缩后的文件名 要打包压缩的文件 : 打包并压缩文件，一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 .tar.gz</p>
<p>tar -xvf 压缩文件 - C 解压的位置 : 解压压缩包</p>
<p>wget : 是从远程下载的工具</p>
<p><strong>netstat</strong>：显示<strong>网络状态</strong>。netstat –apn | grep 8080，查看程序端口占用情况。</p>
<p>vmstat : 虚拟内存性能监控、CPU 监控。</p>
<p><strong>top</strong> : 常用来监控Linux的<strong>系统状况</strong>，比如<strong>CPU、内存</strong>的使用，显示系统上正在运行的进程。</p>
<p>load average：系统负载，就是进程队列的长度。当这个值&gt;cpu核心数的时候就说明有进程在等待处理了，是负载过重。</p>
<p><strong><em>创建新进程</em></strong>在Linux的下是由父进程来完成的，创建完成的新进程是子进程。</p>
<p>新进程的地址空间有两种可能性：</p>
<p>子进程是父进程的复制品（除了PID和task_struct是子进程自己的，其余的都从父进程复制而来）<br>子进程装入另一个程序。<br>在Linux下的fork函数用于创建一个新的进程，使用fork函数来创建一个进程时，子进程只是完全复制父进程的资源。这样得到的子进程和父进程是独立的，具有良好的并发性。但是进程间通信需要专门的机制。</p>
<p>fork函数调用一次，会返回两个函数值，对于父进程而言，返回的是子进程的PID（因为一个父进程可能有多个子进程，并且没有一个函数可以使父进程获取其所有的子进程ID），对于子进程返回值是0（这样就能区分父子进程，子进程是可以通过getppid来获取父进程的ID），如果进程创建失败，那么返回给父进程-1。</p>
<p>现在的Linux操作系统采用了copy-on-write技术（COW），即：如果父进程和子进程中任意一个尝试修改某些区域的值，那么内核会为修改区域的那部分内存制作一个副本，一般都是虚拟内存的一页。否则不进行复制操作，比如在fork的子进程中只是调用exec函数来执行另外一个可执行文件，那么事实上就没有必要复制父进程的资源，这样会造成大量的开销浪费。</p>
<p>fork()函数创建的子进程和父进程的执行顺序理论上是不确定的（因为取决于OS的调度策略）。</p>
<p>总结一下：fork函数创建的子进程是父进程的复制，子进程和父进程并发执行</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><strong><em>关系型 / 非关系型数据库</em></strong></p>
<p><strong>1 关系型数据库</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/1013528-20170926113945323-238845177.png" alt="img"></p>
<p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。<br>优点：<br>1、易于维护：都是使用表结构，格式一致；<br>2、使用方便：SQL语言通用，可用于复杂查询；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。<br>缺点：<br>1、<strong>读写性能</strong>比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，<strong>灵活</strong>度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</p>
<p><strong>2 非关系型数据库</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/1013528-20170926114007198-781865994.png" alt="img"></p>
<p>非关系型数据库严格上不是一种数据库，应该是一种<strong>数据结构化存储方法的集合</strong>，可以是文档或者键值对等。<br>优点：<br>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、成本低：nosql数据库部署简单，基本都是开源软件。</p>
<p>缺点：<br>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p>
<p><strong><em>查询语句</em></strong></p>
<p>查询同时选修了选修课1和选修课2的学生学号：</p>
<p>select Sno from sc where Cno in (‘课1’,’课2’) group by Sno having count(*)=2</p>
<p><strong><em>UNION / UNION ALL</em></strong></p>
<ul>
<li>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</li>
<li>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</li>
</ul>
<p><strong><em>Null / 空值</em></strong></p>
<p>空 (NULL) 值表示数值<strong>未知</strong>。空值不同于空白或零值。没有两个相等的空值。比较两个空值或将空值与任何其它数值相比均返回未知，这是因为每个空值均为未知。</p>
<p>在写入数据的时候，空字符串’’ 也是一个<strong>确定的值</strong>，所以就算你定义了 NOT NULL 也可以被写入。</p>
<p><strong><em>数据库设计三大范式</em></strong></p>
<p>第一范式确保每列保持原子性；</p>
<p>第二范式确保每列都只和主键相关，消除非主属性对码的部分依赖；</p>
<p>第三范式确保每列都和主键直接相关，消除非主属性对码的传递依赖。</p>
<p>注：没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。</p>
<p>具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 订单和订单项、相册浏览次数和照片的浏览次数。</p>
<p><strong><em>索引</em></strong></p>
<p><strong>目的</strong>：使查询数据效率快。</p>
<p><strong>分类</strong></p>
<ol>
<li>聚集索引（主键索引）：所有行数都会按照主键索引进行排序。</li>
<li> 非聚集索引：就是给普通字段加上索引。</li>
<li> 联合索引：就是好几个字段组成的索引，称为联合索引。</li>
</ol>
<p><strong>不走索引的情况</strong></p>
<ol>
<li><p>like语句中%在前面的不走索引，在后面的走索引；</p>
</li>
<li><p>用索引列进行计算的，不走索引；</p>
</li>
<li><p>对索引列用函数了，不走索引；</p>
</li>
<li><p>索引列用了!= 不走索引。</p>
</li>
</ol>
<p><strong>B+树</strong></p>
<p>B+树就是为了解决数据量大的时候存储在外存储器时候，查找效率低的问题。</p>
<p>B+树的特点：</p>
<ol>
<li>中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。</li>
<li>所有的中间节点在子节点中要么是最大的元素要么是最小的元素 。</li>
<li>叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。</li>
</ol>
<p>B+树的优势：</p>
<ol>
<li>单个节点可以存储更多的数据，减少<strong>I/O</strong>的次数。</li>
<li>查找性能更<strong>稳定</strong>，因为都是要查找到叶子结点。</li>
<li>叶子结点形成了有序<strong>链表</strong>，便于查询。</li>
</ol>
<p><strong>重复数据加索引</strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/35158-20180628110430497-1856877204.png" alt="img"></p>
<p>a、非聚簇索引存储了对主键的引用，如果select字段不在非聚簇索引内，就需要跳到主键索引（上图中从右边的索引树跳到左边的索引树），再获取select字段值</p>
<p>b、如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢</p>
<p>c、如果where值重复率高的字段，select用了limit，只查较少数据，也就是跳的次数很少的情况下，还是可以建索引的（后来想想也没必要，limit限制了数量，全表扫描也很快，除非字段值是排序的，必须扫描完前面的所有值）</p>
<p>d、如果没有3这个前提，则不建议在值重复率高的字段上建索引，因为查询效率低，还需要维护索引</p>
<p><strong><em>索引越多越好吗？</em></strong></p>
<ol>
<li>数据量<strong>很小</strong>的表不需要索引</li>
<li>数据变更索引也需要维护，所以索引以为着更多的<strong>维护成本</strong></li>
<li>更多的索引也意味着需要更多的<strong>空间</strong></li>
</ol>
<p><strong><em>联合索引最左匹配原则</em></strong></p>
<ol>
<li>mysql会一直向右匹配知道遇到<strong>范围查询</strong>（&gt; , &lt; , between, like ）就停止匹配，比如a=3 and b = 4 and c &gt; 5 and d =6 如果建立（a，b，c，d）顺序的索引，d是用不到索引的，如果建立（a，b，d，c）的索引则可以用到，a、b、d的顺序可以任意调整</li>
<li>=和in可以乱序，比如a=1 and b=2 and c=3建立（a,b,c）索引可以任意顺序，mysql查询优化器会帮你优化成索引可以识别的形式</li>
</ol>
<p><strong><em>4种隔离级别</em></strong></p>
<p>​        数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。</p>
<p><strong>脏读、不可重复读、幻象读</strong>　　</p>
<p>　　脏读：指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。<br>　　不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。<br>　　幻读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</p>
<hr>
<p> <strong>读未提交 （Read uncommitted）</strong></p>
<p>　　读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p>
<p>　　在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。</p>
<hr>
<p> <strong>读提交（Read Committed）</strong> → 脏读</p>
<p>　　 读提交，顾名思义，就是只能读到已经提交了的内容。</p>
<p>​         这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显式的加锁。</p>
<p>　　那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
<p>　　这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”</p>
<p>　　假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而”快照读”就可以完成<strong>高并发</strong>的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。</p>
<hr>
<p>**可重复读(Repeated Read)**→不可重复读</p>
<p>　　可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。</p>
<p>　　不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p>
<p>　　在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“<strong>修改</strong>操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“<strong>插入或者删除</strong>操作（Insert or Delete）”而产生的。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60a3653d00012db019201080-500-284.jpg" alt="img"></p>
<p>当前读：加锁的增删查改（select … lock in share mode|for update/update/delete/insert）</p>
<p>快照读：不加锁的非阻塞读（select，Serializeable隔离级别除外）</p>
<p>MVCC是行级锁的变种，避免了加锁操作，开销低。</p>
<p>RC的快照读和当前读都是数据的最新版本。</p>
<p>RR的快照读有可能会读到数据的历史版本，首次读取的时机决定了读取的版本。</p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/60a371100001d9ed19201080-500-284.jpg" alt="img"></p>
<p>RR快照读针对查询的数据创建read view，来决定当前事务能看到哪个版本的数据，read view遵循可见性算法：将要修改数据的DB_TRX_ID（DB_TRX_ID :标识最后一次对本行数据做修改事务id）取出，与系统其他活跃事务DB_TRX_ID进行比较，如果大于则通过回滚指针找到当前最稳定版本的undo log。而每次RC快照读都会创建一个新的快照。</p>
<hr>
<p><strong>序列化 Serializable</strong></p>
<p>　　这是数据库最高的隔离级别，这种级别下，事务“<strong>串行化</strong>顺序执行”，也就是一个一个排队执行。这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
<hr>
<p>值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。</p>
<p><strong><em>数据库引擎</em></strong></p>
<p><strong>Innodb引擎</strong><br>Innodb引擎提供了对数据库<strong>ACID事务</strong>的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于<strong>锁的粒度更小</strong>，写操作不会锁定全表，所以在<strong>并发</strong>较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL<u>不能确定要扫描的范围，不使用索引</u>，InnoDB表同样会锁全表。</p>
<p><strong>MyIASM引擎</strong><br>MyIASM是MySQL默认的引擎（5.1之前），但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了<strong>表的行数</strong>，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<p><strong>Mysql的存储引擎和索引</strong><br> 可以说数据库必须有索引，没有索引则检索过程变成了顺序查找，O(n)的时间复杂度几乎是不能忍受的。我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引。  这个索引由独立的B+树来组织。</p>
<p>有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。</p>
<p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p>
<p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<p>MyISAM默认是表级锁不支持行级锁<br>InnoDB默认是行级锁也支持表级锁<br>MyISAM默认会给select语句上共享锁(读锁)<br>InnoDB默认不会给select语句上共享锁(读锁)<br>上了共享锁的可以再上共享锁但是不能上排他锁<br>上了排他锁的不可以再上共享锁和排他锁</p>
<p>不走索引用的是表级锁，走索引是行级所<br>innobd还支持意向锁，也称共享读锁is，排他写锁ix</p>
<p>InnoDB 中的行级锁更好的支持并发 但开销相对表级锁<strong>开销更大</strong>，因为要扫锚到特定行然后加锁 。有且仅有一个聚集索引，数据文件和索引是绑定的。检索信息时辅助索引需要进行两次查找。先找到主键索引，再通过索引找到数据</p>
<p>MyISAM是非聚集索引，数据和文件分离，索引保存数据文件的指针。主键索引和辅助索引是独立存在的，再查找多于增删改的场景下性能优于InnoDB</p>
<p>myisam适合场景<br>1.频繁执行全表count语句(用变量存储)<br>2.增删改频率不高，<strong>查询频繁</strong>（查询效率高）<br>3.<strong>没有事务</strong><br>innodb适合场景<br>1.<strong>增删改</strong>相当频繁<br>2.可靠性要求比较高，要求支持<strong>事务</strong></p>
<p><strong><em>回滚 / 提交</em></strong></p>
<p>1 回滚日志(undo)</p>
<p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前<strong>相反的工作</strong>：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
<p>undo log用于存放数据被修改前的值，如果修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。另外InnoDB MVCC事务特性也是基于undo日志实现的。</p>
<p>因此，undo log有两个作用：提供回滚和多版本控制(MVCC)。</p>
<p>2 重做日志(redo)</p>
<p>redo log重做日志记录的是新数据的<strong>备份</strong>，属于物理日志。在事务提交前，只要将redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。系统可以根据redo log的内容，将所有数据<strong>恢复</strong>到最新的状态。</p>
<p>redo log包括两部分：一是内存中的<strong>日志缓冲</strong>(redo log buffer)，该部分日志是<strong>易失性</strong>的；二是磁盘上的<strong>重做日志文件</strong>(redo log file)，该部分日志是<strong>持久</strong>的。</p>
<p>MySQL中redo log刷新规则采用一种称为Checkpoint的机制(利用LSN实现)，为了确保安全性，又引入double write机制。</p>
<p>4.3 MVCC</p>
<p>MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：MVCC就是<strong>行级锁</strong>的一个变种(升级版)。</p>
<p>事务的隔离级别就是通过锁的机制来实现，只不过隐藏了加锁细节。</p>
<p>在表锁中我们读写是阻塞的，基于提升并发性能的考虑，MVCC一般<strong>读写是不阻塞</strong>的。</p>
<p>MySQL中MVCC是通过redo log版本链+一致性视图Read-view实现的。</p>
<p><strong><em>慢查询</em></strong><br>1.<strong>慢日志定位</strong>慢查询sql<br>show variables like ‘%quer%’，关于quer的变量，打开慢查询日志，查看慢查询日志<br>2.使用<strong>explain分析</strong>工具<br>type找到数据的方式，index/all代表全表扫描，需要优化<br>extra 项的值<br>using filesort：使用的外部索引排序，也成文件排序，没有用到表索引<br>using temporary：mysql对查询结果排序使用临时表，常见于order by ，group by<br>3.修改sql或尽量让sql走<strong>索引</strong><br>查询优化器决定使用哪个索引</p>
<p>sql：语句后面加force index（primary）强制使用主键索引</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/image-20210419232705108.png" alt="image-20210419232705108"></p>
<p><strong><em>测试流程</em></strong></p>
<p>需求分析→测试计划→测试设计→测试环境搭建→测试执行→测试记录→缺陷管理→软件评估→测试总结→测试维护</p>
<p><strong><em>测试分类</em></strong></p>
<p>1、按开发阶段：单元测试、集成测试、系统测试、验收测试<br>2、按测试实施组织：α、β、第三方<br>3、按测试执行方式：静态测试、动态测试<br>4、按是否查看代码：黑盒测试、白盒测试、灰盒测试<br>5、按是否手工执行划分：手工测试、自动化测试<br>6、按测试对象划分：性能测试、安全测试、兼容性测试、文档测试、易用性测试（用户体验测试）、业务测试、界面测试、安装测试（功能测试、接口测试）<br>7、按测试地域划分：本地化测试、国际化测试</p>
<p><strong><em>白盒测试</em></strong></p>
<p><strong>定义</strong>：<br>　　白盒测试又称结构测试,透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例设计方法，白盒指的是程序的内部结构和<strong>目的</strong>：<br>　　通过检查软件内部的逻辑结构，对软件中的逻辑路径进行覆盖测试；在程序不同地方设置检查点，检查程序的状态，以确定实际运行状态与预期状态是否一致。</p>
<p><strong>方法：</strong>大致分为静态方法和动态方法两大类。</p>
<p>A. 静态分析：<br>　　是一种不执行程序而进行测试的技术。静态分析的主要目的是检查软件的表示和描述是否一致,没有冲突或者没有歧义。</p>
<p>B. 动态分析：<br>　　当软件系统在模拟或真实的环境中执行前、过程中和执行后,对其行为分析。它显示了一个系统在检查状态下是否正确。在动态分析技术中,最重要的技术是路径和分支测试。下面要介绍的六种覆盖测试方法属于动态分析方法。</p>
<p>（1）语句覆盖</p>
<p>使程序中的每个可执行语句都能执行一次的测试用例</p>
<p>测试用例条件： A ^ B = T</p>
<p>（2）判定覆盖（分支覆盖）</p>
<p>对于判断语句，在设计用例的时候，要设计判断语句结果为True和False的两种情况</p>
<p>测试用例条件：<br>　　　　　　　A ^ B = T<br>　　　　　　　A ^ B = F
　　　　　　　</p>
<p>（3）条件覆盖</p>
<p>设计用例时针对判断语句里面每个条件表达式true 和 false各取值一次，不考判断语句的计算结果</p>
<p>测试用例条件：<br>　　　　　　　A=T 　　　　A=F<br>　　　　　　　B=T 　　　　B=F
　　　　　　　</p>
<p>（4）判定条件覆盖（分支条件覆盖）</p>
<p>设计测试用例时，使得判断语句中每个条件表达式的所有可能结果至少出现一次，每个判断语句本身所有可能结果也至少出现一次。</p>
<p>测试用例条件：<br>　　　　　　　A ^ B = T 　　 A ^ B = F<br>　　　　　　　A=T　　　　　A=F<br>　　　　　　　B=T　　　　　B=F</p>
<p>（5）条件组合覆盖</p>
<p>设计测试用例时，使得每个判断语句中条件结果的所有可能组合至少出现一次</p>
<p>测试用例条件：<br>　　　　　　　A= T　　　 B= T<br>　　　　　　　A= T 　　　B= F<br>　　　　　　　A= F　　　 B= T<br>　　　　　　　A= F 　　　B= F</p>
<p>（6）路径覆盖</p>
<p>设计测试用例时，覆盖程序中所有可能的执行路径</p>
<p>优点：这种覆盖方法可以对程序进行彻底的测试用例覆盖，比前面讲的五种方法覆盖度都要高。</p>
<p>缺点：于路径覆盖需要对所有可能的路径进行测试（包括循环、条件组合、分支选择等），那么需要设计大量、复杂的测试用例，使得工作量呈指数级增长。路径覆盖虽然是一种比较强的覆盖，但未必考虑判断语句中条件表达式结果的组合，并不能代替条件覆盖和条件组合覆盖。</p>
<p><strong><em>冒烟测试</em></strong></p>
<p>1.冒烟测试是什么？</p>
<p>　　针对每个版本或每次<strong>需求变更</strong>后，在正式测试前，对产品或系统的一次<strong>简单</strong>的验证性测试。</p>
<p>2.冒烟测试的目的</p>
<p>　　为正式测试前，验证是否产品或系统的<strong>主要需求或预置条件</strong>是否存在bug。</p>
<p>3.冒烟测试怎么做？</p>
<p>　　最好的方法，设计出<strong>自动化测试脚本</strong>，每一次版本更新后都可以去执行脚本验证一下。</p>
<p><strong><em>Junit @Before @After</em></strong></p>
<p>@Before修饰的方法，会在测试方法之前被自动执行，所有测试方法在执行之前都会执行该方法</p>
<p>@After修饰的方法，会在测试方法执行之后自动被执行，在所有测试方法执行完之后，都会自动执行该方法</p>
<p>无论测试方法是否会出现异常，这两个修饰的方法总是会自动执行的。</p>
<p><strong><em>CS与BS的测试区别</em></strong></p>
<p>按照测试类型划分：</p>
<p>1、功能性测试：</p>
<p>C/S:服务器和客户端均会分担一部分的事务处理功能，需<strong>分开测试</strong>；</p>
<p>B/S:服务器负责主要的事务逻辑，侧重点在<strong>服务器</strong>；</p>
<p>2、业务逻辑测试：</p>
<p>C/S:cs架构的应用偏重于工作流应用，业务逻辑较多，较复杂，要设计专门的业务用例进行验证；</p>
<p>B/S:bs架构的应用更偏重于内容的展示（但是电商类型的交易网站除外），业务逻辑相对较少，着重于功能点验证；</p>
<p>3、部署测试（也可以叫安装测试）</p>
<p>C/S:应用需进行严格的<strong>安装，卸载以及更新测试</strong>；</p>
<p>B/S:侧重于<strong>部署上的测试</strong>；</p>
<p>4、GUI测试：</p>
<p>C/S:客户端界面的变化不会太频繁，比较适合使用自动化工具来简化测试工作；</p>
<p>B/S:根据浏览器渲染核心不同需要作出相应调整；从网络速率上考虑，还要调整页面中元素大小等等；</p>
<p>5、安全性测试：</p>
<p>C/S:通常应用于<strong>局域网</strong>内使用，安全性的要求稍低；</p>
<p>B/S:依赖于<strong>互联网</strong>，网络上的各种威胁较多，对于安全性的要求更高，需要进行严格的安全性测试；</p>
<p>6、性能测试：</p>
<p>C/S:客户端和服务器均能处理业务，<strong>服务器负载相对较轻</strong>，由于数据通信基于局域网，网络环境要求相对较低；</p>
<p>B/S:主要的业务处理均放在服务器端，需要着重测试服务器（应用服务器，数据库服务器，缓存服务器）等的性能表现，另外还有需要严格监视<strong>网络宽带</strong>因素；</p>
<p>7、兼容性测试：</p>
<p>C/S:主要测试对操作系统和其他安装软件的兼容性；</p>
<p>B/S:主要测试操作系统及浏览器类型的兼容性；</p>
<p>8、稳定性测试：</p>
<p>C/S:客户端的稳定性测试非常必要，待测客户端软件的环境相对来说比较复杂；</p>
<p>B/S:主要取决于服务器的性能与稳定；</p>
<p><strong><em>测试用例</em></strong></p>
<p><strong>设计方法</strong>：等价类划分法、边界值分析法、错误推测法、判定表法、正交实验法。</p>
<p><strong>点赞（抖音）</strong></p>
<ol>
<li>未点赞时，点赞按钮为浅色或灰色；点赞之后为深色或填满。</li>
<li>点赞为零时，不显示点赞数。</li>
<li>点赞大于零时，显示点赞数。</li>
<li>当点赞数过大时，达到千或万（有时百），需考虑简化点赞数，如1k或1w（跟手机屏幕也有关系）。</li>
<li>取消点赞时，点赞数需跟着减少。</li>
<li>每人每天点赞次数，按业务设置上限。</li>
<li>点赞到达上限时，是否有提示用户点赞达到上限。</li>
</ol>
<p><strong>搜索</strong></p>
<p>1：不输入任何字符，点击搜索按钮，一般搜索出网站所有的信息</p>
<p>2：一般搜索输入框中的有<strong>文章</strong>显示，当鼠标点击时，文章消失</p>
<p>3：输入全角/半角中文字符（一个字符、超长字符、已经信息字符）</p>
<p>4：输入全角/半角英文字符（一个字符、超长字符、已经信息字符）</p>
<p>5：输入全角/半角特殊字符~!@#$%^&amp;*()_+|{}:”&lt;&gt;?.,;’[]=-(注意单引号经常会发现bug)</p>
<p>6：输入全角/半角中英文空格</p>
<p>7：输入html语言</p>
<p>8：输入特殊字符串NULL、null、&amp;nbsp空格的转义字 符；&lt;scrīpt&gt;&lt;/scrīpt&gt;；<br>；<tr>；<td>；&lt; /tr&gt;；</td>；</html>；</body>；</table></p>
<p>9：输入javascript</p>
<p><strong>电梯</strong></p>
<p>测试电梯能否实现正常的上升和下降功能，每层是否都可以停靠。</p>
<p>每层停靠楼层是否与所按的楼层一致</p>
<p>电梯按键在按下时是否点亮按键灯</p>
<p>电梯在每个楼层的上行和下行的申请是否可以有效</p>
<p>电梯满负载的时候，是否会忽略其他楼层外部的上行和下行申请</p>
<p>电梯的两边按钮是否都可以使用，三列按钮。</p>
<p>电梯的楼层选择是否可以取消电梯门的打开，关闭是否正常关闭（自动关闭）。</p>
<p>报警装置是否可用。</p>
<p>（满载）超重时是否能强制关门超重时重新挪动一下人员是否可以上下行与另外一部电梯之间是否协作良好。</p>
<p>（算法）电梯的灯光是否满足看书的要求联系外界的电话是否可用通风状况如何，人多的时候是否会很热，通风不畅（排气扇）</p>
<p>电梯里面的摄像头是否可用，拍摄是否清晰</p>
<p>门不夹人伸手的话，应该不会强制关门管理员可以和内部人通话在各种场合下，可以强制开门运行中时，不能按开门键，不会强制开门在不同情况下（如：有人挡着、马上关门的时候、停电的时候、没有请求的时候…），一直按开门键和关门键从电梯外部可以强制开门</p>
<p><strong>购物车</strong></p>
<p>功能性测试:</p>
<p>1.购物车是否可以添加商品</p>
<p>2.购物车的优惠券是否可以使用</p>
<p>3.购物车的计算结果是否正确</p>
<p>4.如果使用购物券购物车里面的价格是否发送改变</p>
<p>5.未登录时购物车是否可以正常显示</p>
<p>6.如果没有登录会不会让你登录之后才可以使用</p>
<p>7.所有的页面链接功能是否正常，是否可以正确跳转到指定页面</p>
<p>8.商品没有勾选时结算按钮是否可以点击</p>
<p>9.购物车页面时用户是否可以取消订单，或者进入订单和客服进行聊天</p>
<p>10.卖家在线时是否显示在线</p>
<p>11.购物车添加的商品是否可以有数量上限</p>
<p>12.购物车点击几件商品时点击结算会不会跳转到支付页面</p>
<p>13.是否可以批量删除商品</p>
<p>14.如果没有在指定时间下单，订单会不会自动失效并在购物车清除该商品信息</p>
<p>15.可否对添加的商品是否可以进行 增加</p>
<p>16.商品信息过长是否可以显示完整</p>
<p>17.商品是否可以进行收藏并推荐相似的商品（宝贝）</p>
<p>18.购物车中的降价商品，库存紧张商品是否成功分类<br>19.购物车商品降价时，购物车是否显示降价信息</p>
<p>性能性测试:</p>
<p>20.打开购物车这个页面需要多长时间</p>
<p>21.弱网时是否还可以进行添加商品，计算商品的价格并且可以正常结算</p>
<p>22.无网状态下是否提醒请检测你的网络设置</p>
<p>23.用户过多会不会使购物车服务器崩溃</p>
<p>24.编辑购物车：删除、添加商品需要的时间。</p>
<p>25.在购物车页面选择需要购买的商品进行结算的时候，结算金额可不可以实时显示。</p>
<p>26.清空失效商品需要的时间。</p>
<p>兼容性测试</p>
<p>27.ios:不同型号，不同ios的手机系统的耗电情况，打开速度，安装后是否闪退，卸载</p>
<p>28.安卓：不同品牌，不同型号，不同的安卓系统，手机系统的耗电情况，打开速度，安装后是否闪退，卸载<br>29.web端的打开速度</p>
<p>界面测试</p>
<p>30.购物车界面是否完善</p>
<p>31.各个功能的设计是否美观 ，大小是否合适</p>
<p>32.页面的功能按钮可以正常显示。</p>
<p>33.商品的最下方显示失效宝贝。</p>
<p>34.页面的最低端显示“你可能喜欢”</p>
<p>35.购物车中如果存在有商品降价、库存不足、限购件数等，在商品详情的下面，会有对应的字体展示</p>
<p>安全性测试</p>
<p>36.用户实名认证后个人信息是否会泄露</p>
<p>37.是否需要绑定手机号</p>
<p>易用性测试</p>
<p>38.是否方便人们操作</p>
<p>39.是否有免密码支付功能</p>
<p>40.是否具有青少年模式</p>
<p><strong>微信语音输入</strong></p>
<p><strong>功能测试</strong><br>不说话的时候发送语音, 是否会有相关的信息提示<br>说话分贝很轻很轻, 是否可以录入语言<br>普通的语音信息是否可以正常发送<br>语音录制的时候是否有时间限制(最短限制 / 最长限制)<br>录制时间不足最短时长限制会发送失败<br>超出了最长时间限制时, 语音自动保存并发送<br>语音识别<br>是否可以录入中文, 英文, 日语…<br>是否可以录入小动物的声音: 狗叫, 猫叫, 羊叫…<br>是否可以录入其他声音: 汽笛, 施工声…<br>是否可以取消语音发送<br>是否可以将语音转换成文字<br>语音发送后<br>对方是否可以立即受到<br>语音信息上是否会显示所发语音的时长, 以及语音标志<br>在多长时间内可以撤回<br>超出了撤回时长, 不可以再撤回<br>如果语音发送失败, 是否会有相应的提示<br>如果语音未发出去, 是否会有相应的提示<br>语音显示长度应该和说话时长成正比, 说话时长越长, 语音信息显示的长度越长<br>如果一次发送了多条语音, 是否会因为网络不稳定原因而打乱顺序<br>对方收到的语音和你发送的语音内容, 音量大小是否一致<br><strong>性能测试</strong><br>语音录制结束到发送语音成功的响应时间是多少<br>发送语音后, 对方是否可以立马收到语音消息提示<br>不停地发送语音, 发送的时间是否会有迟缓<br>将语音转换成文字全部显示出来的响应时间<br>发送一条语音的耗电量<br>打开语音发送界面对于手机或者电脑资源的占用情况<br><strong>界面测试</strong><br>界面设计, 排版是否合理<br>界面上是否有错别字<br>语音图标是否正常显示<br>语音图标的显示位置是否设计合理, 是否符合人的使用习惯<br>语音图标是否可以正常点击<br>语音按钮是上是否会有文字说明<br>录制语音时, 声音采集器会随着分贝的大小而变化<br>在点击取消发送按钮时, 按钮变成红色<br>语音是否已读<br>如果语音未读, 则会在语音前显示红点<br>如果语音已读, 则没有红点显示<br>语音消息上显示语音时长<br>播放的时候, 语音图标会闪烁表示正在播放中<br>如果语音未发送出去. 语音信息前显示红色的感叹号<br>兼容性测试<br>不同手机系统下是否可以发送语音:<br>安卓手机<br>苹果手机<br>不同手机型号和不同的微信版本是否都可以发送语音<br>PC 端是否可以发语音:<br>Windows 电脑<br>MAC 电脑<br>手机端发送的语音, 电脑端是否可以同步接收, 反之电脑端发送的语音, 手机端是否可以同步接收<br>安全测试和网络测试<br>如果发送的语音中有敏感信息, 语音是否可以成功发送<br>如果撤回, 对方是否还可以看见被撤回的语音消息<br>如果发语音是, 发生了中断, 有电话和短信接进来, 关机, 重启, 语音是否还可以正常发送<br>弱网情况下(2G, 3G, wifi), 是否可以正常的发送语音<br>不同网络运营商下是否可以正常发送<br>中国移动<br>中国电吸<br>中国联通<br>网络间发生切换, 语音是否可以正常发送<br>网络从断开到连接<br>3G 切换到 4G / wifi<br><strong>易用性测试</strong><br>点击一条语音信息后, 是否可以自动播放所有未读取的语音信息<br>是否可以根据手机和耳部的距离自动转换模式(扬声器模式 / 听筒模式)</p>
<p><strong>微信聊天测试</strong></p>
<p>微信聊天窗口支持发送文字、图片、表情、小视频、语音、视频</p>
<p>网络正常状态下，单聊的情境下：</p>
<ol>
<li>发送文字、图片、表情、小视频、语音，发送是否成功</li>
<li>接收文字、图片、表情、小视频、语音是否成功</li>
<li>发送文字、图片、表情、小视频、语音最大值测试</li>
<li>是否支持发送文件（群聊文件）</li>
<li>是否支持将语音转化为文字</li>
<li>发送语音、视频聊天，是否有声音提示</li>
<li>发送语音、视频聊天，长时间无人接听时，是否有提示信息？</li>
<li>语音聊天切换到视频聊天是否正常？</li>
<li>视频聊天切换到语音是否正常？</li>
<li>消息发送失败，是否支持重发？</li>
<li>消息发送后，是否支持撤回，在设定的时间内，是否能撤回？超出时间不能撤回？</li>
<li>未加好友状态下，是否能发送消息？</li>
<li>提示的对方还不是你的好友时，是否支持加好友功能？</li>
<li>加好友后，发送消息是否正常？</li>
<li>连续发消息，消息统计的数量是否正常？</li>
<li>消息较多时，是否支持一键到上次浏览的地方？</li>
</ol>
<p>网络正常状态下，群聊的情景下：</p>
<ol>
<li>发送文字、图片、表情、小视频、语音，是否所有成员都能看到</li>
<li>@个人、多人、全部人时，是否有提醒</li>
<li>发起群视频，所有被邀请的成员，是否能加入群聊</li>
<li>群聊数量统计是否正确</li>
</ol>
<p>网络不稳定或无网络情景下：</p>
<ol>
<li>给无网络或网络不稳定的好友发送信息，恢复网络，是否能接收正常</li>
<li>给无网络或网络不稳定的好友发送语音、视频时，恢复网络时，是否有提示</li>
<li>语音聊天、视频聊天时，网络出现异常时，是否有提示，网络恢复后，是否正常</li>
</ol>
<p>中断测试：</p>
<ol>
<li>正在编辑消息时，语音、视频聊天中断，结束后，是否回到正在编辑中的聊天框中</li>
<li>正在语音或视频聊天时，电话、短信进入，是否有提示</li>
<li>正在语音或视频聊天时，手电低电耗进入，是否有提示</li>
</ol>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><strong><em>Git常用命令</em></strong></p>
<p><img src="http://typora-imagehosting.oss-cn-shanghai.aliyuncs.com/img/bg2015120901.png" alt="img"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<p><strong><em>常用自动化测试工具</em></strong></p>
<p>1、Appium</p>
<p>官网：<a target="_blank" rel="noopener" href="http://appium.io/">http://appium.io</a></p>
<p>AppUI自动化测试</p>
<p>Appium 是一个移动端自动化测试开源工具，支持iOS 和Android 平台，支持Python、Java 等语言，即同一套Java 或Python 脚本可以同时运行在iOS 和Android平台，Appium 是一个C/S 架构，核心是一个 Web 服务器，它提供了一套 REST 的接口。当收到客户端的连接后，就会监听到命令，然后在移动设备上执行这些命令，最后将执行结果放在 HTTP 响应中返还给客户端。</p>
<p>License：免费</p>
<p>2、<strong>Selenium</strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.seleniumhq.org/download/">https://www.seleniumhq.org/download/</a></p>
<p>WebUI自动化测试</p>
<p>Selenium是一个用于Web应用程序测试的工具，Selenium已经成为Web自动化测试工程师的首选。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE(7、8、9)、Mozilla Firefox、Mozilla Suite等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。Selenium 是ThoughtWorks专门为Web应用程序编写的一个验收测试工具。其升级版本为Webdriver。</p>
<p>License：免费</p>
<p>3、<strong>Postman</strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.getpostman.com/">https://www.getpostman.com</a></p>
<p>接口测试</p>
<p> Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。不仅如此，它还提供测试数据和环境配置数据的导入导出，付费的 Post Cloud 用户还能够创建自己的 Team Library 用来团队协作式的测试，并能够将自己的测试收藏夹和用例数据分享给团队。</p>
<p>License：免费</p>
<p>4、Soapui</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.soapui.org/">https://www.soapui.org</a></p>
<p>接口测试</p>
<p>SoapUI提供了所有所需的工具来测试和完善的测试。总览标签给你一个项目的所有内容和全面的看法。只需一次点击，您可以添加任何数量的断言为验证传入的消息TestStep。使用功能强大的HTTP监视器记录，分析甚至修改客户机 - 服务器通信，因为它发生。和SoapUI临带来了更专业和先进的功能，保持遥遥领先其他测试工具。轻松创建和运行数据驱动测试。该数据源TestStep读取测试数据从任何外部来源 - Excel中，XML，JDBC，文件，等等 - 到标准SoapUI属性。</p>
<p>License：免费</p>
<p>5、Robot Framework</p>
<p>官网：<a target="_blank" rel="noopener" href="http://robotframework.org/">http://robotframework.org</a>  </p>
<p>WebUI自动化测试，接口测试，APP测试</p>
<p>   Robot Framework是一款python编写的功能自动化测试框架。具备良好的可扩展性，支持关键字驱动，可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。主要用于轮次很多的验收测试和验收测试驱动开发。</p>
<p>Robot framework为不同的自动化测试需求提供了不同的框架。它的测试能力可以通过 Python 和 Java 测试库得到扩展。Selenium WebDriver 是 Robot Framework 中内置的流行库。</p>
<p>Robot Framework 不仅仅是网页测试工具，同样可以用来做 Android 和 iOS 的自动化测试。对于关键字测试驱动熟悉的测试员可以轻松上手 Robot Framework。</p>
<p>License：免费  </p>
<p>6、QTP</p>
<p>官网：<a target="_blank" rel="noopener" href="https://software.microfocus.com/en-us/products/unified-functional-automated-testing/overview">https://software.microfocus.com/en-us/products/unified-functional-automated-testing/overview</a></p>
<p>WebUI自动化测试，接口测试，APP测试</p>
<p>HP QuickTest Professional 提供符合所有主要应用软件环境的功能测试和回归测试的自动化。采用关键字驱动的理念以简化测试用例的创建和维护。它让用户可以直接录制屏幕上的操作流程，自动生成功能测试或者回归测试用例。专业的测试者也可以通过提供的内置脚本和调试环境来取得对测试和对象属性的完全控制。目前版本名为Unified Functional Testing，简称UFT。可以测试非常多的应用，比如接口API，Web services，桌面程序，Web系统，手机APP。</p>
<p>License：商业</p>
<p>7、<strong>Jmeter</strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://jmeter.apache.org/">https://jmeter.apache.org</a></p>
<p>接口测试，性能测试</p>
<p>JMeter是Apache组织的开放源代码项目，它是功能和性能测试的工具，100%的用java实现；</p>
<p>JMeter可以用于测试静态或者动态资源的性能（文件、Servlets、Perl脚本、java对象、数据库和查询、ftp服务器或者其他的资源）。JMeter用于模拟在服务器、网络或者其他对象上附加高负载以测试他们提供服务的受压能力，或者分析他们提供的服务在不同负载条件下的总性能情况。你可以用JMeter提供的图形化界面分析性能指标或者在高负载情况下测试服务器/脚本/对象的行为。</p>
<p>使用Jmeter做接口测试需要注意一点，小心使用“用户定义变量”，Jmeter组件有优先级的，如果多个线程同时执行的时候，“用户定义变量”组件定义的变量可能会乱套。</p>
<p>License：免费</p>
<p>8、<strong>Loadrunner</strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://software.microfocus.com/en-us/products/loadrunner-load-testing/overview">https://software.microfocus.com/en-us/products/loadrunner-load-testing/overview</a></p>
<p>性能测试</p>
<p>LoadRunner，是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner能够对整个企业架构进行测试。企业使用LoadRunner能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期。 LoadRunner可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。</p>
<p>License：商业</p>
<p>9、Monkey</p>
<p>App稳定性测试</p>
<p>软件附带在sdk中，适用于android和ios，通过adb shell，生成用户或系统的伪随机事件，压力测试结果：崩溃crash，无响应anr。</p>
<p>License：免费</p>
<p>10、GT</p>
<p>官网：<a target="_blank" rel="noopener" href="http://gt.qq.com/index.html">http://gt.qq.com/index.html</a></p>
<p>App性能测试</p>
<p>GT（随身调）是APP的随身调测平台，它是直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)。利用GT，仅凭一部手机，无需连接电脑，您即可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。</p>
<p>License：免费</p>
<p>11、Appscan</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/downloads/r/appscan/">https://www.ibm.com/developerworks/downloads/r/appscan/</a></p>
<p>安全测试</p>
<p>IBM Security AppScan 是一个适合安全专家的 Web 应用程序和 Web 服务渗透测试解决方案，对现代 Web 应用程序和服务执行自动化的动态应用程序安全测试 (DAST) 和交互式应用程序安全测试 (IAST)，支持 Web 2.0、JavaScript 和 AJAX 框架的全面的 JavaScript 执行引擎，涵盖 XML 和 JSON 基础架构的 SOAP 和 REST Web 服务测试支持 WS-Security 标准、XML 加密和 XML 签名，详细的漏洞公告和修复建议。</p>
<p>License：免费</p>
<p>12、<strong>Jenkins</strong></p>
<p>官网：<a target="_blank" rel="noopener" href="https://jenkins.io/">https://jenkins.io</a></p>
<p>持续集成</p>
<p>自动化构建 编译，部署，任务执行，测试报告，邮件通知等。</p>
<p>License：免费</p>
<p><strong><em>拓展知识</em></strong></p>
<p><strong>CDN</strong></p>
<p><strong>全称</strong>:Content Delivery Network或Content Ddistribute Network，即<strong>内容分发网络</strong></p>
<p><strong>基本思路</strong>：</p>
<p>尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置<strong>节点服务器</strong>所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户<strong>最近的服务节点</strong>上。</p>
<p><strong>目的</strong>：</p>
<p>解决因分布、带宽、服务器性能带来的<strong>访问延迟</strong>问题，适用于站点加速、点播、直播等场景。使用户可<strong>就近取得所需内容</strong>，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。</p>
<p>控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。</p>

        </div>

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev btn"
                           rel="prev"
                           href="/2021/04/24/JVM%E6%8E%A2%E7%A9%B6/"
                        >
                            <i class="fa fa-chevron-left"></i>
                            <span class="post-nav-title-item">JVM探究</span>
                            <span class="post-nav-item">上一篇</span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next btn"
                           rel="next"
                           href="/2021/03/20/SpringBoot%E6%95%99%E7%A8%8B/"
                        >
                            <span class="post-nav-title-item">SpringBoot教程</span>
                            <span class="post-nav-item">下一篇</span>
                            <i class="fa fa-chevron-right"></i>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                    

                </main>

            </div>

            <div class="page-main-content-bottom">
                <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy; 2022 <i class="fa fa-heart-o"></i> <a href="/">Homgun</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a
                    href="https://github.com/XPoet/hexo-theme-ils" target="_blank">ILS v2.1.0</a>
        </div>
    </div>
</footer>

            </div>
        </div>
    </main>

    <div class="sidebar-tools">
        <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fa fa-search"></i>
            </li>
        

        

        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa fa-outdent"></i>
            </li>
        

    </ul>
</div>

    </div>

    <div class="sidebar-tools-2">
        <div class="tools2-container">

    <button class="tools-button">
        <i class="fa fa-plus"></i>
    </button>

    <ul class="tools-wrapper">
        <!-- back2top -->
        
            <li class="tools-item scroll-to-bottom">
                <i class="fa fa-arrow-down"></i>
            </li>
            <li class="tools-item scroll-to-top">
                <i class="fa fa-arrow-up"></i>
            </li>
        

        <!-- mode toggle -->
        <li class="tools-item mode-toggle">
            <i class="fa fa-moon-o"></i>
        </li>

        <!-- rss -->
        


    </ul>
</div>

    </div>


    <!-- page aside -->
    <aside class="page-aside">
        
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java"><span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JVM"><span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVC"><span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">源码解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81"><span class="nav-text">手撕代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E6%A1%86%E6%9E%B6"><span class="nav-text">Java框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-text">网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-text">工具</span></a></li></ol>
    </div>
</div>
        
    </aside>

</div>



    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fa fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="/js/utils.js"></script>
<script src="/js/header-shrink.js"></script>
<script src="/js/dark-light-toggle.js"></script>
<script src="/js/main.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/back2top.js"></script>





    
<script src="/js/left-side-toggle.js"></script>


    
        
<script src="/js/code-copy.js"></script>

    

    
        
<script src="/lib/anime.min.js"></script>
<script src="/js/toc.js"></script>

    


</body>
</html>
[{"title":"JavaScript入门","url":"/2020/10/26/JavaScript%E5%85%A5%E9%97%A8/","content":"1 基础语法比较运算符===  //等于（类型不同，值一样，也会判断为true）=== //绝对等于（类型一样，值一样，结果才为true）\n\n这是一个JS的缺陷，坚持不要使用 == 比较\n须知：\n\nNaN===NaN返回false，NaN与所有数值都不相等，包括自己\n只能通过isNaN(NaN)来判断这个数是否是NaN\n\n尽量避免使用浮点数进行运算，存在精度问题\nMath.abs(1/3-(1-2/3))&lt;0.000000001\n\n严格检查模式全局变量 i = 1;\n局部变量 var i = 1; let i = 1;（ES6建议使用let）\n严格检查模式\n‘use strict’; 严格检查模式，预防JavaScript的随意性导致产生的一些问题\n字符串多行字符串：\n`XXX\nXXX`\n模板字符串\n`hello,${变量}`\nstr.length str[0] str.toUpperCase() str.toLowerCase()\nstr.subsring(X,Y)返回str[X,Y)\n数组var arr = [1,2,3,4,5,&#x27;hello&#x27;,null,true];new Array(1,2,3,4,5,&#x27;hello&#x27;,null,true);\n\n取数组下标，如果越界(arr[8]),就会提示undifined\n假如给数组的长度arr.length赋值，数组大小就会发生变化\nindexOf：通过元素获得下标索引\nslice()截取Array的一部分，类似字符串中的substring\narr.push(),arr.pop() // 尾部\narr.unshift(),shift() // 头部 \narr.sort()\narr.reverse()\narr.concat() // 不会改变原数组\narr.join(‘-‘) // 连接符 打印\narr.fill(X)\n对象\n每个属性之间使用逗号隔开，最后一个不需要添加\n\nvar person = &#123;    name:&quot;XXX&quot;,    age:18,    tags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;...&#x27;]&#125;\n\n对象赋值：person.name = “XXX”\n取对象的值：person.name\n使用一个不存在的对象属性，不会报错！undefined\n动态删除，添加对象的属性：delete person.name person.XXX=XXX\nJavaScript中所有键都是字符串，值是任意对象\n判断属性值是否在这个对象中！’XXX’ in XXX\n判断一个属性是否是这个对象自身拥有的 hasOwnProperty()\n流程控制arr.forEach(function (value)&#123;  // ES5.1\tconsole.log(value)&#125;)for(var i in arr)&#123;   // i为数组下标&#125;for(var e of arr)&#123;   // e为数组元素&#125;\n\nMap和SetES6的新特性\nvar map = new Map([[&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90]]);var name = map.get(&#x27;tom&#x27;);map.set(&#x27;admin&#x27;,123); // 新增map.delete(&#x27;XXX&#x27;);console.log(name);var set = new Set(1,1,1,3); // 去重set.add(x);set.delete(x);set.has(x);\n\niterater ES6新特性\n函数function abs(x)&#123;\t//定义方式一    //...&#125;var abs = function(x)&#123;\t//定义方式二    //...&#125;\n\n如果没有执行return，函数执行完也会返回结果：undefined\nJavaScript可以传任意参数，也可以不传参数\nvar abs = function(x)&#123;    //手动抛出异常    if(typeof x != &#x27;number&#x27;)&#123;        throw &#x27;Not a Number&#x27;;    &#125;    if(x &gt;= 0)&#123;        return x;    &#125;else&#123;        return -x;    &#125;&#125;\n\narguments参数表示函数传入的所有参数，是一个数组\nrest剩余参数，只能写在最后面，必须用…表示\nfunction aaa(a,b,...rest)&#123;    consloe(&quot;a-&gt;&quot;+a);    consloe(&quot;b-&gt;&quot;+b);    consloe(&quot;rest-&gt;&quot;+rest);&#125;\n\n全局对象 window所有全局变量都绑定在全局对象window上的\nwindow.x（全局变量）\nwindows.alert(window.x)\nvar old_alert = window.alert;//old_alert(x);window.alert = function()&#123;    &#125;;window.alert(123); //失效//恢复window.alert = old_alert;window.alert(456);\n\n全局变量→冲突\n//唯一全局变量var App = &#123;&#125;;//定义全局变量App.name = &#x27;XXX&#x27;;App.add = function (a,b) &#123;    return a + b;&#125;\n\n把自己代码全部放入自己定义的唯一命名空间中，降低全局命名冲突的问题（JQuery）\nES6建议使用let关键字去定义局部作用域的变量（解决局部作用域冲突的问题），使用const定义常量const PI = &#39;3.14&#39;\n方法var XXX = &#123;\tname:&#x27;xxx&#x27;,\tbirth:2020,\t//方法\tage:function()&#123;        var now = new Date().getFullYear();        return now - this.birth;    &#125;&#125;XXX.nameXXX.age()\n\napply在js中可以控制this指向，通过 apply() 方法，能够编写用于不同对象的方法。函数.apply(对象,参数列表)this指向apply的对象\n2 内部对象\n标准对象\n\nnumber, string, boolean, object\ntypeof NaN&quot;number&quot;typeof []&quot;object&quot;typeof undefined&quot;undefined&quot;\n\n2.1 Datevar now = new Date();now.getFullYear(); // 年now.getMonth(); //月（0-11）now.getDate(); //日now.getDay(); //星期几now.getHours(); //时now.getMinutes(); //分now.getSeconds(); //秒now.getTime(); //时间戳 1970.1.1 00:00 - msconsole.log(new Date(113224222)) //时间戳转为时间//转换为字符串now.toLocaleString()now.toGMTString()\n\n2.2 JSON\nJSON(JavaScript Object Notation, JS 对象表示法) 是一种轻量级的数据交换格式。\n\n特点：简洁，清晰的层次结构；易于人阅读和编写，同时也易于机器解析和生成，有效提升网络传输效率\n在JavaScript中一切皆对象，任何JS支持的类型都可以用JSON来表示\n格式：\n\n对象：{}\n数组：[]\n键值对：key:value\n\nJSON字符串和JS对象的转化\nvar user = &#123;    name: &quot;XXX&quot;,    age: 3,    sex: &#x27;男&#x27;&#125;//对象转化为JSON对象var jsonUser = JSON.stringify()//json字符串转化为对象,参数为json字符串var obj = JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;XXX&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;)\n\n2.3 Ajax\n原生的js写法 xhr异步请求\n\nJQuery封装好的方法 $(“#name”).ajax(“”)\n\naxios 请求\n\n\n3 面向对象编程原型：子类（对象）.__proto__ = 父类（原型对象）; //子类的原型是父类\n随意指向\nclass关键字是在ES6引入的\nclass Student&#123;    constructor(name)&#123;        this.name = name;    &#125;    hello()&#123;        alert(&#x27;hello&#x27;)    &#125;&#125;class pupil extends Student&#123;    constructor(name,grade)&#123;        super(name);        this.grade = grade;    &#125;    myGrade()&#123;        alert(&#x27;我是一名小学生&#x27;)    &#125;&#125;var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);xiaoming.hello();\n\n\n\n原型链：_proto_\\\n\n4 操作BOM对象（重点）\nBOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。\n\n浏览器：\n内核：IE， Chrome, Safari, FireFox\n三方：QQ，360\n4.1 windowwindow代表浏览器窗口\nwindow.alert(1)// 调整浏览器窗口大小window.innerHeightwindow.innerWidthwindow.outerHeightwindow.innerWidth\n\n4.2 navigatornavigator封装了浏览器的信息\nnavigator.appNamenavigator.appVersionnavigator.userAgentnavigator.platform\n\n一般不使用，因为会被人为修改，不建议用这些属性来判断浏览器版本\n4.3 screenscreen代表屏幕尺寸\nscreen.widthscreen.height\n\n4.4 location（重要）location代表当前页面的URL信息\nhost: &quot;www.bilibili.com&quot;hostname: &quot;www.bilibili.com&quot;href: &quot;https://www.bilibili.com/video/BV1JJ41177di?p=19&quot;protocol: &quot;https:&quot;reload: ƒ reload() // 刷新页面// 设置新的地址location.assign(&#x27;https://...&#x27;)\n\n4.5 documentdocument代表当前的页面（document.），HTML DOM文档树\n//获取具体的文档树节点&lt;dl id=&quot;app&quot;&gt;    &lt;dt&gt;Java&lt;/dt&gt;    &lt;dd&gt;JavaSE&lt;/dd&gt;&lt;/dl&gt;&lt;script&gt;\tvar dl = document.getElementById(&#x27;app&#x27;);&lt;/script&gt;\n\n获取cookie\ndocument.cookie&quot;finger=158939783; _uuid=C56A5201-E5AB-30A7-6A3D-33573CFAEC4B75115infoc; buvid3=2DE4F72B-D52C-4628-B6F6-D25A79D4DFBD155818infoc; sid=jsr4r70q; im_notify_type_775959=0; LIVE_BUVID=AUTO6215819975268326; LIVE_PLAYER_TYPE=2; DedeUserID=775959; DedeUserID__ckMd5=5a93072db131a757; bili_jct=e4c30825e9523f0d624509aa21012a7e; rpdid=|(J~RllJRmlY0J&#x27;ulm)RkRm)l; blackside_state=1; CURRENT_FNVAL=80; bp_t_offset_775959=434460479141307658; Hm_lvt_8a6e55dbd2870f0f5bc9194cddf32a02=1600696828; CURRENT_QUALITY=80; bp_video_offset_775959=438421933640865406; finger=158939783; PVID=3&quot;\n\n劫持cookie原理\nwww.taobao.com\n&lt;script src=&quot;aa.js&quot;&gt;&lt;/script&gt;&lt;!-- 恶意人员：获取你的cookie上传到他的服务器 --&gt;\n\n服务器可以设置：httpOnly（安全）\n4.6 historyhistory代表浏览器的历史记录（不建议使用）\nhistory.back()history.forward()\n\n5 操作DOM对象（重点）\n文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本,更新其内容、结构和www文档的风格(目前,HTML和XML文档是通过说明部分定义的)。\n\n浏览器网页就是一个DOM树形结构，要操作一个DOM节点，就必须先获得这个DOM节点\n5.1 获得DOM节点标签选择器：document.getElementsByTagName(&#39;h1&#39;)（返回数组）\nid选择器：documen.getElementById(&#39;id&#39;)\nclass选择器：document.getElementByClassName(&#39;class&#39;)（返回数组）\n获得子节点：Node.children\n5.2 更新DOM节点修改文本值：\nNode.innerText = &#39;xxx&#39;\nNode.innerHTML = &#39;xxx&#39;（超文本）\n设置样式：\nNode.style.color/fontSize/... = &#39;xxx&#39;（驼峰命名）\n5.3 删除DOM节点先获取父节点，再通过父节点删除自己\nNode.parentElement.removeChild(Node)（只能通过id选择器选择节点删除）\n注意：删除节点过程中，父节点的children是动态变化的\n5.4 插入DOM节点获得的DOM节点若为空节点，可以通过innerText增加元素\n追加节点：Node1.append(Node2)\n创建新节点：document.createElement(&#39;p&#39;)\n设置节点属性：Node = setAttribute(&#39;属性名&#39;,&#39;属性值&#39;)\n插入节点：Node.insertBefore(newItem,existingItem);\n6 操作表单（验证）表单的目的：提交信息\n获得要提交的信息\ninput_text.valueboy_radio.checked //boolean\n\nMD5加密密码\n表单绑定提交事件\nonsubmit= 绑定一个提交检测的函数，返回布尔值（return false：不提交表单）\n7 jQuery公式：$(selector).action()\n$(&#x27;#id&#x27;).click(function()&#123;    //...&#125;)//当网页元素加载完毕之后，响应事件$(document).ready(function()&#123;    //...&#125;)//↑简写,获取坐标$(function()&#123;    $(&#x27;#divMove&#x27;).mousemove(function(e)&#123;        $(&#x27;mouseMove&#x27;).text(&#x27;x:&#x27;+e.pageX+&#x27;y:&#x27;+e.pageY)    &#125;)&#125;)\n\n文档工具站：https://jquery.cuishifeng.cn/\n操作DOM：\n$(&#x27;#test-ul li[name=python]&#x27;).css(&#123;&quot;color&quot;,&quot;red&quot;&#125;)$(&#x27;#test-ul li[name=python]&#x27;).show()/hide()$(window).width\n\n\n\nLayUI 弹窗组件\nElementUI 样式好看\n","tags":["JavaScript","JQuery"]},{"title":"Hello World","url":"/2020/10/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"网络编程入门","url":"/2020/10/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/","content":"1 概述计算机网络：地理位置不同 多台计算机 连接 通信 共享\n网络编程的目的：数据交换，通信\n如何实现多台主机之间的数据通信：\n\n准确定位网络上的一台主机以及该主机的某个资源（IP：Port）\n传输数据？\n\nJavaWeb：网页编程  B/S\n网络编程：TCP/IP      C/S\n2 网络通信的要素实现网络通信需要知道通信双方地址（ip、端口号）\n规则：网络通信协议\nTCP/IP参考模型：\n\n网络编程专门针对传输层（TCP/IP）\n3 IPip地址：InetAddress\n\n唯一定位一台网络上的计算机\n127.0.0.1：本机localhost\nip地址的分类：\nipv4/ipv6\nipv4：10.164.120.176    4个字节组成，0~255，42亿中30亿在北美，亚洲4亿，2011年就用尽\nipv6：fe80::a1a2:85b0:e7d9:58f1%7  128位，8个无符号整数  \n\n\n公网（互联网） 私网（局域网）\nABCD类地址\n192.168.xx.xx 专门给组织内部使用的\n\n\n\n\n域名→记忆IP问题！\n\n4 端口端口表示计算机上的一个程序的进程：\n\n不同进程有不同的端口号！（不能冲突）用来区分进程！\n\n范围：0~65535\n\nTCP，UDP：65535*2 单个协议下，端口号不能冲突\n\n端口分类\n\n公有端口 0~1023\n\nHTTP：80\nHTTPS：443\nFTP：21\nTelnet：23\n\n\n程序注册端口：1024~49151 分配给用户或者程序\n\nTomcat：8080\nMySQL：3306\nOracle：1521\n\n\n动态/私有端口：49152~65535\nnetstat -ano #查看所有端口netstat -ano|findstr &quot;端口号&quot; #查看指定的端口tasklist|findstr &quot;端口号&quot; #查看指定端口的进程\n\n\n\n\n\n5 通信协议协议：约定\n网络通信协议：速率，传输码率，代码结构，传输控制……\nTCP/IP协议簇\n重要：\n\nTCP：传输控制协议\nUDP：用户数据报协议\n\nTCP vs UDP\n打电话~TCP\n\n连接，稳定\n\n三次握手，四次挥手\n最少需要三次，保证稳定连接！A:你瞅啥？B:瞅你咋地？A:干一场！A:我要走了B:你真的要走了吗？B:你真的真的要走了吗？A:我真的真的要走了！\n\n\n\n客户端、服务端\n\n传输完成，释放连接，效率低\n\n\n发短信~UDP\n\n不连接，不稳定\n客户端、服务器：没有明确的界限\n不管有没有准备好，都可以发给你\n导弹\nDDoS：洪水攻击（饱和攻击）\n\n6 TCP聊天客户端\n\n通过Socket连接服务器\n发送消息\n\npackage tcp;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\tInetAddress serverIP = null;\t\tint port = 0;\t\tSocket socket = null;\t\tOutputStream os = null;\t\ttry &#123;\t\t\t//1.得知服务器地址\t\t\tserverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\tport = 9999;\t\t\t//2.创建一个socket连接\t\t\tsocket = new Socket(serverIP,port);\t\t\t//3.发送消息\t\t\tos = socket.getOutputStream();\t\t\tos.write(&quot;你好&quot;.getBytes());\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\tif(os!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;            if(socket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tsocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t&#125;&#125;\n\n服务器端\n\n建立服务端口\n通过accept等待用户连接\n接收用户消息\n\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tServerSocket serverSocket = null;\t\tSocket socket = null;\t\tInputStream is = null;\t\tByteArrayOutputStream baos = null;\t\t\t\ttry &#123;\t\t\t//1.有地址\t\t\tserverSocket = new ServerSocket(9999);\t\t\t//2.等待客户端连接\t\t\tsocket = serverSocket.accept();\t\t\t//3.读取客户端的消息\t\t\tis = socket.getInputStream();\t\t\t//管道流\t\t\tbaos = new ByteArrayOutputStream();\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tbaos.write(buffer,0,len);\t\t\t&#125;\t\t\tSystem.out.println(baos.toString());\t\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\t//关闭资源\t\t\tif(baos!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tbaos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(is!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(serverSocket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tserverSocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\n\n\n\n文件上传服务器端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import org.omg.CORBA_2_3.portable.OutputStream;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\t\ttry &#123;\t\t\t//1.创建服务\t\t\tServerSocket serverSocket = new ServerSocket(9999);\t\t\t//2.监听客户端连接\t\t\tSocket socket = serverSocket.accept();\t\t\t//3.读取输入流\t\t\tInputStream is = socket.getInputStream();\t\t\t//4.文件输出\t\t\tFileOutputStream fos = new FileOutputStream(new File(&quot;receive.jpg&quot;));\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tfos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tis.close();\t\t\tfos.close();\t\t\tsocket.close();\t\t\tserverSocket.close();\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\n客户端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\t//1.创建一个socket连接\t\t\tSocket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);\t\t\t//2.创建一个输出流\t\t\tOutputStream os = socket.getOutputStream();\t\t\t//3.读取文件\t\t\tFileInputStream fis = new FileInputStream(new File(&quot;dog.jpg&quot;));\t\t\t//4.写出文件\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=fis.read(buffer))!=-1)&#123;\t\t\t\tos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tfis.close();\t\t\tos.close();\t\t\tsocket.close();\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t\t&#125;&#125;\n\n服务端（Tomcat）\n客户端（浏览器）\n7 UDP发短信：不用连接，需要知道对方地址\n发送消息发送端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;//不需要连接服务器public class Client &#123;\tpublic static void main(String[] args) throws Exception &#123;\t//1.建立一个Socket\tDatagramSocket socket = new DatagramSocket();\t//2.建个包\t\tString msg = &quot;Hello!&quot;;\tInetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\tint port = 9090;\t//数据，数据的长度起始，发送给谁\tDatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);\t//3.发送包\tsocket.send(packet);\t//4.关闭流\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;//还是要等待客户端的连接！public class Server &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//开放端口\t\tDatagramSocket socket = new DatagramSocket(9090);\t\t//接收数据包\t\tbyte[] buffer = new byte[1024];\t\tDatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); //接收\t\tsocket.receive(packet);//阻塞接收\t\tSystem.out.println(packet.getAddress().getHostAddress());\t\tSystem.out.println(new String(packet.getData(),0,packet.getLength()));\t\t//关闭连接\t\tsocket.close();\t&#125;&#125;\n\n循环发送消息发送端\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class Sender &#123;\t/**\t * @param args\t * @throws Exception \t */\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(8888);\t\t//准备数据：控制台读取\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true)&#123;\t\t\t//2.建个包\t\t\t\tString data = reader.readLine();\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t//数据，数据的长度起始，发送给谁\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,6666));\t\t\t//3.发送包\t\t\tsocket.send(packet);\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t\t//4.关闭流\t\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receiver &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(6666);\t\t\t\twhile(true)&#123;\t\t\t//准备接收包裹\t\t\tbyte[] container = new byte[1024];\t\t\tDatagramPacket packet = new DatagramPacket(container,0,container.length);\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t//断开连接 bye\t\t\tbyte[] data = packet.getData();\t\t\tString receiveData = new String(data,0,data.length).trim();\t\t\tSystem.out.println(receiveData);\t\t\tif(receiveData.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n在线咨询：两个人既可以是发送端也可以是接收端（多线程）\n线程TalkSend\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class TalkSend implements Runnable&#123;\tDatagramSocket socket = null;\tBufferedReader reader = null;\t\tprivate int fromPort;\tprivate String toIP;\tprivate int toPort;\t\tpublic TalkSend(int fromPort, String toIP, int toPort) &#123;\t\tsuper();\t\tthis.fromPort = fromPort;\t\tthis.toIP = toIP;\t\tthis.toPort = toPort;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(fromPort);\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\twhile(true)&#123;\t\t\tString data;\t\t\ttry &#123;\t\t\t\tdata = reader.readLine();\t\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));\t\t\t\tsocket.send(packet);\t\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\tsocket.close();\t&#125;&#125;\n\n线程TalkReceive\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class TalkReceive implements Runnable&#123;\tDatagramSocket socket = null;\tprivate int port;\tprivate String msgFrom;\t\tpublic TalkReceive(int port,String msgFrom) &#123;\t\tsuper();\t\tthis.port = port;\t\tthis.msgFrom = msgFrom;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(port);\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\t\twhile(true)&#123;\t\t\ttry &#123;\t\t\t\t//准备接收包裹\t\t\t\tbyte[] container = new byte[1024];\t\t\t\tDatagramPacket packet = new DatagramPacket(container, 0,container.length);\t\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t\t//断开连接 bye\t\t\t\tbyte[] data = packet.getData();\t\t\t\tString receiveData = new String(data, 0, data.length).trim();\t\t\t\tSystem.out.println(msgFrom+&quot;：&quot;+receiveData);\t\t\t\tif (receiveData.equals(&quot;bye&quot;)) &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n老师TalkTeacher\npackage udp;public class TalkTeacher &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tnew Thread(new TalkSend(5555,&quot;localhost&quot;,8888)).start();\t\tnew Thread(new TalkReceive(9999,&quot;学生&quot;)).start();\t&#125;&#125;\n\n学生TalkStudent\npackage udp;public class TalkStudent &#123;\tpublic static void main(String[] args) &#123;\t\t//开启两个线程\t\tnew Thread(new TalkSend(7777,&quot;localhost&quot;,9999)).start();\t\tnew Thread(new TalkReceive(8888,&quot;老师&quot;)).start();\t&#125;&#125;\n\n8 URL统一资源定位符：定位互联网资源\n协议://ip地址：端口/项目名/资源\nurl下载网络资源\npackage url;import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLDown &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.下载地址\t\tURL url = new URL(&quot;http://127.0.0.1:8080/zhg/Confidential.txt&quot;);\t\t//2.连接这个资源HTTP\t\tHttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();\t\tInputStream inputStream = urlConnection.getInputStream();\t\tFileOutputStream fos = new FileOutputStream(&quot;cfile.txt&quot;);\t\tbyte[] buffer = new byte[1024];\t\tint len;\t\twhile((len=inputStream.read(buffer))!=-1)&#123;\t\t\tfos.write(buffer, 0, len); \t\t&#125;\t\tfos.close();\t\tinputStream.close();\t\turlConnection.disconnect();\t&#125;&#125;\n\n","tags":["Java","JavaSE","网络编程","TCP","UDP"]},{"title":"MySQL教程","url":"/2020/10/26/MySQL%E6%95%99%E7%A8%8B/","content":"数据库XX语言：DDL, DML, DQL, DCL\n1 数据库1.1 连接数据库命令行连接\nmysql -uroot -pupdate mysql.user set password = password(&#x27;XXX&#x27;) where user = &#x27;root&#x27; and Host = &#x27;localhost&#x27;; -- 修改用户密码flush privileges; -- 刷新权限-----------------------------------------------show tables;describe 表名; -- 显示表信息exit; -- 退出连接\n\n1.2 操作数据库create database [if not exists] 数据库名 -- 创建drop database [if exists] 数据库名 -- 删除use 数据库名 -- 使用/切换 如果数据库名是关键词，则加上``show databases; -- 查看\n\n\n\n数据类型：\n\n数值：\n\n\n整型：tinyint 1B,smallint 2B, int 4B, bigint 8B\n浮点型：float 4B, double 8B, decimal（字符串形式的浮点数，常用于金融计算）\n\n\n字符串\n\n\nchar 固定大小 0~255,\n\nvarchar 可变 0~65535\n\ntinytext 微型文本 2^8 - 1\n\ntext 文本串 2^16-1\n\n\n\n时间日期\n\n\ndate YYYY- MM- DD\ntime HH: mm: ss \ndatetime YYYY- MM - DD HH: mm: ss\ntimestamp 时间戳，1970.1.1到现在的毫秒数\nyear 年份表示\n\n\nNULL\n\n每个表都必须存在以下五个字段：\n\nid 主键\n`version`乐观锁\nis_delete 伪删除\ngmt_create 创建时间\ngmt_update 修改时间\n\n2 表2.1 创建表CREATE TABLE [IF NOT EXISTS] `student`&#123;\t`id` INT(4) [NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;],\t...\tPRIMARY KEY(`id`)&#125;[ENGINE=INNODB DEFAULT CHARSET=utf-8]\n\n查看创建语句\nSHOW CREATE DATABASE school -- 查看创建数据库语句SHOW CREATE TABLE student -- 查看创建表语句DESC student -- 显示表结构\n\n\n\n数据表的类型\nINNODB（默认）\nMYISAM（早年使用）\n\n\n\n\nMYISAM\nINNODB\n\n\n\n事务支持\n不支持\n支持\n\n\n数据行锁定\n不支持\n支持\n\n\n外键约束\n不支持\n支持\n\n\n全文索引\n支持\n不支持\n\n\n表空间大小\n较小\n较大，约为2倍\n\n\n常规使用的操作：\n\nMYISAM：节约空间，速度较快\nINNODB：安全性高，事务的处理，多表多用户操作\n\n所有的数据库文件都存在data目录下，本质还是文件的存储\nMySQL引擎在物理文件上的区别\n\nINNODB在数据库表中只有*.frm文件，以及上级目录下的ibdata1文件\nMYISAM对应文件\n*.frm - 表结构的定义文件\n*.MYD 数据文件（data）\n*.MYI 索引文件（index）\n\n\n\n2.2 修改删除表\n修改（alter）\n\nALTER TABLE teacher RENAME AS teacher1 -- 修改表名ALTER TABLE teacher1 ADD age INT(11) -- 增加字段-- 修改表的字段ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束ALTER TABLE teacher1 CHANGE age age1 VARCHAR(1) -- 重命名-- 删除表的字段ALTER TABLE teacher1 DROP age1\n\n\n\n\n删除\n\n-- 删除表DROP TABLE [IF EXISTS] teacher1\n\n3 MySQL数据管理3.1 外键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`);\n\n以上操作都是物理外键，数据库级别的外键，不建议使用，避免数据库过多造成困扰\n3.2 DML语言数据库意义：数据存储，数据管理\n添加：insert into 表名[(字段1,2,3...)]values(值1,2,3...)[,(),()...]\n修改：update 表名 set 字段1 = 值1[,字段2 = 值2...] where 条件\n删除：delete from 表名 where 条件\ntruncate 表名：完全清空一个数据库表，表的结构和索引约束不会变！\ntruncate 重新设置，自增列，计数器会归零，不会影响事务\nwhere子句\n=, &gt;, &lt;, &lt;=, &gt;= &lt;&gt;或者!=（不等于）, BETWEEN X AND Y （[X,Y]）\nAND, OR\n注意：没写条件则修改表的所有记录！\n4 DQL查询数据\nDQL:Data QueryLanguage 数据查询语言\n\nselect 字段 [as 别名] from 表 [as 别名]\n函数\nconcat(a,b)\n去重 distinct select distinct 字段 ...\n可以select的表达式：文本值，列，Null，函数，计算表达式，系统变量… \n4.1 模糊查询is null,like, in\n-- 查询姓刘的同学-- like结合 %代表0到任意个字符 _代表一个字符select `StudentNo`,`StudentName` from `student`where StudentName like &#x27;刘%&#x27;--查询1001,1002,1003号学员select `StudentNo`,`StudentName` from `student`where StudentNo in (1001,1002,1003)\n\n4.2 联表查询where 等值查询\njoin on 连接查询\n\n查表思路：\n\n分析需求：分析查询的字段来自哪些表\n确定使用哪种连接查询（7种）\n确定交叉点（判断的条件：student.studentNo = grade.studentNo）\n\n-- 查询缺考的学生select s.StudentNo,studentName,SubjectNo,StudentResultfrom student sleft join result ron s.studentNo = r.studentNowhere StudentResult is null\n\n自连接核心：一张表拆成两张一样的表\nselect a.`categoryName` as &#x27;父栏目&#x27;,b.`categoryName` as &#x27;子栏目&#x27;from `category` as a,`category` as bwhere a.`categoryid` = b.`pid`\n\n4.3 分页和排序limit &amp; order by\n排序：升序 ASC 降序 DESC\n-- 分页：起始值，页面大小limit start(0-),sizelimit 0,5 -- 第一页limit 5,5 -- 第二页...limit (N-1)*pageSize,pageSize --第N页\n\n4.4 嵌套查询select 字段 from 表\nwhere(子查询)\n-- 由里及外select StudentNo,StudentName from student where StudentNo in (    select StudentNo from result where StudentResult&gt;80    and SubjectNo = (        select SubjectNo from `subject` where `SubjectName` = &#x27;高等数学-2&#x27;    ))\n\n5 MySQL函数官网：https://dev.mysql.com/doc/refman/5.7/en/sql-function-reference.html\n5.1 常用函数-- 数学函数select abs(-8) -- 8select ceiling(9.4) -- 10select floor(9.4) -- 9select rand() -- 0~1select sign(-10/0/10) -- -1,0,1-- 字符串函数select char_length(&#x27;xxxxx&#x27;)select concat(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)select insert(&#x27;xxx&#x27;,pos,length,&#x27;yyy&#x27;)select lower(&#x27;XXX&#x27;)select upper(&#x27;xxx&#x27;)select instr(&#x27;xyz&#x27;,&#x27;x&#x27;) -- 返回子串第一次出现的索引select replace(&#x27;abc&#x27;,&#x27;b&#x27;,&#x27;d&#x27;)select substr(&#x27;abcdefg&#x27;,pos,length)select reverse(&#x27;cba&#x27;)-- 查询姓周的同学,替换成邹select replace(studentname,&#x27;周&#x27;&#x27;邹&#x27;） from studentwhere studentname like &#x27;周%&#x27;               -- 时间和日期函数（记住）select current_date()select curdate()select now() -- 当前时间select localtime()select sysdate()-- 系统select system_user()    select user()select version()\n\n5.2 聚合函数select count(字段) from 表 -- 忽略null值，有主键，count(字段)查询效率高select count(*) from 表select count(1) from 表select sum(`StudentResult`) as 总和 from resultselect avg(`StudentResult`) as 平均分 from resultselect max(`StudentResult`) as 最高分 from resultselect min(`StudentResult`) as 最低分 from result-- 分组：查询不同课程的平均分，最高分，最低分select SubjectName,avg(StudentResult) as 平均分,max(StudentResult) as 最高分,min(StudentResult) as 最低分from result rinner join `subject` subon r.`SubjectNo` = sub.`SubjectNo`group by r.SubjectNo -- 分组字段having 平均分&gt;80\n\n5.3 MD5加密不可逆\n破解原理：暴力破解，一个个试\nMD5(pwd)\n将用户传递进来的密码，进行MD5加密，然后比对加密后的值\n6 事务将一组SQL放在一个批次中执行\n原则：ACID（原子性，一致性，隔离性，持久性）\n原子性（Atomicity）\n要么都成功，要么都失败\n一致性（Consistency）\n事务前后的数据完整性要保证一致\n隔离性（Isolation）\n事物之间要相互隔离\n持久性（Durability）\n事务一旦提交则不可逆，被持久化到数据库中\n隔离导致的问题：脏读（读到另一事务未提交的数据）、不可重复读（多次读取结果不同）、幻读（读取别的事务插入的数据）\n-- mysql默认开启事务自动提交set autocommit = 0 -- 关闭set autocommit = 1 -- 开启（默认）-- 手动处理事务set autocommit = 0-- 事务开启start transactioninsert XXXinsert yyy-- 提交commit-- 回滚rollback-- 事务结束set autocommit = 1-- 了解savepoint 保存点名rollback to savepoint 保存点名release savepoint 保存点名\n\n7 索引\nMySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。\n\n7.1 索引的分类\n主键索引（primary key）\n唯一索引（unique key）\n常规索引（key/index）\n全文索引（fulltext）\n\n-- 索引的使用-- 1.在创建表的时候给字段增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息select index from 表名-- 增加一个全文索引alter table 数据库.表名 add fulltext index 索引名(字段名)-- explain分析sql执行的状况explain select * from student --非全文索引explain select * from student where match(studentName) against(&#x27;刘&#x27;)\n\n7.2 测试索引 插入100万条数据测试索引\n--  插入100万条数据delimiter $$ -- 写函数前必须写，标志create function mock_data()returns intbegin\tdeclare num int default 1000000;\tdeclare i int default 0;\twhile i&lt;num do\t\t-- 插入语句\t\tinsert into app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) values(concat(&#x27;用户&#x27;,i),&#x27;178343244@qq.com&#x27;,concat(&#x27;18&#x27;,floor(rand()*(999999999-100000000))+100000000),floor(rand()*2),uuid(),floor(rand()*100));\t\tset i = i+1;\tend while;\t\treturn i;end;select mock_data();-- 测试索引select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.0993 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询99万条数据-- 创建普通索引-- create index 索引名 on 表(字段)-- 索引名：id_表名_字段名create index id_app_user_name on app_user(`name`);select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.001 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询1条数据\n\n总结：索引在小数据量的时候用处不大，但在大数据的时候，区别十分明显\n7.3 索引原则\n索引不是越多越好\n不要对经常变动的数据加索引\n小数据量的表不需要加索引\n索引一般加在经常查询的字段上\n\n\n索引的数据结构\n\nHash类型的索引\nBtree：InnoDB默认\nhttp://blog.codinglabs.org/articles/theory-of-mysql-index.html\n8 权限管理和备份8.1 权限管理SQL命令操作：本质是对用户表mysql.user进行改动\n-- 创建用户create user xxx identified by &#x27;123456&#x27;-- 修改密码set password [for xxx] = password(&#x27;123456&#x27;)-- 重命名rename user xxx to yyy-- 用户授权 库.表grant all privileges on *.* to xxx -- all privileges 除授权权限-- 查询权限show grants for xxxshow grants for root@localhost-- 撤销权限revoke all privileges on *.* from xxx-- 删除用户drop user xxx\n\n8.2 MySQL备份目的：保证数据不丢失，数据转移\n方式：\n\n直接复制物理文件\n在Navicat这种可视化工具中手动导出\n使用命令行导出 mysqldump\n\nmysqldump -hlocalhost -uroot -p123456 school student &gt;D:/a.sql# 导入# 登录的情况下，切换到指定的数据库# source 备份文件source d:/a.sqlmysql -u用户名 -p密码 库名&lt; 备份文件\n\n9 规范数据库设计数据库设计：分析需求→概要设计（E-R图）\n三大范式：\n\n第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。\n1NF保证每一列不可再分\n\n第二范式（2NF）：满足1NF的前提下，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）\n2NF保证每张表只描述一件事物\n\n第三范式（3NF）：满足2NF的前提下，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\n3NF保证表中每一列数据都与主键直接相关\n\n\n规范性和性能的问题：\n关联查询的表不得超过三张\n\n考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要\n在规范性能的问题的时候，需要适当考虑规范性\n故意给某些表增加一些冗余的字段。（多表查询→单表查询）\n故意增加一些计算列（大数据量查询→小数据量查询）\n\n10 JDBCJava操作数据库\n程序通过数据库驱动操作数据库\n需要导入一个数据库驱动包：mysql-connector-java-X.X.XX.jar\npublic class JDBCFirstDemo &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        // 1. 加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 固定写法，自动加载DriverManager.registerDriver(new com.mysql.jdbc,Driver());        // 2. 用户信息和url        String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=true&quot;; // 协议(jdbc:mysql)://主机地址:端口号/数据库名?参数        String username = &quot;root&quot;;        String password = &quot;1031&quot;;        // 3. 连接成功，数据库对象Connection        Connection connection = DriverManager.getConnection(url,username,password);        // 4. Statement执行SQL对象        Statement statement = connection.createStatement();        String sql = &quot;select * from users&quot;;        ResultSet resultSet = statement.executeQuery(sql);        // 5.查看返回结果        while(resultSet.next())&#123;            System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));            System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));            System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));            System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));            System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));            System.out.println(&quot;=================&quot;);        &#125;        // 6. 释放连接，耗资源，用完关掉        resultSet.close();        statement.close();        connection.close();    &#125;&#125;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\nStatement &amp; ResultSet\nConnection connection = DriverManager.getConnection(url,username,password);Statement statement = connection.createStatement();String sql = &quot;select * from users&quot;;ResultSet resultSet = statement.executeQuery(sql); // 查询操作返回ResultSetstatement.execute(); // 执行任何SQLstatement.executeUpdate(); // 更新、插入，删除，返回一个受影响的行数// ResultSetresultSet.getObject(&quot;id&quot;) // 不知道返回类型resultSet.getString(&quot;id&quot;) // 知道返回类型// 遍历指针（光标）resultSet.next() // 移动到下一行resultSet.beforeFirst() // 移动到最前resultSet.afterLast() // 移动到最后resultSet.previous()  // 移动到前一行resultSet.absolute(row) //移动到指定行\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.2 SQL注入\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SQLInjection &#123;    public static void main(String[] args) &#123;        login(&quot;zhg&quot;,&quot;123456&quot;); // 正常登录        login(&quot;&#x27;or&#x27;1=1&quot;,&quot;&#x27;or&#x27;1=1&quot;); //SQL注入：用or拼接SQL语句...    &#125;    // 登录业务    public static void login(String username,String password)&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users where `NAME` =&#x27;&quot;+username+&quot;&#x27; and `PASSWORD` = &#x27;&quot;+password+&quot;&#x27;&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.3 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n10.4 数据库连接池数据库连接→执行→释放，非常浪费系统资源\n池化技术：准备一些预先的资源，过来就连接预先准备好的\n编写连接池，实现接口DataSource\n开源数据源实现\nDBCP\nC3P0\nDruid：阿里\n使用这些数据库连接池之后，我们在项目开发中不需要编写数据库的代码了！\nDBCP，需要jar包：commons-dbcp-1.4, commons-pool-1.6\nC3P0，需要jar包：c3p0-0.9.5.5, mcharge-commons-java-0.2.19\n无论使用什么数据源，本质还是一样的，DataSource接口不会变，方法就不会变\n","tags":["MySQL","JDBC"]},{"title":"注解和反射","url":"/2020/10/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","content":"1 注解简介注解（Annotation）是从JDK5.0开始引入的新技术\n作用：\n\n对程序作出解释（非必须，检查和约束）\n被其他程序读取（编译器）\n\n格式：@注解名（有的还可以添加参数值）\nAnnotation可以附加在package, class, method, field 等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问\n1.1 内置注解@Override：重写父类方法\n@Deprecated：不推荐使用\n@SuppressWarnings(“all”)：抑制警告\n1.2 元注解作用：注解其他注解，为其他annotation提供说明\nJava定义了4个标准的meta-annotation类型：@Target, @Retention, @Document, @Inherited\n\n@Target：描述注解的使用范围\n\n@Retention：描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）\n\n@Documented：说明该注解被包含在javadoc中\n\n@inherited：说明子类可以继承父类中的该注释\n\n\n1.3 自定义注解格式：public @ interface 注解名 {定义内容}\npublic class Test extends Object&#123;\t//注解可以显式赋值，如果没有默认值，则必须赋值\t@MyAnnotation(name = &quot;XXX&quot;,schools = &#123;&quot;门头沟大学&quot;,&quot;家里蹲大学&quot;&#125;)\tpublic void test() &#123;\t\t&#125;&#125;//定义一个注解//Target 描述注解使用范围@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 描述注解生效时间@Retention(value = RetentionPolicy.RUNTIME)//Documented 表示将注解生成在javadoc中@Documented//Inherited 表示子类可以继承父类的注解@Inherited@interface MyAnnotation&#123;\t//注解的参数：参数类型+参数名()\t//假如只有一参数，建议命名为value\tString name() default &quot;&quot;;\tint age() default 0;\tint id() default -1;\tString[] schools() default &#123;&quot;&quot;&#125;;&#125;\n\n2 反射机制静态语言VS动态语言\n\n动态语言：运行时代码可以根据某些条件改变自身结构（C#, JavaScript, Python…）\n\n静态语言：运行时结构不可变（Java, C, C++…）\n\n\nJava不是动态语言，但Java可以利用反射机制获得类似动态语言的特性\n反射机制（Reflection）允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法\n功能：\n\n运行时进行与类（对象）相关的操作\n运行时处理注解\n生成动态代理（AOP）\n\n优点：实现动态创建对象和编译，体现出很大的灵活性\n缺点：对性能有影响。使用反射基本上是一种解释操作，这类操作总是慢于直接执行相同的操作\n主要API：java.lang.Class…\n2.1 Class类Object类中定义了getClass()方法，被所有子类继承\n\n获取Class类的实例：\npublic class Test01 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\tPerson person = new Student();\t\tSystem.out.println(&quot;这个人是：&quot;+person.name);\t\t//一个类在内存中只有一个Class对象\t\t//一个类被加载后，类的整个结构都会被封装在Class对象中\t\t//获取类的Class对象\t\t//方式一：通过对象获得\t\tClass c1 = person.getClass();\t\tSystem.out.println(c1.hashCode());\t\t\t\t//方式二：通过Class.forName获得\t\tClass c2 = Class.forName(&quot;com.zhg.reflection.Student&quot;);\t\tSystem.out.println(c2.hashCode());\t\t\t\t//方式三：通过类名.class获得\t\tClass c3 = Student.class;\t\tSystem.out.println(c3.hashCode());\t\t\t\t//方式四：基本内置类型的包装类都有一个TYPE属性\t\tClass c4 = Integer.TYPE;\t\tSystem.out.println(c4);\t\t\t\t//获得父类类型\t\tClass c5 = c1.getSuperclass();\t\tSystem.out.println(c5);\t&#125;&#125;class Person&#123;\tpublic String name;\tpublic Person() &#123;\t\tsuper();\t&#125;\tpublic Person(String name) &#123;\t\tsuper();\t\tthis.name = name;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Person [name=&quot; + name + &quot;]&quot;;\t&#125;&#125;class Student extends Person&#123;\tpublic Student() &#123;\t\tthis.name = &quot;学生&quot;;\t&#125;&#125;class Teacher extends Person&#123;\tpublic Teacher() &#123;\t\t\t&#125;&#125;\n\n哪些类型可以有Class对象？\nimport java.lang.annotation.ElementType;//所有类型的Class对象public class Test02 &#123;\tpublic static void main(String[] args) &#123;\t\tClass c1 = Object.class; //类\t\tClass c2 = Comparable.class; //接口\t\tClass c3 = String[].class; //一维数组\t\tClass c4 = int[][].class; //二维数组\t\tClass c5 = Override.class; //注解\t\tClass c6 = ElementType.class; //枚举\t\tClass c7 = Integer.class; //基本数据类型包装类\t\tClass c8 = void.class; //void\t\tClass c9 = Class.class; //Class\t\tSystem.out.println(c1); //class java.lang.Object\t\tSystem.out.println(c2); //interface java.lang.Comparable\t\tSystem.out.println(c3); //class [Ljava.lang.String;\t\tSystem.out.println(c4); //class [[I\t\tSystem.out.println(c5); //interface java.lang.Override\t\tSystem.out.println(c6); //class java.lang.annotation.ElementType\t\tSystem.out.println(c7); //class java.lang.Integer\t\tSystem.out.println(c8); //void\t\tSystem.out.println(c9); //class java.lang.Class\t\t//只要元素类型与维度一样，就是同一Class\t\tint[] a = new int[10];\t\tint[] b = new int[100];\t\tSystem.out.println(a.getClass().hashCode());\t\tSystem.out.println(b.getClass().hashCode()); \t&#125;&#125;\n\n2.2 内存分析Java内存：堆（方法区），栈\n堆：存放new的对象和数组，可以被所有线程共享\n方法区：特殊的堆，存放所有class和static变量\n栈：存放基本变量类型，引用类型的变量\n2.2.1 类的加载过程\n加载（Load）：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象\n链接（Link）：将Java类的二进制代码合并到JVM的运行状态（JRE）中的过程\n\n验证：确保加载类信息符合JVM规范，没有安全问题\n准备：为类变量（static）分配内存并设置默认初始值\n解析：虚拟机常量池的符号（常量名）引用替换为直接引用（地址）的过程\n\n初始化（Initialize）：\n\n执行类构造器&lt;clinit&gt;()方法的过程（类构造器是构造类信息的）\n先触发父类的初始化\n保证&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步\n\npublic class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\tA a = new A();\t\tSystem.out.println(A.m);\t\t/*\t\t 1.加载到内存，会产生一个类对应的Class对象\t\t 2.链接，链接结束后 m = 0\t\t 3.初始化\t\t &lt;clinit&gt;()&#123;\t\t \tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\t\tm = 300;\t\t\tm = 100;\t\t&#125;\t\tm = 100;\t\t */\t&#125;&#125;class A&#123;\tstatic &#123;\t\tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\tm = 300;\t&#125;\tstatic int m = 100;\tpublic A() &#123;\t\tSystem.out.println(&quot;A类的无参构造器初始化&quot;);\t&#125;&#125;\n\n2.2.2 类的初始化什么时候会发生类的初始化？\n\n类的主动引用（一定会发生类的初始化）\n虚拟机启动时先初始化main方法所在的类\nnew一个类的对象\n调用类的静态成员和静态方法（除了final常量）\n对类进行反射调用\n当初始化一个类时，先初始化其父类\n\n\n类的被动引用（不会发生类的初始化）\n当访问静态域时，只有真正声明这个于的类才会被初始化\n通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）\n\n\n\n//测试类什么时候会初始化public class Test04 &#123;\tstatic &#123;\t\tSystem.out.println(&quot;main类被加载&quot;);\t&#125;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//1.主动引用\t\t//Son son = new Son();\t\t\t\t//反射也会产生主动引用\t\t//Class.forName(&quot;com.zhg.reflection.Son&quot;);\t\t\t\t//不会产生类的引用的方法\t\t//System.out.println(Son.b);\t\t//Son[] array = new Son[5];\t\tSystem.out.println(Son.M);\t&#125;&#125;class Father&#123;\tstatic int b = 2;\tstatic &#123;\t\tSystem.out.println(&quot;父类被加载&quot;);\t&#125;&#125;class Son extends Father&#123;\tstatic &#123;\t\tSystem.out.println(&quot;子类被加载&quot;);\t\tm = 300;\t&#125;\t\tstatic int m = 100;\tstatic final int M = 1;&#125;\n\n2.2.3 类加载器作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成这个类的Class对象，作为方法区中类数据的访问入口\n\n类缓存：类加载器加载类时，先按要求查找类，如果某个类被加载到类加载器中，它将维持加载（缓存）一段时间。\n类加载器的类型：\n\n引导类加载器（负责Java核心库）\n扩展类加载器\n系统类加载器\n\npublic class Test05 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//获取系统类的加载器\t\tClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\t\tSystem.out.println(systemClassLoader);\t\t\t\t//获取系统类加载器的父类加载器--&gt;扩展类加载器\t\tClassLoader parent = systemClassLoader.getParent();\t\tSystem.out.println(parent);\t\t\t\t//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）\t\tClassLoader parent1 = parent.getParent();\t\tSystem.out.println(parent1);\t\t\t\t//测试当前类是哪个加载器加载的（系统类加载器）\t\tClassLoader classLoader = Class.forName(&quot;com.zhg.reflection.Test05&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//测试JDK内置的类是谁加载的（根加载器）\t\tclassLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//如何获得系统类加载器可以加载的路径\t\tSystem.out.println(System.getProperty(&quot;java.class.path&quot;));\t\t\t\t//双亲委派机制\t\t\t//java.lang.String--&gt;多重检测，保证安全性\t&#125;&#125;\n\n2.2.4 获取类的结构通过反射获取运行时类的完整结构\nField, Method, Constructor, Superclass, Interface, Annotation…\n//获取类的信息public class Test06 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, NoSuchMethodException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\tPerson person = new Person();\t\tc1 = person.getClass();\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的名字\t\tSystem.out.println(c1.getName()); //获得包名 + 类名\t\tSystem.out.println(c1.getSimpleName()); //获得类名\t\t\t//获得类的属性\t\tField[] fields = c1.getFields(); //只能找到public属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\tfields = c1.getDeclaredFields(); //找到全部的属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\t\t//获取指定属性的值\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\tSystem.out.println(name);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的方法\t\tMethod[] methods = c1.getMethods(); //获得本类及父类的所有public方法\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;正常的：&quot;+method);\t\t&#125;\t\tmethods = c1.getDeclaredMethods(); //获得本类的所有方法（包括private方法）\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;getDeclaredMethods：&quot;+method);\t\t&#125;\t\t//获得指定方法\t\tMethod getName = c1.getMethod(&quot;getName&quot;, null);\t\tMethod setName = c1.getMethod(&quot;setName&quot;, String.class);\t\tSystem.out.println(getName);\t\tSystem.out.println(setName);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得指定的构造器\t\tConstructor[] constructors = c1.getConstructors(); //获得public构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(constructor);\t\t&#125;\t\tconstructors = c1.getDeclaredConstructors(); //获得全部构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(&quot;#&quot;+constructor);\t\t&#125;\t\t//获得指定的构造器\t\tConstructor declaredConstructor = c1.getDeclaredConstructor(String.class);\t\tSystem.out.println(&quot;指定：&quot;+declaredConstructor);\t&#125;&#125;\n\n2.3 实际应用2.3.1 动态创建对象动态创建类的对象：调用Class对象的newInstance()方法\n\n类必须有一个无参构造器\n类的构造器的访问权限需要足够\n\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//通过反射动态的创建对象public class Test07 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;\t\t//构造Class对象\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\t\t\t//构造一个对象\t\tPerson person = (Person) c1.newInstance();  //本质是调用了类的无参构造器\t\tSystem.out.println(person);\t\t\t\t//通过构造器创建对象\t\tConstructor constructor = c1.getDeclaredConstructor(String.class);\t\tPerson person2 = (Person)constructor.newInstance(&quot;XX&quot;);\t\tSystem.out.println(person2);\t\t\t\t//通过反射调用普通方法\t\tPerson person3 = (Person) c1.newInstance();\t\tMethod setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);\t\t//invoke(对象，方法参数)\t\tsetName.invoke(person3, &quot;XXX&quot;);\t\tSystem.out.println(person3.name);\t\tSystem.out.println(&quot;=================&quot;);\t\t//通过反射操作属性\t\tPerson person4 = (Person) c1.newInstance();\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\t//不能直接操作私有属性，需要关闭程序的安全检测，属性或者方法的setAccessible(true)\t\tname.setAccessible(true); //\t\tname.set(person4, &quot;XXXX&quot;);\t\tSystem.out.println(person4.getName());\t\t\t&#125;&#125;\n\nsetAccessible参数值为true则指示反射的对象在使用时取消Java语言访问检查→提高了反射的效率；使得原本无法访问的私有成员也可以访问\n性能分析（调用对象的方法）：普通方式 VS 反射方式 VS 关闭检测后反射\nimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class Test08 &#123;\t//普通方式调用\tpublic static void test01() &#123;\t\tPerson person = new Person();\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tperson.getName();\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;普通方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t//反射方式调用\tpublic static void test02() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t\t//反射方式调用 关闭检测\tpublic static void test03() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\tgetName.setAccessible(true);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;关闭检测后反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\tpublic static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\ttest01();\t\ttest02();\t\ttest03();\t&#125;&#125;\n\n2.3.2 获取泛型信息Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，一旦编译完成，所有和泛型有关的类型全部擦除\n通过反射操作类型：\nimport java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;//通过反射获取泛型public class Test09 &#123;\tpublic void test01(Map&lt;String,Person&gt; map,List&lt;Person&gt; list)&#123;\t\tSystem.out.println(&quot;test01&quot;);\t&#125;\tpublic Map&lt;String,Person&gt;test02()&#123;\t\tSystem.out.println(&quot;test02&quot;);\t\treturn null;\t&#125;\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException &#123;\t\tMethod method = Test09.class.getMethod(&quot;test01&quot;, Map.class,List.class);\t\tType[] genericParameterTypes = method.getGenericParameterTypes();\t\tfor(Type genericParameterType:genericParameterTypes) &#123;\t\t\tSystem.out.println(&quot;#&quot;+genericParameterType);\t\t\tif(genericParameterType instanceof ParameterizedType) &#123;\t\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericParameterType).getActualTypeArguments();\t\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tmethod = Test09.class.getMethod(&quot;test02&quot;, null);\t\tType genericReturnType = method.getGenericReturnType();\t\tif(genericReturnType instanceof ParameterizedType) &#123;\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericReturnType).getActualTypeArguments();\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n2.3.3 获取注解信息ORM(Object Relationship Mapping)：对象关系映射\n\n类和表结构对应\n属性和字段对应\n对象和记录对应\n\n利用注解和反射完成类和表结构的映射关系：\nimport java.lang.annotation.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;//练习反射操作注解public class Test10 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.StudentX&quot;);\t\t\t\t//通过反射获得注解\t\tAnnotation[] annotations = c1.getAnnotations();\t\tfor(Annotation annotation:annotations) &#123;\t\t\tSystem.out.println(annotation);\t\t&#125;\t\t\t\t//获取注解的value值\t\tTableX table = (TableX)c1.getAnnotation(TableX.class);\t\tString value = table.value();\t\tSystem.out.println(value);\t\t\t\t//获取类指定的注解\t\tField f = c1.getDeclaredField(&quot;name&quot;);\t\tFieldX annotation = f.getAnnotation(FieldX.class);\t\tSystem.out.println(annotation.columnName());\t\tSystem.out.println(annotation.type());\t\tSystem.out.println(annotation.length());\t&#125;&#125;@TableX(&quot;db_student&quot;)class StudentX&#123;\t\t@FieldX(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)\tprivate int id;\t@FieldX(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)\tprivate int age;\t@FieldX(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)\tprivate String name;\tpublic StudentX() &#123;\t\tsuper();\t&#125;\tpublic StudentX(int id, int age, String name) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.age = age;\t\tthis.name = name;\t&#125;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\tpublic int getAge() &#123;\t\treturn age;\t&#125;\tpublic void setAge(int age) &#123;\t\tthis.age = age;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Student [id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;\t&#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableX&#123;\tString value();&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldX&#123;\tString columnName();\tString type();\tint length();&#125;","tags":["Java","JavaSE","注解","反射"]},{"title":"多线程详解","url":"/2020/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/","content":"1.1 线程简介多任务→多线程\n进程 VS 线程\n\n程序是指令和数据的有序集合，是一个静态的概念。\n进程是程序的一次执行过程,是一个动态的概念。\n进程中至少有一个线程，线程是CPU调度和执行的基本单位。\n\n1.2 线程创建三种创建方式：\n\n继承Thread类\n实现Runnable接口\n实现Callable接口（了解）\n\n1.2.1 继承Thread类创建线程方式一：继承Thread类→重写run()方法→调用start()启动线程\n//注意，线程开启不一定立即执行，由CPU调度执行public class TestThread1 extends Thread&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//main线程，主线程\t\tTestThread1 testThread1 = new TestThread1();\t\t//调用start()方法开启线程，交替执行\t\ttestThread1.start();\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;\t&#125;\n\n实现多线程同步下载图片\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;public class TestThread2 extends Thread&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2 t1 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2 t2 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2 t3 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\tt1.start();\t\tt2.start();\t\tt3.start();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n1.2.2 实现Runnable接口创建线程方式二：实现Runnable接口→重写run()方法→调用start()启动线程（需要Runnable接口实现类）\npublic class TestThread3 implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//创建runnable接口的实现类对象\t\tTestThread3 testThread3 = new TestThread3();\t\t\t\t//创建线程对象，通过线程对象来开启线程，代理//\t\tThread thread = new Thread(testThread3);//\t\tthread.start();\t\tnew Thread(testThread3).start();\t\t\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;&#125;\n\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;//练习Thread，实现多线程同步下载图片public class TestThread2n implements Runnable&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2n(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader1 webDownloader = new WebDownloader1();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2n t1 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2n t2 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2n t3 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\tnew Thread(t1).start();\t\tnew Thread(t2).start();\t\tnew Thread(t3).start();\t&#125;&#125;//下载器class WebDownloader1&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n小结：\n\n继承Thread类\n子类继承Thread类具备多线程能力\n启动线程：子类对象.start()\n不建议使用：避免OOP单继承局限性\n\n\n实现Runnable接口\n实现接口Runnable具有多线程能力\n启动线程：传入目标对象+Thread对象.start()\n推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用\n\n\n\n多个线程同时操作一个对象，买火车票的例子\n//问题：多个线程操作同一个资源，线程不安全，数据紊乱public class TestThread4 implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\ttry &#123;\t\t\t\tThread.sleep(10);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread4 ticket = new TestThread4();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\n案例：龟兔赛跑\n//模拟龟兔赛跑public class Race implements Runnable&#123;\t//胜利者\tprivate static String winner; \tpublic static void main(String[] args) &#123;\t\tRace race = new Race();\t\tnew Thread(race,&quot;兔子&quot;).start();\t\tnew Thread(race,&quot;乌龟&quot;).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tfor(int i = 0; i &lt;= 100;i++) &#123;\t\t\t//模拟兔子休息\t\t\tif(&quot;兔子&quot;.equals(Thread.currentThread().getName() )&amp;&amp; i%10==5) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(56);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(&quot;乌龟&quot;.equals(Thread.currentThread().getName() )) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(5);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\t//判断比赛是否结束\t\t\tboolean flag = gameOver(i);\t\t\t//如果比赛结束了，就停止程序\t\t\tif(flag) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;);\t\t&#125;\t\t&#125;\t//判断是否完成比赛\tprivate boolean gameOver(int steps) &#123;\t\t//判断是否有胜利者\t\tif(winner!=null) &#123;\t\t\treturn true;\t\t&#125;else &#123;\t\t\tif(steps==100) &#123;\t\t\t\twinner = Thread.currentThread().getName();\t\t\t\tSystem.out.println(&quot;winner is &quot;+winner);\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t\treturn false;\t&#125;&#125;\n\n1.2.3 实现Callable接口创建线程方式三（了解即可）：实现Callable接口（需要返回值类型）→重写call()方法（需要抛出异常）→创建目标对象→创建关闭服务\nimport java.io.File;import java.net.URL;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import org.apache.commons.io.FileUtils;//创建方式三：实现Callable接口/* * Callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 */public class TestCallable implements Callable&lt;Boolean&gt;&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestCallable(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic Boolean call() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t\treturn true;\t&#125;\tpublic static void main(String[] args) throws Exception &#123;\t\tTestCallable t1 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestCallable t2 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestCallable t3 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\t//创建执行服务 \t\tExecutorService ser = Executors.newFixedThreadPool(3);\t\t\t\t//提交执行\t\tFuture&lt;Boolean&gt; r1 = ser.submit(t1);\t\tFuture&lt;Boolean&gt; r2 = ser.submit(t2);\t\tFuture&lt;Boolean&gt; r3 = ser.submit(t3);\t\t\t\t//获取结果\t\tboolean rs1 = r1.get();\t\tboolean rs2 = r2.get();\t\tboolean rs3 = r3.get();\t\t\t\tSystem.out.println(rs1);\t\tSystem.out.println(rs2);\t\tSystem.out.println(rs3);\t\t//关闭服务\t\tser.shutdown();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\nLamda表达式语法：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }\n作用：简化代码，避免匿名内部类定义过多\nFunction Interface（函数式接口）：只包含唯一一个抽象方法\n可以通过lamda表达式来创建函数式接口的对象\n推导lambda表达式\npublic class TestLambda1 &#123;\t//3.静态内部类\tstatic class Like2 implements ILike&#123;\t\t@Override\t\tpublic void lambda() &#123;\t\t\tSystem.out.println(&quot;I like lambda2&quot;);\t\t&#125;\t\t\t&#125;\t\tpublic static void main(String[] args) &#123;\t\tILike like = new Like();\t\tlike.lambda();\t\tlike = new Like2();\t\tlike.lambda();\t\t\t\t//4.局部内部类\t\tclass Like3 implements ILike&#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda3&quot;);\t\t\t&#125;\t\t\t\t&#125;\t\tlike = new Like3();\t\tlike.lambda();\t\t\t\t//5.匿名内部类，没有类的名称，必须借助接口或者父类\t\tlike = new ILike() &#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda4&quot;);\t\t\t&#125;\t\t&#125;;\t\tlike.lambda();\t\t\t\t//6.用lambda简化\t\tlike = () -&gt; &#123;\t\t\tSystem.out.println(&quot;I like lambda5&quot;);\t\t&#125;;\t\tlike.lambda();\t&#125;&#125;//1.定义一个函数式接口interface ILike&#123;\tvoid lambda();&#125;//2.实现类class Like implements ILike&#123;\t@Override\tpublic void lambda() &#123;\t\tSystem.out.println(&quot;I like lambda&quot;);\t&#125;\t&#125;\n\n简化lambda表达式：1.省略参数类型 2.省略括号\n静态代理示例（婚庆公司）\npublic class StaticProxy &#123;\tpublic static void main(String[] args) &#123;        You you = new You(); \t\tyou.HappyMarry();        //\t\tnew Thread(()-&gt;System.out.println(&quot;我爱你&quot;)).start();//\t\tnew WeddingCompany(new You()).HappyMarry();\t\t//代理\t\tWeddingCompany weddingCompany = new WeddingCompany(new You());\t\tweddingCompany.HappyMarry();\t&#125;&#125;interface Marry&#123;\tvoid HappyMarry();&#125;//真实角色class You implements Marry&#123;\t@Override\tpublic void HappyMarry() &#123;\t\tSystem.out.println(&quot;结婚了，开心&quot;);\t\t\t&#125;&#125;//代理角色class WeddingCompany implements Marry&#123;\tprivate Marry target;\t\tpublic WeddingCompany(Marry target) &#123;\t\tthis.target = target;\t&#125;\t@Override\tpublic void HappyMarry() &#123;\t\tbefore();\t\tthis.target.HappyMarry(); //真实对象\t\tafter();\t&#125;\tprivate void after() &#123;\t\tSystem.out.println(&quot;结婚之后，收尾款&quot;);\t\t\t&#125;\tprivate void before() &#123;\t\tSystem.out.println(&quot;结婚之前，布置现场&quot;);\t\t\t&#125;\t&#125;\n\n静态代理模式总结：\n\n真实对象和代理对象都要实现同一个接口\n代理对象代理真实对象\n\n好处：\n\n代理对象可以做很多真实对象做不了的事情\n真实对象专注做自己的事情\n\n1.3 线程状态1.3.1 五大状态\n\n1.3.2 线程停止\n不推荐使用JDK提供的stop()、destroy()方法【已废弃】\n推荐线程自己停下来（建议使用一标志位进行终止变量）\n\n//测试stop//1.建议线程正常停止--&gt;利用次数，不建议死循环//2.建议使用标志位//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法public class TestStop implements Runnable&#123;\tprivate boolean flag = true;\tpublic static void main(String[] args) &#123;\t\tTestStop testStop = new TestStop();\t\tnew Thread(testStop).start();\t\tfor(int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t\tif(i == 900) &#123;\t\t\t\t//调用stop()方法切换标志位，让线程停止\t\t\t\ttestStop.stop();\t\t\t\tSystem.out.println(&quot;线程停止&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tint i = 0;\t\twhile(flag) &#123;\t\t\tSystem.out.println(&quot;run ... Thread&quot;+i++);\t\t&#125;\t\t&#125;\tpublic void stop() &#123;\t\tthis.flag = false;\t&#125;&#125;\n\n1.3.3 线程休眠sleep(毫秒)→就绪\n每个对象有个锁，sleep不会释放锁\n//模拟网络延时：放大问题的发生性public class TestSleep implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t//模拟延时\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestSleep ticket = new TestSleep();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\nimport java.text.SimpleDateFormat;import java.util.Date;public class TestSleep2&#123;\tpublic static void main(String[] args) &#123;\t\t//模拟倒计时\t\ttry &#123;\t\t\ttenDown();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t//打印当前系统时间\t\tDate startTime = new Date(System.currentTimeMillis());\t\twhile(true) &#123;\t\t\ttry &#123;\t\t\t\tSystem.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\t\t\t\tThread.sleep(1000);\t\t\t\tstartTime = new Date(System.currentTimeMillis()); //更新当前时间\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t&#125;\tpublic static void tenDown() throws InterruptedException &#123;\t\tint num = 3;\t\twhile(true) &#123;\t\t\tThread.sleep(1000);\t\t\tSystem.out.println(num--);\t\t\tif(num&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t&#125;&#125;\n\n1.3.4 线程礼让Yield让当前线程暂停但不阻塞，转为就绪状态\n礼让不一定成功\n//测试礼让线程，礼让不一定成功public class TestYield &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tMyYield myYield = new MyYield();\t\tnew Thread(myYield,&quot;a&quot;).start();\t\tnew Thread(myYield,&quot;b&quot;).start();\t&#125;&#125;class MyYield implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);\t\tThread.yield(); //礼让\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);\t&#125;\t&#125;\n\n1.3.5 线程强制执行Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞（可以看作是插队）\n//测试join方法public class TestJoin implements Runnable&#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\t//启动我们的线程\t\tTestJoin testJoin = new TestJoin();\t\tThread thread = new Thread(testJoin);\t\tthread.start();\t\tfor (int i = 0; i &lt; 500; i++) &#123;\t\t\tif(i==200) &#123;\t\t\t\tthread.join();//插队\t\t\t&#125;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;线程vip来了&quot;+i);\t\t&#125;\t\t&#125;&#125;\n\n1.3.6 线程优先级优先高的不一定先执行，默认是5\n//测试线程的优先级public class TestPriority&#123;\tpublic static void main(String[] args) &#123;\t\t//主线程默认优先级\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\tMyPriority myPriority = new MyPriority();\t\tThread t1 = new Thread(myPriority);\t\tThread t2 = new Thread(myPriority);\t\tThread t3 = new Thread(myPriority);\t\tThread t4 = new Thread(myPriority);\t\t//先设置优先级，再启动\t\tt1.start();\t\tt2.setPriority(1);\t\tt2.start();\t\tt3.setPriority(4);\t\tt3.start();\t\tt4.setPriority(Thread.MAX_PRIORITY); //MAX_PRIORITY=10\t\tt4.start();\t&#125;&#125;class MyPriority implements Runnable&#123;\t@Override\tpublic void run() &#123;\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\t\t&#125;\t&#125;\n\n1.3.7 守护（daemon）线程线程分为用户线程和守护线程\n虚拟机必须确保用户线程（如，后台记录操作日志，监控内存，垃圾回收等待）执行完毕，但不用等待守护线程执行完毕\n//测试守护线程//上帝守护你public class TestDaemon &#123;\tpublic static void main(String[] args) &#123;\t\tGod god = new God();\t\tYou you = new You();\t\tThread thread = new Thread(god);\t\tthread.setDaemon(true); //默认是false表示是用户线程，正常的线程都是用户线程\t\tthread.start(); //守护线程启动\t\tnew Thread(you).start(); //用户线程启动\t&#125;&#125;//上帝class God implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tSystem.out.println(&quot;上帝保佑着你&quot;);\t\t&#125;\t&#125;\t&#125;//你class You implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 36500; i++) &#123;\t\t\tSystem.out.println(&quot;开心活着&quot;);\t\t&#125;\t\tSystem.out.println(&quot;====Good bye!====&quot;);\t&#125;\t&#125;\n\n1.4 线程同步多个线程操作同一资源（并发）\n线程同步是一种等待机制，多个需要同时访问同一对象的线程进图该对象的等待池形成队列，等待前面线程使用完毕，下一线程再使用\n形成条件：队列+锁（synchronized）\n1.4.1 同步方法及同步块三个不安全案例1.不安全的买票\n//不安全的买票(线程不安全）public class UnsafeBuyTicket &#123;\tpublic static void main(String[] args) &#123;\t\tBuyTicket station = new BuyTicket();\t\tnew Thread(station,&quot;苦逼的我&quot;).start();\t\tnew Thread(station,&quot;牛逼的你们&quot;).start();\t\tnew Thread(station,&quot;可恶的黄牛党&quot;).start();\t&#125;\t&#125;class BuyTicket implements Runnable&#123;\t\t//票\tprivate int ticketNum = 10;\tboolean flag = true; //外部停止方式\t@Override\tpublic void run() &#123;\t\t//买票\t\twhile(flag) &#123;\t\t\tbuy();\t\t&#125;\t&#125;\tprivate void buy() &#123;\t\tif(ticketNum&lt;=0) &#123;\t\t\tflag = false;\t\t\treturn;\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//买票        System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--);\t&#125;\t&#125;\n\n2.不安全的取钱\n//不安全的取钱（两个人）public class UnsafeBank &#123;\tpublic static void main(String[] args) &#123;\t\tAccount account = new Account(100,&quot;结婚基金&quot;);\t\tDrawing you = new Drawing(account,50,&quot;你&quot;);\t\tDrawing GF = new Drawing(account,100,&quot;女朋友&quot;);\t\tyou.start();\t\tGF.start();\t&#125;&#125;//账户class Account&#123;\tint money; //余额\tString name; //卡名\tpublic Account(int money, String name) &#123;\t\tsuper();\t\tthis.money = money;\t\tthis.name = name;\t&#125;&#125;//银行：模拟取款class Drawing extends Thread&#123;\tAccount account;\t//取了多少钱\tint drawingMoney;\t//现在手里有多少钱\tint nowMoney;\tpublic Drawing(Account account,int drawingMoney,String name) &#123;\t\tsuper(name);\t\tthis.account = account;\t\tthis.drawingMoney = drawingMoney;\t&#125;\t//取钱\t@Override\tpublic void run() &#123;\t\t//判断有没有钱\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\treturn;\t\t&#125;\t\t//放大问题的发生性\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//卡内余额 = 余额 - 取的钱\t\taccount.money = account.money - drawingMoney;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;&#125;\n\n3.不安全的集合\n//线程不安全的集合//添加到同一位置被覆盖public class UnsafeList &#123;\tpublic static void main(String[] args) &#123;\t\tList&lt;String&gt; list = new ArrayList&lt;String&gt;();\t\tfor (int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\nsynchronized同步方法：public synchronized void method(int args) { }\nsynchronized方法控制对“对象”的访问，每个对象对象对应一把锁，每个synchronized方法都必须获得调用该方法的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行\n同步块：synchronized(Obj) { }\nObj称为同步监视器\n\nObj可以是任何对象，但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this\n\npublic void run() &#123;\t\t//锁的对象就是变化的量，需要增删改的对象\t\tsynchronized (account) &#123;\t\t\t//判断有没有钱\t\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\t\treturn;\t\t\t&#125;\t\t\t//放大问题的发生性\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t//卡内余额 = 余额 - 取的钱\t\t\taccount.money = account.money - drawingMoney;\t\t&#125;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;\n\nCopyOnWriteArrayListJUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。Callable接口也在JUC中。\nimport java.util.concurrent.CopyOnWriteArrayList;//测试JUC安全类型的集合public class TestJUC &#123;\tpublic static void main(String[] args) &#123;\t\tCopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();\t\tfor(int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(3000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\n1.4.2 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“的问题\n//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class DeadLock &#123;\tpublic static void main(String[] args) &#123;\t\tMakeup g1 = new Makeup(0,&quot;灰姑娘&quot;);\t\tMakeup g2 = new Makeup(1,&quot;白雪公主&quot;);\t\tg1.start();\t\tg2.start();\t&#125;&#125;//口红class Lipstick&#123;\t&#125;//镜子class Mirror&#123;\t&#125;class Makeup extends Thread&#123;\t//需要的资源只有一份，用static来保证只有一份\tstatic Lipstick lipstick = new Lipstick();\tstatic Mirror mirror = new Mirror();\t\tint choice; //选择\tString girlName; //选择化妆品的人\t\tMakeup(int choice,String girlName)&#123;\t\tthis.choice = choice;\t\tthis.girlName = girlName;\t&#125;\t@Override\tpublic void run() &#123;\t\t//化妆\t\ttry &#123;\t\t\tmakeup();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t\t//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t\t\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t\t\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n锁中锁（多个对象互相嵌套的锁）使多个线程互相抱着对方需要的资源，然后形成僵持\n解决方法：锁分开写，不要同时占有多个资源\n//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t&#125;\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125;\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t&#125;\n\n产生死锁的四个必要条件：\n\n互斥条件\n请求与保持条件\n不剥夺条件\n循环等待条件\n\n1.4.3 Lock锁从JDK 5.0开始，Java提供了更强大的线程同步机制——显式定义同步锁对象来实现同步。同步锁使用Lock对象充当，Lock锁也包含在JUC内\nReentrantLock（可重入锁）类实现了Lock，可以显式加锁、释放锁\n使用格式：\nLock lock=new ReentrantLock();lock.lock();try&#123;    //处理任务&#125;catch(Exception ex)&#123;     &#125;finally&#123;    lock.unlock();   //释放锁&#125;\n\n测试Lock类（买票）：\nimport java.util.concurrent.locks.ReentrantLock;//测试Lock类public class TestLock &#123;\tpublic static void main(String[] args) &#123;\t\tTestLock2 testLock2 = new TestLock2(); \t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t&#125;&#125;class TestLock2 implements Runnable&#123;\tint ticketNum = 10;\t\t//定义Lock锁\tprivate final ReentrantLock lock = new ReentrantLock();\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tlock.lock();//加锁\t\t\ttry &#123;\t\t\t\tif(ticketNum &gt; 0) &#123;\t\t\t\t\ttry &#123;\t\t\t\t\t\tThread.sleep(1000);\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t\t\t\tSystem.out.println(ticketNum--);\t\t\t\t&#125;else &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;finally &#123;\t\t\t\t//解锁\t\t\t\tlock.unlock();\t\t\t&#125;\t\t\t\t&#125;\t&#125;&#125;\n\nsynchronized与Lock对比\n\nLock是显式锁（手动开启和关闭锁），synchronized是隐式锁，自动释放\n使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）\n\n1.4.4 线程通信线程通信方法：\n\n注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常\n生产者消费者问题解决方法：\n\n利用缓冲区解决：管程法\n//测试生产者消费者模型--&gt;利用缓冲区解决：管程法//生产者，消费者，产品，缓冲区public class TestPC &#123;\tpublic static void main(String[] args) &#123;\t\tSynContainer container = new SynContainer();\t\t\t\tnew Producer(container).start();\t\tnew Consumer(container).start();\t&#125;&#125;//生产者class Producer extends Thread&#123;\tSynContainer container;\tpublic Producer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t\t//生产\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\tcontainer.push(new Chicken(i));\t\t\tSystem.out.println(&quot;生产了第&quot;+i+&quot;只鸡&quot;);\t\t&#125;\t&#125;&#125;//消费者class Consumer extends Thread&#123;\tSynContainer container;\tpublic Consumer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t//消费\t\t@Override\t\tpublic void run() &#123;\t\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\t\tSystem.out.println(&quot;消费了第&quot;+container.pop().id+&quot;只鸡&quot;);\t\t\t&#125;\t\t\t\t&#125;&#125;//产品class Chicken&#123;\tint id; //产品编号\tpublic Chicken(int id) &#123;\t\tthis.id = id;\t&#125;\t&#125;//缓冲区class SynContainer&#123;\t//需要一个容器大小\tChicken[] chickens = new Chicken[10];\t//容器计数器\tint count = 0;\t\t//生产者放入产品\tpublic synchronized void push(Chicken chicken) &#123;\t\t//如果容器满了，就需要等待消费者消费\t\tif(count == chickens.length) &#123;\t\t\t//通知消费者消费，生产等待\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果没有满，我们就需要丢入产品\t\tchickens[count] = chicken;\t\tcount++;\t\t\t\t//可以通知消费者消费了\t\tthis.notifyAll();\t&#125;\t//消费者消费产品\tpublic synchronized Chicken pop() &#123;\t\t//判断能否消费\t\tif(count==0) &#123;\t\t\t//等待生产者生产\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果可以消费\t\tcount--;\t\tChicken chicken = chickens[count];\t\t\t//吃完了，通知生产者生产\t\tthis.notifyAll();\t\treturn chicken;\t\t\t&#125;&#125;\n\n利用标志位解决：信号灯法\npackage com.zhg.thread;//测试生产者消费者模型2--&gt;利用标志位解决：信号灯法public class TestPC2 &#123;\tpublic static void main(String[] args) &#123;\t\tTV tv = new TV();\t\tnew Player(tv).start();\t\tnew Watcher(tv).start();\t&#125;&#125;//生产者--&gt;演员class Player extends Thread&#123;\tTV tv;\tpublic Player(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\tif(i%2==0) &#123;\t\t\t\tthis.tv.play(&quot;快乐大本营&quot;);\t\t\t&#125;else &#123;\t\t\t\tthis.tv.play(&quot;广告&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;//消费者--&gt;观众class Watcher extends Thread&#123;\tTV tv;\tpublic Watcher(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\ttv.watch();\t\t&#125;\t&#125;&#125;//产品--&gt;节目class TV&#123;\t\t//演员表演，观众等待 T\t//观众观看，演员等待 F\tString voice;//表演的节目\tboolean flag = true;\t\t//表演\tpublic synchronized void play(String voice) &#123;\t\t\t\tif(!flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(&quot;演员表演了：&quot;+voice);\t\t//通知观众观看\t\tthis.notifyAll(); //通知唤醒\t\tthis.voice = voice;\t\tthis.flag = !this.flag;\t&#125;\t\t//观看\tpublic synchronized void watch() &#123;\t\tif(flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;观众观看了：&quot;+voice);\t\t//通知演员表演\t\tthis.notifyAll();\t\tthis.flag = !this.flag;\t&#125;&#125;\n\n\n\n线程池背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。\n好处：\n\n提高响应速度\n降低资源消耗\n便于线程管理\n\nJDK 5.0起提供了线程池相关API：ExecutorService和Executors\n\nExecutorService：真正的线程池接口。\n\nExecutor：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。\n\n\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//测试线程池public class TestPool &#123;\tpublic static void main(String[] args) &#123;\t\t//1.创建服务，创建线程池\t\t//newFixedThreadPool 参数为线程池大小\t\tExecutorService service = Executors.newFixedThreadPool(10);\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\t//2.关闭连接\t\tservice.shutdown();\t&#125;&#125;class MyThread implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tSystem.out.println(Thread.currentThread().getName());\t\t\t&#125;&#125;","tags":["Java","JavaSE","多线程"]}]
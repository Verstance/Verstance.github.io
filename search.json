[{"title":"LeetCode 463.岛屿的长度","url":"/2020/10/30/LeetCode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E9%95%BF%E5%BA%A6/","content":"题目描述：\n给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n示例：\n输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]\n输出: 16\n解释: 它的周长是下面图片中的 16 个黄色的边：\n\n我的解法（迭代）：\nint[] dx = &#123;-1,1,0,0&#125;;int[] dy = &#123;0,0,-1,1&#125;;// 统计每块陆地四周有几块陆地，贡献的周长=4-四周的陆地块数int around1(int[][] grid,int x,int y)&#123;    int num = 0;    for(int i = 0; i &lt; 4; i++)&#123;        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &lt; 0 || xx &gt;= grid.length || yy &lt; 0 || yy &gt;= grid[0].length) continue;        if(grid[xx][yy] == 1) num++;    &#125;    return num;&#125;public int islandPerimeter(int[][] grid) &#123;    int sum = 0;    for(int i = 0; i &lt; grid.length; i++)&#123;        for(int j = 0; j &lt; grid[0].length; j++)&#123;            if(grid[i][j] == 1)&#123;                sum += 4 - around1(grid,i,j);            &#125;        &#125;    &#125;    return sum;&#125;\n\n\n\n用DFS求岛屿周长：\n思路：岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量。（每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1）\n\npublic int islandPerimeter(int[][] grid) &#123;    for (int r = 0; r &lt; grid.length; r++) &#123;        for (int c = 0; c &lt; grid[0].length; c++) &#123;            if (grid[r][c] == 1) &#123;                // 题目限制只有一个岛屿，计算一个即可                return dfs(grid, r, c);            &#125;        &#125;    &#125;    return 0;&#125;int dfs(int[][] grid, int r, int c) &#123;    if (!(0 &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length)) &#123;        return 1;    &#125;    if (grid[r][c] == 0) &#123;        return 1;    &#125;    if (grid[r][c] != 1) &#123;        return 0;    &#125;    grid[r][c] = 2; // 用2标记已遍历过的岛屿    return dfs(grid, r - 1, c)        + dfs(grid, r + 1, c)        + dfs(grid, r, c - 1)        + dfs(grid, r, c + 1);&#125;\n\n链接：https://leetcode-cn.com/problems/island-perimeter\n","tags":["算法","LeetCode","DFS"]},{"title":"Hello World","url":"/2020/10/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"JavaScript入门","url":"/2020/10/26/JavaScript%E5%85%A5%E9%97%A8/","content":"1 基础语法比较运算符===  //等于（类型不同，值一样，也会判断为true）=== //绝对等于（类型一样，值一样，结果才为true）\n\n这是一个JS的缺陷，坚持不要使用 == 比较\n须知：\n\nNaN===NaN返回false，NaN与所有数值都不相等，包括自己\n只能通过isNaN(NaN)来判断这个数是否是NaN\n\n尽量避免使用浮点数进行运算，存在精度问题\nMath.abs(1/3-(1-2/3))&lt;0.000000001\n\n严格检查模式全局变量 i = 1;\n局部变量 var i = 1; let i = 1;（ES6建议使用let）\n严格检查模式\n‘use strict’; 严格检查模式，预防JavaScript的随意性导致产生的一些问题\n字符串多行字符串：\n`XXX\nXXX`\n模板字符串\n`hello,${变量}`\nstr.length str[0] str.toUpperCase() str.toLowerCase()\nstr.subsring(X,Y)返回str[X,Y)\n数组var arr = [1,2,3,4,5,&#x27;hello&#x27;,null,true];new Array(1,2,3,4,5,&#x27;hello&#x27;,null,true);\n\n取数组下标，如果越界(arr[8]),就会提示undifined\n假如给数组的长度arr.length赋值，数组大小就会发生变化\nindexOf：通过元素获得下标索引\nslice()截取Array的一部分，类似字符串中的substring\narr.push(),arr.pop() // 尾部\narr.unshift(),shift() // 头部 \narr.sort()\narr.reverse()\narr.concat() // 不会改变原数组\narr.join(‘-‘) // 连接符 打印\narr.fill(X)\n对象\n每个属性之间使用逗号隔开，最后一个不需要添加\n\nvar person = &#123;    name:&quot;XXX&quot;,    age:18,    tags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;...&#x27;]&#125;\n\n对象赋值：person.name = “XXX”\n取对象的值：person.name\n使用一个不存在的对象属性，不会报错！undefined\n动态删除，添加对象的属性：delete person.name person.XXX=XXX\nJavaScript中所有键都是字符串，值是任意对象\n判断属性值是否在这个对象中！’XXX’ in XXX\n判断一个属性是否是这个对象自身拥有的 hasOwnProperty()\n流程控制arr.forEach(function (value)&#123;  // ES5.1\tconsole.log(value)&#125;)for(var i in arr)&#123;   // i为数组下标&#125;for(var e of arr)&#123;   // e为数组元素&#125;\n\nMap和SetES6的新特性\nvar map = new Map([[&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90]]);var name = map.get(&#x27;tom&#x27;);map.set(&#x27;admin&#x27;,123); // 新增map.delete(&#x27;XXX&#x27;);console.log(name);var set = new Set(1,1,1,3); // 去重set.add(x);set.delete(x);set.has(x);\n\niterater ES6新特性\n函数function abs(x)&#123;\t//定义方式一    //...&#125;var abs = function(x)&#123;\t//定义方式二    //...&#125;\n\n如果没有执行return，函数执行完也会返回结果：undefined\nJavaScript可以传任意参数，也可以不传参数\nvar abs = function(x)&#123;    //手动抛出异常    if(typeof x != &#x27;number&#x27;)&#123;        throw &#x27;Not a Number&#x27;;    &#125;    if(x &gt;= 0)&#123;        return x;    &#125;else&#123;        return -x;    &#125;&#125;\n\narguments参数表示函数传入的所有参数，是一个数组\nrest剩余参数，只能写在最后面，必须用…表示\nfunction aaa(a,b,...rest)&#123;    consloe(&quot;a-&gt;&quot;+a);    consloe(&quot;b-&gt;&quot;+b);    consloe(&quot;rest-&gt;&quot;+rest);&#125;\n\n全局对象 window所有全局变量都绑定在全局对象window上的\nwindow.x（全局变量）\nwindows.alert(window.x)\nvar old_alert = window.alert;//old_alert(x);window.alert = function()&#123;    &#125;;window.alert(123); //失效//恢复window.alert = old_alert;window.alert(456);\n\n全局变量→冲突\n//唯一全局变量var App = &#123;&#125;;//定义全局变量App.name = &#x27;XXX&#x27;;App.add = function (a,b) &#123;    return a + b;&#125;\n\n把自己代码全部放入自己定义的唯一命名空间中，降低全局命名冲突的问题（JQuery）\nES6建议使用let关键字去定义局部作用域的变量（解决局部作用域冲突的问题），使用const定义常量const PI = &#39;3.14&#39;\n方法var XXX = &#123;\tname:&#x27;xxx&#x27;,\tbirth:2020,\t//方法\tage:function()&#123;        var now = new Date().getFullYear();        return now - this.birth;    &#125;&#125;XXX.nameXXX.age()\n\napply在js中可以控制this指向，通过 apply() 方法，能够编写用于不同对象的方法。函数.apply(对象,参数列表)this指向apply的对象\n2 内部对象\n标准对象\n\nnumber, string, boolean, object\ntypeof NaN&quot;number&quot;typeof []&quot;object&quot;typeof undefined&quot;undefined&quot;\n\n2.1 Datevar now = new Date();now.getFullYear(); // 年now.getMonth(); //月（0-11）now.getDate(); //日now.getDay(); //星期几now.getHours(); //时now.getMinutes(); //分now.getSeconds(); //秒now.getTime(); //时间戳 1970.1.1 00:00 - msconsole.log(new Date(113224222)) //时间戳转为时间//转换为字符串now.toLocaleString()now.toGMTString()\n\n2.2 JSON\nJSON(JavaScript Object Notation, JS 对象表示法) 是一种轻量级的数据交换格式。\n\n特点：简洁，清晰的层次结构；易于人阅读和编写，同时也易于机器解析和生成，有效提升网络传输效率\n在JavaScript中一切皆对象，任何JS支持的类型都可以用JSON来表示\n格式：\n\n对象：{}\n数组：[]\n键值对：key:value\n\nJSON字符串和JS对象的转化\nvar user = &#123;    name: &quot;XXX&quot;,    age: 3,    sex: &#x27;男&#x27;&#125;//对象转化为JSON对象var jsonUser = JSON.stringify()//json字符串转化为对象,参数为json字符串var obj = JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;XXX&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;)\n\n2.3 Ajax\n原生的js写法 xhr异步请求\n\nJQuery封装好的方法 $(“#name”).ajax(“”)\n\naxios 请求\n\n\n3 面向对象编程原型：子类（对象）.__proto__ = 父类（原型对象）; //子类的原型是父类\n随意指向\nclass关键字是在ES6引入的\nclass Student&#123;    constructor(name)&#123;        this.name = name;    &#125;    hello()&#123;        alert(&#x27;hello&#x27;)    &#125;&#125;class pupil extends Student&#123;    constructor(name,grade)&#123;        super(name);        this.grade = grade;    &#125;    myGrade()&#123;        alert(&#x27;我是一名小学生&#x27;)    &#125;&#125;var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);xiaoming.hello();\n\n\n\n原型链：_proto_\\\n\n4 操作BOM对象（重点）\nBOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。\n\n浏览器：\n内核：IE， Chrome, Safari, FireFox\n三方：QQ，360\n4.1 windowwindow代表浏览器窗口\nwindow.alert(1)// 调整浏览器窗口大小window.innerHeightwindow.innerWidthwindow.outerHeightwindow.innerWidth\n\n4.2 navigatornavigator封装了浏览器的信息\nnavigator.appNamenavigator.appVersionnavigator.userAgentnavigator.platform\n\n一般不使用，因为会被人为修改，不建议用这些属性来判断浏览器版本\n4.3 screenscreen代表屏幕尺寸\nscreen.widthscreen.height\n\n4.4 location（重要）location代表当前页面的URL信息\nhost: &quot;www.bilibili.com&quot;hostname: &quot;www.bilibili.com&quot;href: &quot;https://www.bilibili.com/video/BV1JJ41177di?p=19&quot;protocol: &quot;https:&quot;reload: ƒ reload() // 刷新页面// 设置新的地址location.assign(&#x27;https://...&#x27;)\n\n4.5 documentdocument代表当前的页面（document.），HTML DOM文档树\n//获取具体的文档树节点&lt;dl id=&quot;app&quot;&gt;    &lt;dt&gt;Java&lt;/dt&gt;    &lt;dd&gt;JavaSE&lt;/dd&gt;&lt;/dl&gt;&lt;script&gt;\tvar dl = document.getElementById(&#x27;app&#x27;);&lt;/script&gt;\n\n获取cookie\ndocument.cookie&quot;finger=158939783; _uuid=C56A5201-E5AB-30A7-6A3D-33573CFAEC4B75115infoc; buvid3=2DE4F72B-D52C-4628-B6F6-D25A79D4DFBD155818infoc; sid=jsr4r70q; im_notify_type_775959=0; LIVE_BUVID=AUTO6215819975268326; LIVE_PLAYER_TYPE=2; DedeUserID=775959; DedeUserID__ckMd5=5a93072db131a757; bili_jct=e4c30825e9523f0d624509aa21012a7e; rpdid=|(J~RllJRmlY0J&#x27;ulm)RkRm)l; blackside_state=1; CURRENT_FNVAL=80; bp_t_offset_775959=434460479141307658; Hm_lvt_8a6e55dbd2870f0f5bc9194cddf32a02=1600696828; CURRENT_QUALITY=80; bp_video_offset_775959=438421933640865406; finger=158939783; PVID=3&quot;\n\n劫持cookie原理\nwww.taobao.com\n&lt;script src=&quot;aa.js&quot;&gt;&lt;/script&gt;&lt;!-- 恶意人员：获取你的cookie上传到他的服务器 --&gt;\n\n服务器可以设置：httpOnly（安全）\n4.6 historyhistory代表浏览器的历史记录（不建议使用）\nhistory.back()history.forward()\n\n5 操作DOM对象（重点）\n文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本,更新其内容、结构和www文档的风格(目前,HTML和XML文档是通过说明部分定义的)。\n\n浏览器网页就是一个DOM树形结构，要操作一个DOM节点，就必须先获得这个DOM节点\n5.1 获得DOM节点标签选择器：document.getElementsByTagName(&#39;h1&#39;)（返回数组）\nid选择器：documen.getElementById(&#39;id&#39;)\nclass选择器：document.getElementByClassName(&#39;class&#39;)（返回数组）\n获得子节点：Node.children\n5.2 更新DOM节点修改文本值：\nNode.innerText = &#39;xxx&#39;\nNode.innerHTML = &#39;xxx&#39;（超文本）\n设置样式：\nNode.style.color/fontSize/... = &#39;xxx&#39;（驼峰命名）\n5.3 删除DOM节点先获取父节点，再通过父节点删除自己\nNode.parentElement.removeChild(Node)（只能通过id选择器选择节点删除）\n注意：删除节点过程中，父节点的children是动态变化的\n5.4 插入DOM节点获得的DOM节点若为空节点，可以通过innerText增加元素\n追加节点：Node1.append(Node2)\n创建新节点：document.createElement(&#39;p&#39;)\n设置节点属性：Node = setAttribute(&#39;属性名&#39;,&#39;属性值&#39;)\n插入节点：Node.insertBefore(newItem,existingItem);\n6 操作表单（验证）表单的目的：提交信息\n获得要提交的信息\ninput_text.valueboy_radio.checked //boolean\n\nMD5加密密码\n表单绑定提交事件\nonsubmit= 绑定一个提交检测的函数，返回布尔值（return false：不提交表单）\n7 jQuery公式：$(selector).action()\n$(&#x27;#id&#x27;).click(function()&#123;    //...&#125;)//当网页元素加载完毕之后，响应事件$(document).ready(function()&#123;    //...&#125;)//↑简写,获取坐标$(function()&#123;    $(&#x27;#divMove&#x27;).mousemove(function(e)&#123;        $(&#x27;mouseMove&#x27;).text(&#x27;x:&#x27;+e.pageX+&#x27;y:&#x27;+e.pageY)    &#125;)&#125;)\n\n文档工具站：https://jquery.cuishifeng.cn/\n操作DOM：\n$(&#x27;#test-ul li[name=python]&#x27;).css(&#123;&quot;color&quot;,&quot;red&quot;&#125;)$(&#x27;#test-ul li[name=python]&#x27;).show()/hide()$(window).width\n\n\n\nLayUI 弹窗组件\nElementUI 样式好看\n","tags":["JavaScript","JQuery","前端"]},{"title":"网络编程入门","url":"/2020/10/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/","content":"1 概述计算机网络：地理位置不同 多台计算机 连接 通信 共享\n网络编程的目的：数据交换，通信\n如何实现多台主机之间的数据通信：\n\n准确定位网络上的一台主机以及该主机的某个资源（IP：Port）\n传输数据？\n\nJavaWeb：网页编程  B/S\n网络编程：TCP/IP      C/S\n2 网络通信的要素实现网络通信需要知道通信双方地址（ip、端口号）\n规则：网络通信协议\nTCP/IP参考模型：\n\n网络编程专门针对传输层（TCP/IP）\n3 IPip地址：InetAddress\n\n唯一定位一台网络上的计算机\n127.0.0.1：本机localhost\nip地址的分类：\nipv4/ipv6\nipv4：10.164.120.176    4个字节组成，0~255，42亿中30亿在北美，亚洲4亿，2011年就用尽\nipv6：fe80::a1a2:85b0:e7d9:58f1%7  128位，8个无符号整数  \n\n\n公网（互联网） 私网（局域网）\nABCD类地址\n192.168.xx.xx 专门给组织内部使用的\n\n\n\n\n域名→记忆IP问题！\n\n4 端口端口表示计算机上的一个程序的进程：\n\n不同进程有不同的端口号！（不能冲突）用来区分进程！\n\n范围：0~65535\n\nTCP，UDP：65535*2 单个协议下，端口号不能冲突\n\n端口分类\n\n公有端口 0~1023\n\nHTTP：80\nHTTPS：443\nFTP：21\nTelnet：23\n\n\n程序注册端口：1024~49151 分配给用户或者程序\n\nTomcat：8080\nMySQL：3306\nOracle：1521\n\n\n动态/私有端口：49152~65535\nnetstat -ano #查看所有端口netstat -ano|findstr &quot;端口号&quot; #查看指定的端口tasklist|findstr &quot;端口号&quot; #查看指定端口的进程\n\n\n\n\n\n5 通信协议协议：约定\n网络通信协议：速率，传输码率，代码结构，传输控制……\nTCP/IP协议簇\n重要：\n\nTCP：传输控制协议\nUDP：用户数据报协议\n\nTCP vs UDP\n打电话~TCP\n\n连接，稳定\n\n三次握手，四次挥手\n最少需要三次，保证稳定连接！A:你瞅啥？B:瞅你咋地？A:干一场！A:我要走了B:你真的要走了吗？B:你真的真的要走了吗？A:我真的真的要走了！\n\n\n\n客户端、服务端\n\n传输完成，释放连接，效率低\n\n\n发短信~UDP\n\n不连接，不稳定\n客户端、服务器：没有明确的界限\n不管有没有准备好，都可以发给你\n导弹\nDDoS：洪水攻击（饱和攻击）\n\n6 TCP聊天客户端\n\n通过Socket连接服务器\n发送消息\n\npackage tcp;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\tInetAddress serverIP = null;\t\tint port = 0;\t\tSocket socket = null;\t\tOutputStream os = null;\t\ttry &#123;\t\t\t//1.得知服务器地址\t\t\tserverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\tport = 9999;\t\t\t//2.创建一个socket连接\t\t\tsocket = new Socket(serverIP,port);\t\t\t//3.发送消息\t\t\tos = socket.getOutputStream();\t\t\tos.write(&quot;你好&quot;.getBytes());\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\tif(os!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;            if(socket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tsocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t&#125;&#125;\n\n服务器端\n\n建立服务端口\n通过accept等待用户连接\n接收用户消息\n\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tServerSocket serverSocket = null;\t\tSocket socket = null;\t\tInputStream is = null;\t\tByteArrayOutputStream baos = null;\t\t\t\ttry &#123;\t\t\t//1.有地址\t\t\tserverSocket = new ServerSocket(9999);\t\t\t//2.等待客户端连接\t\t\tsocket = serverSocket.accept();\t\t\t//3.读取客户端的消息\t\t\tis = socket.getInputStream();\t\t\t//管道流\t\t\tbaos = new ByteArrayOutputStream();\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tbaos.write(buffer,0,len);\t\t\t&#125;\t\t\tSystem.out.println(baos.toString());\t\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\t//关闭资源\t\t\tif(baos!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tbaos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(is!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(serverSocket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tserverSocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\n\n\n\n文件上传服务器端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import org.omg.CORBA_2_3.portable.OutputStream;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\t\ttry &#123;\t\t\t//1.创建服务\t\t\tServerSocket serverSocket = new ServerSocket(9999);\t\t\t//2.监听客户端连接\t\t\tSocket socket = serverSocket.accept();\t\t\t//3.读取输入流\t\t\tInputStream is = socket.getInputStream();\t\t\t//4.文件输出\t\t\tFileOutputStream fos = new FileOutputStream(new File(&quot;receive.jpg&quot;));\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tfos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tis.close();\t\t\tfos.close();\t\t\tsocket.close();\t\t\tserverSocket.close();\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\n客户端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\t//1.创建一个socket连接\t\t\tSocket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);\t\t\t//2.创建一个输出流\t\t\tOutputStream os = socket.getOutputStream();\t\t\t//3.读取文件\t\t\tFileInputStream fis = new FileInputStream(new File(&quot;dog.jpg&quot;));\t\t\t//4.写出文件\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=fis.read(buffer))!=-1)&#123;\t\t\t\tos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tfis.close();\t\t\tos.close();\t\t\tsocket.close();\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t\t&#125;&#125;\n\n服务端（Tomcat）\n客户端（浏览器）\n7 UDP发短信：不用连接，需要知道对方地址\n发送消息发送端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;//不需要连接服务器public class Client &#123;\tpublic static void main(String[] args) throws Exception &#123;\t//1.建立一个Socket\tDatagramSocket socket = new DatagramSocket();\t//2.建个包\t\tString msg = &quot;Hello!&quot;;\tInetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\tint port = 9090;\t//数据，数据的长度起始，发送给谁\tDatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);\t//3.发送包\tsocket.send(packet);\t//4.关闭流\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;//还是要等待客户端的连接！public class Server &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//开放端口\t\tDatagramSocket socket = new DatagramSocket(9090);\t\t//接收数据包\t\tbyte[] buffer = new byte[1024];\t\tDatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); //接收\t\tsocket.receive(packet);//阻塞接收\t\tSystem.out.println(packet.getAddress().getHostAddress());\t\tSystem.out.println(new String(packet.getData(),0,packet.getLength()));\t\t//关闭连接\t\tsocket.close();\t&#125;&#125;\n\n循环发送消息发送端\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class Sender &#123;\t/**\t * @param args\t * @throws Exception \t */\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(8888);\t\t//准备数据：控制台读取\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true)&#123;\t\t\t//2.建个包\t\t\t\tString data = reader.readLine();\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t//数据，数据的长度起始，发送给谁\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,6666));\t\t\t//3.发送包\t\t\tsocket.send(packet);\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t\t//4.关闭流\t\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receiver &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(6666);\t\t\t\twhile(true)&#123;\t\t\t//准备接收包裹\t\t\tbyte[] container = new byte[1024];\t\t\tDatagramPacket packet = new DatagramPacket(container,0,container.length);\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t//断开连接 bye\t\t\tbyte[] data = packet.getData();\t\t\tString receiveData = new String(data,0,data.length).trim();\t\t\tSystem.out.println(receiveData);\t\t\tif(receiveData.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n在线咨询：两个人既可以是发送端也可以是接收端（多线程）\n线程TalkSend\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class TalkSend implements Runnable&#123;\tDatagramSocket socket = null;\tBufferedReader reader = null;\t\tprivate int fromPort;\tprivate String toIP;\tprivate int toPort;\t\tpublic TalkSend(int fromPort, String toIP, int toPort) &#123;\t\tsuper();\t\tthis.fromPort = fromPort;\t\tthis.toIP = toIP;\t\tthis.toPort = toPort;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(fromPort);\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\twhile(true)&#123;\t\t\tString data;\t\t\ttry &#123;\t\t\t\tdata = reader.readLine();\t\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));\t\t\t\tsocket.send(packet);\t\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\tsocket.close();\t&#125;&#125;\n\n线程TalkReceive\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class TalkReceive implements Runnable&#123;\tDatagramSocket socket = null;\tprivate int port;\tprivate String msgFrom;\t\tpublic TalkReceive(int port,String msgFrom) &#123;\t\tsuper();\t\tthis.port = port;\t\tthis.msgFrom = msgFrom;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(port);\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\t\twhile(true)&#123;\t\t\ttry &#123;\t\t\t\t//准备接收包裹\t\t\t\tbyte[] container = new byte[1024];\t\t\t\tDatagramPacket packet = new DatagramPacket(container, 0,container.length);\t\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t\t//断开连接 bye\t\t\t\tbyte[] data = packet.getData();\t\t\t\tString receiveData = new String(data, 0, data.length).trim();\t\t\t\tSystem.out.println(msgFrom+&quot;：&quot;+receiveData);\t\t\t\tif (receiveData.equals(&quot;bye&quot;)) &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n老师TalkTeacher\npackage udp;public class TalkTeacher &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tnew Thread(new TalkSend(5555,&quot;localhost&quot;,8888)).start();\t\tnew Thread(new TalkReceive(9999,&quot;学生&quot;)).start();\t&#125;&#125;\n\n学生TalkStudent\npackage udp;public class TalkStudent &#123;\tpublic static void main(String[] args) &#123;\t\t//开启两个线程\t\tnew Thread(new TalkSend(7777,&quot;localhost&quot;,9999)).start();\t\tnew Thread(new TalkReceive(8888,&quot;老师&quot;)).start();\t&#125;&#125;\n\n8 URL统一资源定位符：定位互联网资源\n协议://ip地址：端口/项目名/资源\nurl下载网络资源\npackage url;import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLDown &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.下载地址\t\tURL url = new URL(&quot;http://127.0.0.1:8080/zhg/Confidential.txt&quot;);\t\t//2.连接这个资源HTTP\t\tHttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();\t\tInputStream inputStream = urlConnection.getInputStream();\t\tFileOutputStream fos = new FileOutputStream(&quot;cfile.txt&quot;);\t\tbyte[] buffer = new byte[1024];\t\tint len;\t\twhile((len=inputStream.read(buffer))!=-1)&#123;\t\t\tfos.write(buffer, 0, len); \t\t&#125;\t\tfos.close();\t\tinputStream.close();\t\turlConnection.disconnect();\t&#125;&#125;\n\n","tags":["Java","JavaSE","网络编程","TCP","UDP"]},{"title":"MySQL教程","url":"/2020/10/26/MySQL%E6%95%99%E7%A8%8B/","content":"数据库XX语言：DDL, DML, DQL, DCL\n1 数据库1.1 连接数据库命令行连接\nmysql -uroot -pupdate mysql.user set password = password(&#x27;XXX&#x27;) where user = &#x27;root&#x27; and Host = &#x27;localhost&#x27;; -- 修改用户密码flush privileges; -- 刷新权限-----------------------------------------------show tables;describe 表名; -- 显示表信息exit; -- 退出连接\n\n1.2 操作数据库create database [if not exists] 数据库名 -- 创建drop database [if exists] 数据库名 -- 删除use 数据库名 -- 使用/切换 如果数据库名是关键词，则加上``show databases; -- 查看\n\n\n\n数据类型：\n\n数值：\n\n\n整型：tinyint 1B,smallint 2B, int 4B, bigint 8B\n浮点型：float 4B, double 8B, decimal（字符串形式的浮点数，常用于金融计算）\n\n\n字符串\n\n\nchar 固定大小 0~255,\n\nvarchar 可变 0~65535\n\ntinytext 微型文本 2^8 - 1\n\ntext 文本串 2^16-1\n\n\n\n时间日期\n\n\ndate YYYY- MM- DD\ntime HH: mm: ss \ndatetime YYYY- MM - DD HH: mm: ss\ntimestamp 时间戳，1970.1.1到现在的毫秒数\nyear 年份表示\n\n\nNULL\n\n每个表都必须存在以下五个字段：\n\nid 主键\n`version`乐观锁\nis_delete 伪删除\ngmt_create 创建时间\ngmt_update 修改时间\n\n2 表2.1 创建表CREATE TABLE [IF NOT EXISTS] `student`&#123;\t`id` INT(4) [NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;],\t...\tPRIMARY KEY(`id`)&#125;[ENGINE=INNODB DEFAULT CHARSET=utf-8]\n\n查看创建语句\nSHOW CREATE DATABASE school -- 查看创建数据库语句SHOW CREATE TABLE student -- 查看创建表语句DESC student -- 显示表结构\n\n\n\n数据表的类型\nINNODB（默认）\nMYISAM（早年使用）\n\n\n\n\nMYISAM\nINNODB\n\n\n\n事务支持\n不支持\n支持\n\n\n数据行锁定\n不支持\n支持\n\n\n外键约束\n不支持\n支持\n\n\n全文索引\n支持\n不支持\n\n\n表空间大小\n较小\n较大，约为2倍\n\n\n常规使用的操作：\n\nMYISAM：节约空间，速度较快\nINNODB：安全性高，事务的处理，多表多用户操作\n\n所有的数据库文件都存在data目录下，本质还是文件的存储\nMySQL引擎在物理文件上的区别\n\nINNODB在数据库表中只有*.frm文件，以及上级目录下的ibdata1文件\nMYISAM对应文件\n*.frm - 表结构的定义文件\n*.MYD 数据文件（data）\n*.MYI 索引文件（index）\n\n\n\n2.2 修改删除表\n修改（alter）\n\nALTER TABLE teacher RENAME AS teacher1 -- 修改表名ALTER TABLE teacher1 ADD age INT(11) -- 增加字段-- 修改表的字段ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束ALTER TABLE teacher1 CHANGE age age1 VARCHAR(1) -- 重命名-- 删除表的字段ALTER TABLE teacher1 DROP age1\n\n\n\n\n删除\n\n-- 删除表DROP TABLE [IF EXISTS] teacher1\n\n3 MySQL数据管理3.1 外键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`);\n\n以上操作都是物理外键，数据库级别的外键，不建议使用，避免数据库过多造成困扰\n3.2 DML语言数据库意义：数据存储，数据管理\n添加：insert into 表名[(字段1,2,3...)]values(值1,2,3...)[,(),()...]\n修改：update 表名 set 字段1 = 值1[,字段2 = 值2...] where 条件\n删除：delete from 表名 where 条件\ntruncate 表名：完全清空一个数据库表，表的结构和索引约束不会变！\ntruncate 重新设置，自增列，计数器会归零，不会影响事务\nwhere子句\n=, &gt;, &lt;, &lt;=, &gt;= &lt;&gt;或者!=（不等于）, BETWEEN X AND Y （[X,Y]）\nAND, OR\n注意：没写条件则修改表的所有记录！\n4 DQL查询数据\nDQL:Data QueryLanguage 数据查询语言\n\nselect 字段 [as 别名] from 表 [as 别名]\n函数\nconcat(a,b)\n去重 distinct select distinct 字段 ...\n可以select的表达式：文本值，列，Null，函数，计算表达式，系统变量… \n4.1 模糊查询is null,like, in\n-- 查询姓刘的同学-- like结合 %代表0到任意个字符 _代表一个字符select `StudentNo`,`StudentName` from `student`where StudentName like &#x27;刘%&#x27;--查询1001,1002,1003号学员select `StudentNo`,`StudentName` from `student`where StudentNo in (1001,1002,1003)\n\n4.2 联表查询where 等值查询\njoin on 连接查询\n\n查表思路：\n\n分析需求：分析查询的字段来自哪些表\n确定使用哪种连接查询（7种）\n确定交叉点（判断的条件：student.studentNo = grade.studentNo）\n\n-- 查询缺考的学生select s.StudentNo,studentName,SubjectNo,StudentResultfrom student sleft join result ron s.studentNo = r.studentNowhere StudentResult is null\n\n自连接核心：一张表拆成两张一样的表\nselect a.`categoryName` as &#x27;父栏目&#x27;,b.`categoryName` as &#x27;子栏目&#x27;from `category` as a,`category` as bwhere a.`categoryid` = b.`pid`\n\n4.3 分页和排序limit &amp; order by\n排序：升序 ASC 降序 DESC\n-- 分页：起始值，页面大小limit start(0-),sizelimit 0,5 -- 第一页limit 5,5 -- 第二页...limit (N-1)*pageSize,pageSize --第N页\n\n4.4 嵌套查询select 字段 from 表\nwhere(子查询)\n-- 由里及外select StudentNo,StudentName from student where StudentNo in (    select StudentNo from result where StudentResult&gt;80    and SubjectNo = (        select SubjectNo from `subject` where `SubjectName` = &#x27;高等数学-2&#x27;    ))\n\n5 MySQL函数官网：https://dev.mysql.com/doc/refman/5.7/en/sql-function-reference.html\n5.1 常用函数-- 数学函数select abs(-8) -- 8select ceiling(9.4) -- 10select floor(9.4) -- 9select rand() -- 0~1select sign(-10/0/10) -- -1,0,1-- 字符串函数select char_length(&#x27;xxxxx&#x27;)select concat(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)select insert(&#x27;xxx&#x27;,pos,length,&#x27;yyy&#x27;)select lower(&#x27;XXX&#x27;)select upper(&#x27;xxx&#x27;)select instr(&#x27;xyz&#x27;,&#x27;x&#x27;) -- 返回子串第一次出现的索引select replace(&#x27;abc&#x27;,&#x27;b&#x27;,&#x27;d&#x27;)select substr(&#x27;abcdefg&#x27;,pos,length)select reverse(&#x27;cba&#x27;)-- 查询姓周的同学,替换成邹select replace(studentname,&#x27;周&#x27;&#x27;邹&#x27;） from studentwhere studentname like &#x27;周%&#x27;               -- 时间和日期函数（记住）select current_date()select curdate()select now() -- 当前时间select localtime()select sysdate()-- 系统select system_user()    select user()select version()\n\n5.2 聚合函数select count(字段) from 表 -- 忽略null值，有主键，count(字段)查询效率高select count(*) from 表select count(1) from 表select sum(`StudentResult`) as 总和 from resultselect avg(`StudentResult`) as 平均分 from resultselect max(`StudentResult`) as 最高分 from resultselect min(`StudentResult`) as 最低分 from result-- 分组：查询不同课程的平均分，最高分，最低分select SubjectName,avg(StudentResult) as 平均分,max(StudentResult) as 最高分,min(StudentResult) as 最低分from result rinner join `subject` subon r.`SubjectNo` = sub.`SubjectNo`group by r.SubjectNo -- 分组字段having 平均分&gt;80\n\n5.3 MD5加密不可逆\n破解原理：暴力破解，一个个试\nMD5(pwd)\n将用户传递进来的密码，进行MD5加密，然后比对加密后的值\n6 事务将一组SQL放在一个批次中执行\n原则：ACID（原子性，一致性，隔离性，持久性）\n原子性（Atomicity）\n要么都成功，要么都失败\n一致性（Consistency）\n事务前后的数据完整性要保证一致\n隔离性（Isolation）\n事物之间要相互隔离\n持久性（Durability）\n事务一旦提交则不可逆，被持久化到数据库中\n隔离导致的问题：脏读（读到另一事务未提交的数据）、不可重复读（多次读取结果不同）、幻读（读取别的事务插入的数据）\n-- mysql默认开启事务自动提交set autocommit = 0 -- 关闭set autocommit = 1 -- 开启（默认）-- 手动处理事务set autocommit = 0-- 事务开启start transactioninsert XXXinsert yyy-- 提交commit-- 回滚rollback-- 事务结束set autocommit = 1-- 了解savepoint 保存点名rollback to savepoint 保存点名release savepoint 保存点名\n\n7 索引\nMySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。\n\n7.1 索引的分类\n主键索引（primary key）\n唯一索引（unique key）\n常规索引（key/index）\n全文索引（fulltext）\n\n-- 索引的使用-- 1.在创建表的时候给字段增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息select index from 表名-- 增加一个全文索引alter table 数据库.表名 add fulltext index 索引名(字段名)-- explain分析sql执行的状况explain select * from student --非全文索引explain select * from student where match(studentName) against(&#x27;刘&#x27;)\n\n7.2 测试索引 插入100万条数据测试索引\n--  插入100万条数据delimiter $$ -- 写函数前必须写，标志create function mock_data()returns intbegin\tdeclare num int default 1000000;\tdeclare i int default 0;\twhile i&lt;num do\t\t-- 插入语句\t\tinsert into app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) values(concat(&#x27;用户&#x27;,i),&#x27;178343244@qq.com&#x27;,concat(&#x27;18&#x27;,floor(rand()*(999999999-100000000))+100000000),floor(rand()*2),uuid(),floor(rand()*100));\t\tset i = i+1;\tend while;\t\treturn i;end;select mock_data();-- 测试索引select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.0993 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询99万条数据-- 创建普通索引-- create index 索引名 on 表(字段)-- 索引名：id_表名_字段名create index id_app_user_name on app_user(`name`);select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.001 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询1条数据\n\n总结：索引在小数据量的时候用处不大，但在大数据的时候，区别十分明显\n7.3 索引原则\n索引不是越多越好\n不要对经常变动的数据加索引\n小数据量的表不需要加索引\n索引一般加在经常查询的字段上\n\n\n索引的数据结构\n\nHash类型的索引\nBtree：InnoDB默认\nhttp://blog.codinglabs.org/articles/theory-of-mysql-index.html\n8 权限管理和备份8.1 权限管理SQL命令操作：本质是对用户表mysql.user进行改动\n-- 创建用户create user xxx identified by &#x27;123456&#x27;-- 修改密码set password [for xxx] = password(&#x27;123456&#x27;)-- 重命名rename user xxx to yyy-- 用户授权 库.表grant all privileges on *.* to xxx -- all privileges 除授权权限-- 查询权限show grants for xxxshow grants for root@localhost-- 撤销权限revoke all privileges on *.* from xxx-- 删除用户drop user xxx\n\n8.2 MySQL备份目的：保证数据不丢失，数据转移\n方式：\n\n直接复制物理文件\n在Navicat这种可视化工具中手动导出\n使用命令行导出 mysqldump\n\nmysqldump -hlocalhost -uroot -p123456 school student &gt;D:/a.sql# 导入# 登录的情况下，切换到指定的数据库# source 备份文件source d:/a.sqlmysql -u用户名 -p密码 库名&lt; 备份文件\n\n9 规范数据库设计数据库设计：分析需求→概要设计（E-R图）\n三大范式：\n\n第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。\n1NF保证每一列不可再分\n\n第二范式（2NF）：满足1NF的前提下，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）\n2NF保证每张表只描述一件事物\n\n第三范式（3NF）：满足2NF的前提下，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\n3NF保证表中每一列数据都与主键直接相关\n\n\n规范性和性能的问题：\n关联查询的表不得超过三张\n\n考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要\n在规范性能的问题的时候，需要适当考虑规范性\n故意给某些表增加一些冗余的字段。（多表查询→单表查询）\n故意增加一些计算列（大数据量查询→小数据量查询）\n\n10 JDBCJava操作数据库\n程序通过数据库驱动操作数据库\n需要导入一个数据库驱动包：mysql-connector-java-X.X.XX.jar\npublic class JDBCFirstDemo &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        // 1. 加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 固定写法，自动加载DriverManager.registerDriver(new com.mysql.jdbc,Driver());        // 2. 用户信息和url        String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=true&quot;; // 协议(jdbc:mysql)://主机地址:端口号/数据库名?参数        String username = &quot;root&quot;;        String password = &quot;1031&quot;;        // 3. 连接成功，数据库对象Connection        Connection connection = DriverManager.getConnection(url,username,password);        // 4. Statement执行SQL对象        Statement statement = connection.createStatement();        String sql = &quot;select * from users&quot;;        ResultSet resultSet = statement.executeQuery(sql);        // 5.查看返回结果        while(resultSet.next())&#123;            System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));            System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));            System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));            System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));            System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));            System.out.println(&quot;=================&quot;);        &#125;        // 6. 释放连接，耗资源，用完关掉        resultSet.close();        statement.close();        connection.close();    &#125;&#125;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\nStatement &amp; ResultSet\nConnection connection = DriverManager.getConnection(url,username,password);Statement statement = connection.createStatement();String sql = &quot;select * from users&quot;;ResultSet resultSet = statement.executeQuery(sql); // 查询操作返回ResultSetstatement.execute(); // 执行任何SQLstatement.executeUpdate(); // 更新、插入，删除，返回一个受影响的行数// ResultSetresultSet.getObject(&quot;id&quot;) // 不知道返回类型resultSet.getString(&quot;id&quot;) // 知道返回类型// 遍历指针（光标）resultSet.next() // 移动到下一行resultSet.beforeFirst() // 移动到最前resultSet.afterLast() // 移动到最后resultSet.previous()  // 移动到前一行resultSet.absolute(row) //移动到指定行\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.2 SQL注入\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SQLInjection &#123;    public static void main(String[] args) &#123;        login(&quot;zhg&quot;,&quot;123456&quot;); // 正常登录        login(&quot;&#x27;or&#x27;1=1&quot;,&quot;&#x27;or&#x27;1=1&quot;); //SQL注入：用or拼接SQL语句...    &#125;    // 登录业务    public static void login(String username,String password)&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users where `NAME` =&#x27;&quot;+username+&quot;&#x27; and `PASSWORD` = &#x27;&quot;+password+&quot;&#x27;&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.3 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n10.4 数据库连接池数据库连接→执行→释放，非常浪费系统资源\n池化技术：准备一些预先的资源，过来就连接预先准备好的\n编写连接池，实现接口DataSource\n开源数据源实现\nDBCP\nC3P0\nDruid：阿里\n使用这些数据库连接池之后，我们在项目开发中不需要编写数据库的代码了！\nDBCP，需要jar包：commons-dbcp-1.4, commons-pool-1.6\nC3P0，需要jar包：c3p0-0.9.5.5, mcharge-commons-java-0.2.19\n无论使用什么数据源，本质还是一样的，DataSource接口不会变，方法就不会变\n","tags":["MySQL","JDBC"]},{"title":"注解和反射","url":"/2020/10/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","content":"1 注解简介注解（Annotation）是从JDK5.0开始引入的新技术\n作用：\n\n对程序作出解释（非必须，检查和约束）\n被其他程序读取（编译器）\n\n格式：@注解名（有的还可以添加参数值）\nAnnotation可以附加在package, class, method, field 等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问\n1.1 内置注解@Override：重写父类方法\n@Deprecated：不推荐使用\n@SuppressWarnings(“all”)：抑制警告\n1.2 元注解作用：注解其他注解，为其他annotation提供说明\nJava定义了4个标准的meta-annotation类型：@Target, @Retention, @Document, @Inherited\n\n@Target：描述注解的使用范围\n\n@Retention：描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）\n\n@Documented：说明该注解被包含在javadoc中\n\n@inherited：说明子类可以继承父类中的该注释\n\n\n1.3 自定义注解格式：public @ interface 注解名 {定义内容}\npublic class Test extends Object&#123;\t//注解可以显式赋值，如果没有默认值，则必须赋值\t@MyAnnotation(name = &quot;XXX&quot;,schools = &#123;&quot;门头沟大学&quot;,&quot;家里蹲大学&quot;&#125;)\tpublic void test() &#123;\t\t&#125;&#125;//定义一个注解//Target 描述注解使用范围@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 描述注解生效时间@Retention(value = RetentionPolicy.RUNTIME)//Documented 表示将注解生成在javadoc中@Documented//Inherited 表示子类可以继承父类的注解@Inherited@interface MyAnnotation&#123;\t//注解的参数：参数类型+参数名()\t//假如只有一参数，建议命名为value\tString name() default &quot;&quot;;\tint age() default 0;\tint id() default -1;\tString[] schools() default &#123;&quot;&quot;&#125;;&#125;\n\n2 反射机制静态语言VS动态语言\n\n动态语言：运行时代码可以根据某些条件改变自身结构（C#, JavaScript, Python…）\n\n静态语言：运行时结构不可变（Java, C, C++…）\n\n\nJava不是动态语言，但Java可以利用反射机制获得类似动态语言的特性\n反射机制（Reflection）允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法\n功能：\n\n运行时进行与类（对象）相关的操作\n运行时处理注解\n生成动态代理（AOP）\n\n优点：实现动态创建对象和编译，体现出很大的灵活性\n缺点：对性能有影响。使用反射基本上是一种解释操作，这类操作总是慢于直接执行相同的操作\n主要API：java.lang.Class…\n2.1 Class类Object类中定义了getClass()方法，被所有子类继承\n\n获取Class类的实例：\npublic class Test01 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\tPerson person = new Student();\t\tSystem.out.println(&quot;这个人是：&quot;+person.name);\t\t//一个类在内存中只有一个Class对象\t\t//一个类被加载后，类的整个结构都会被封装在Class对象中\t\t//获取类的Class对象\t\t//方式一：通过对象获得\t\tClass c1 = person.getClass();\t\tSystem.out.println(c1.hashCode());\t\t\t\t//方式二：通过Class.forName获得\t\tClass c2 = Class.forName(&quot;com.zhg.reflection.Student&quot;);\t\tSystem.out.println(c2.hashCode());\t\t\t\t//方式三：通过类名.class获得\t\tClass c3 = Student.class;\t\tSystem.out.println(c3.hashCode());\t\t\t\t//方式四：基本内置类型的包装类都有一个TYPE属性\t\tClass c4 = Integer.TYPE;\t\tSystem.out.println(c4);\t\t\t\t//获得父类类型\t\tClass c5 = c1.getSuperclass();\t\tSystem.out.println(c5);\t&#125;&#125;class Person&#123;\tpublic String name;\tpublic Person() &#123;\t\tsuper();\t&#125;\tpublic Person(String name) &#123;\t\tsuper();\t\tthis.name = name;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Person [name=&quot; + name + &quot;]&quot;;\t&#125;&#125;class Student extends Person&#123;\tpublic Student() &#123;\t\tthis.name = &quot;学生&quot;;\t&#125;&#125;class Teacher extends Person&#123;\tpublic Teacher() &#123;\t\t\t&#125;&#125;\n\n哪些类型可以有Class对象？\nimport java.lang.annotation.ElementType;//所有类型的Class对象public class Test02 &#123;\tpublic static void main(String[] args) &#123;\t\tClass c1 = Object.class; //类\t\tClass c2 = Comparable.class; //接口\t\tClass c3 = String[].class; //一维数组\t\tClass c4 = int[][].class; //二维数组\t\tClass c5 = Override.class; //注解\t\tClass c6 = ElementType.class; //枚举\t\tClass c7 = Integer.class; //基本数据类型包装类\t\tClass c8 = void.class; //void\t\tClass c9 = Class.class; //Class\t\tSystem.out.println(c1); //class java.lang.Object\t\tSystem.out.println(c2); //interface java.lang.Comparable\t\tSystem.out.println(c3); //class [Ljava.lang.String;\t\tSystem.out.println(c4); //class [[I\t\tSystem.out.println(c5); //interface java.lang.Override\t\tSystem.out.println(c6); //class java.lang.annotation.ElementType\t\tSystem.out.println(c7); //class java.lang.Integer\t\tSystem.out.println(c8); //void\t\tSystem.out.println(c9); //class java.lang.Class\t\t//只要元素类型与维度一样，就是同一Class\t\tint[] a = new int[10];\t\tint[] b = new int[100];\t\tSystem.out.println(a.getClass().hashCode());\t\tSystem.out.println(b.getClass().hashCode()); \t&#125;&#125;\n\n2.2 内存分析Java内存：堆（方法区），栈\n堆：存放new的对象和数组，可以被所有线程共享\n方法区：特殊的堆，存放所有class和static变量\n栈：存放基本变量类型，引用类型的变量\n2.2.1 类的加载过程\n加载（Load）：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象\n链接（Link）：将Java类的二进制代码合并到JVM的运行状态（JRE）中的过程\n\n验证：确保加载类信息符合JVM规范，没有安全问题\n准备：为类变量（static）分配内存并设置默认初始值\n解析：虚拟机常量池的符号（常量名）引用替换为直接引用（地址）的过程\n\n初始化（Initialize）：\n\n执行类构造器&lt;clinit&gt;()方法的过程（类构造器是构造类信息的）\n先触发父类的初始化\n保证&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步\n\npublic class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\tA a = new A();\t\tSystem.out.println(A.m);\t\t/*\t\t 1.加载到内存，会产生一个类对应的Class对象\t\t 2.链接，链接结束后 m = 0\t\t 3.初始化\t\t &lt;clinit&gt;()&#123;\t\t \tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\t\tm = 300;\t\t\tm = 100;\t\t&#125;\t\tm = 100;\t\t */\t&#125;&#125;class A&#123;\tstatic &#123;\t\tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\tm = 300;\t&#125;\tstatic int m = 100;\tpublic A() &#123;\t\tSystem.out.println(&quot;A类的无参构造器初始化&quot;);\t&#125;&#125;\n\n2.2.2 类的初始化什么时候会发生类的初始化？\n\n类的主动引用（一定会发生类的初始化）\n虚拟机启动时先初始化main方法所在的类\nnew一个类的对象\n调用类的静态成员和静态方法（除了final常量）\n对类进行反射调用\n当初始化一个类时，先初始化其父类\n\n\n类的被动引用（不会发生类的初始化）\n当访问静态域时，只有真正声明这个于的类才会被初始化\n通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）\n\n\n\n//测试类什么时候会初始化public class Test04 &#123;\tstatic &#123;\t\tSystem.out.println(&quot;main类被加载&quot;);\t&#125;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//1.主动引用\t\t//Son son = new Son();\t\t\t\t//反射也会产生主动引用\t\t//Class.forName(&quot;com.zhg.reflection.Son&quot;);\t\t\t\t//不会产生类的引用的方法\t\t//System.out.println(Son.b);\t\t//Son[] array = new Son[5];\t\tSystem.out.println(Son.M);\t&#125;&#125;class Father&#123;\tstatic int b = 2;\tstatic &#123;\t\tSystem.out.println(&quot;父类被加载&quot;);\t&#125;&#125;class Son extends Father&#123;\tstatic &#123;\t\tSystem.out.println(&quot;子类被加载&quot;);\t\tm = 300;\t&#125;\t\tstatic int m = 100;\tstatic final int M = 1;&#125;\n\n2.2.3 类加载器作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成这个类的Class对象，作为方法区中类数据的访问入口\n\n类缓存：类加载器加载类时，先按要求查找类，如果某个类被加载到类加载器中，它将维持加载（缓存）一段时间。\n类加载器的类型：\n\n引导类加载器（负责Java核心库）\n扩展类加载器\n系统类加载器\n\npublic class Test05 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//获取系统类的加载器\t\tClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\t\tSystem.out.println(systemClassLoader);\t\t\t\t//获取系统类加载器的父类加载器--&gt;扩展类加载器\t\tClassLoader parent = systemClassLoader.getParent();\t\tSystem.out.println(parent);\t\t\t\t//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）\t\tClassLoader parent1 = parent.getParent();\t\tSystem.out.println(parent1);\t\t\t\t//测试当前类是哪个加载器加载的（系统类加载器）\t\tClassLoader classLoader = Class.forName(&quot;com.zhg.reflection.Test05&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//测试JDK内置的类是谁加载的（根加载器）\t\tclassLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//如何获得系统类加载器可以加载的路径\t\tSystem.out.println(System.getProperty(&quot;java.class.path&quot;));\t\t\t\t//双亲委派机制\t\t\t//java.lang.String--&gt;多重检测，保证安全性\t&#125;&#125;\n\n2.2.4 获取类的结构通过反射获取运行时类的完整结构\nField, Method, Constructor, Superclass, Interface, Annotation…\n//获取类的信息public class Test06 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, NoSuchMethodException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\tPerson person = new Person();\t\tc1 = person.getClass();\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的名字\t\tSystem.out.println(c1.getName()); //获得包名 + 类名\t\tSystem.out.println(c1.getSimpleName()); //获得类名\t\t\t//获得类的属性\t\tField[] fields = c1.getFields(); //只能找到public属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\tfields = c1.getDeclaredFields(); //找到全部的属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\t\t//获取指定属性的值\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\tSystem.out.println(name);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的方法\t\tMethod[] methods = c1.getMethods(); //获得本类及父类的所有public方法\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;正常的：&quot;+method);\t\t&#125;\t\tmethods = c1.getDeclaredMethods(); //获得本类的所有方法（包括private方法）\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;getDeclaredMethods：&quot;+method);\t\t&#125;\t\t//获得指定方法\t\tMethod getName = c1.getMethod(&quot;getName&quot;, null);\t\tMethod setName = c1.getMethod(&quot;setName&quot;, String.class);\t\tSystem.out.println(getName);\t\tSystem.out.println(setName);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得指定的构造器\t\tConstructor[] constructors = c1.getConstructors(); //获得public构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(constructor);\t\t&#125;\t\tconstructors = c1.getDeclaredConstructors(); //获得全部构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(&quot;#&quot;+constructor);\t\t&#125;\t\t//获得指定的构造器\t\tConstructor declaredConstructor = c1.getDeclaredConstructor(String.class);\t\tSystem.out.println(&quot;指定：&quot;+declaredConstructor);\t&#125;&#125;\n\n2.3 实际应用2.3.1 动态创建对象动态创建类的对象：调用Class对象的newInstance()方法\n\n类必须有一个无参构造器\n类的构造器的访问权限需要足够\n\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//通过反射动态的创建对象public class Test07 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;\t\t//构造Class对象\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\t\t\t//构造一个对象\t\tPerson person = (Person) c1.newInstance();  //本质是调用了类的无参构造器\t\tSystem.out.println(person);\t\t\t\t//通过构造器创建对象\t\tConstructor constructor = c1.getDeclaredConstructor(String.class);\t\tPerson person2 = (Person)constructor.newInstance(&quot;XX&quot;);\t\tSystem.out.println(person2);\t\t\t\t//通过反射调用普通方法\t\tPerson person3 = (Person) c1.newInstance();\t\tMethod setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);\t\t//invoke(对象，方法参数)\t\tsetName.invoke(person3, &quot;XXX&quot;);\t\tSystem.out.println(person3.name);\t\tSystem.out.println(&quot;=================&quot;);\t\t//通过反射操作属性\t\tPerson person4 = (Person) c1.newInstance();\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\t//不能直接操作私有属性，需要关闭程序的安全检测，属性或者方法的setAccessible(true)\t\tname.setAccessible(true); //\t\tname.set(person4, &quot;XXXX&quot;);\t\tSystem.out.println(person4.getName());\t\t\t&#125;&#125;\n\nsetAccessible参数值为true则指示反射的对象在使用时取消Java语言访问检查→提高了反射的效率；使得原本无法访问的私有成员也可以访问\n性能分析（调用对象的方法）：普通方式 VS 反射方式 VS 关闭检测后反射\nimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class Test08 &#123;\t//普通方式调用\tpublic static void test01() &#123;\t\tPerson person = new Person();\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tperson.getName();\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;普通方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t//反射方式调用\tpublic static void test02() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t\t//反射方式调用 关闭检测\tpublic static void test03() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\tgetName.setAccessible(true);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;关闭检测后反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\tpublic static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\ttest01();\t\ttest02();\t\ttest03();\t&#125;&#125;\n\n2.3.2 获取泛型信息Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，一旦编译完成，所有和泛型有关的类型全部擦除\n通过反射操作类型：\nimport java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;//通过反射获取泛型public class Test09 &#123;\tpublic void test01(Map&lt;String,Person&gt; map,List&lt;Person&gt; list)&#123;\t\tSystem.out.println(&quot;test01&quot;);\t&#125;\tpublic Map&lt;String,Person&gt;test02()&#123;\t\tSystem.out.println(&quot;test02&quot;);\t\treturn null;\t&#125;\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException &#123;\t\tMethod method = Test09.class.getMethod(&quot;test01&quot;, Map.class,List.class);\t\tType[] genericParameterTypes = method.getGenericParameterTypes();\t\tfor(Type genericParameterType:genericParameterTypes) &#123;\t\t\tSystem.out.println(&quot;#&quot;+genericParameterType);\t\t\tif(genericParameterType instanceof ParameterizedType) &#123;\t\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericParameterType).getActualTypeArguments();\t\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tmethod = Test09.class.getMethod(&quot;test02&quot;, null);\t\tType genericReturnType = method.getGenericReturnType();\t\tif(genericReturnType instanceof ParameterizedType) &#123;\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericReturnType).getActualTypeArguments();\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n2.3.3 获取注解信息ORM(Object Relationship Mapping)：对象关系映射\n\n类和表结构对应\n属性和字段对应\n对象和记录对应\n\n利用注解和反射完成类和表结构的映射关系：\nimport java.lang.annotation.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;//练习反射操作注解public class Test10 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.StudentX&quot;);\t\t\t\t//通过反射获得注解\t\tAnnotation[] annotations = c1.getAnnotations();\t\tfor(Annotation annotation:annotations) &#123;\t\t\tSystem.out.println(annotation);\t\t&#125;\t\t\t\t//获取注解的value值\t\tTableX table = (TableX)c1.getAnnotation(TableX.class);\t\tString value = table.value();\t\tSystem.out.println(value);\t\t\t\t//获取类指定的注解\t\tField f = c1.getDeclaredField(&quot;name&quot;);\t\tFieldX annotation = f.getAnnotation(FieldX.class);\t\tSystem.out.println(annotation.columnName());\t\tSystem.out.println(annotation.type());\t\tSystem.out.println(annotation.length());\t&#125;&#125;@TableX(&quot;db_student&quot;)class StudentX&#123;\t\t@FieldX(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)\tprivate int id;\t@FieldX(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)\tprivate int age;\t@FieldX(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)\tprivate String name;\tpublic StudentX() &#123;\t\tsuper();\t&#125;\tpublic StudentX(int id, int age, String name) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.age = age;\t\tthis.name = name;\t&#125;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\tpublic int getAge() &#123;\t\treturn age;\t&#125;\tpublic void setAge(int age) &#123;\t\tthis.age = age;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Student [id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;\t&#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableX&#123;\tString value();&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldX&#123;\tString columnName();\tString type();\tint length();&#125;","tags":["Java","JavaSE","注解","反射"]},{"title":"多线程详解","url":"/2020/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/","content":"1.1 线程简介多任务→多线程\n进程 VS 线程\n\n程序是指令和数据的有序集合，是一个静态的概念。\n进程是程序的一次执行过程,是一个动态的概念。\n进程中至少有一个线程，线程是CPU调度和执行的基本单位。\n\n1.2 线程创建三种创建方式：\n\n继承Thread类\n实现Runnable接口\n实现Callable接口（了解）\n\n1.2.1 继承Thread类创建线程方式一：继承Thread类→重写run()方法→调用start()启动线程\n//注意，线程开启不一定立即执行，由CPU调度执行public class TestThread1 extends Thread&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//main线程，主线程\t\tTestThread1 testThread1 = new TestThread1();\t\t//调用start()方法开启线程，交替执行\t\ttestThread1.start();\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;\t&#125;\n\n实现多线程同步下载图片\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;public class TestThread2 extends Thread&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2 t1 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2 t2 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2 t3 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\tt1.start();\t\tt2.start();\t\tt3.start();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n1.2.2 实现Runnable接口创建线程方式二：实现Runnable接口→重写run()方法→调用start()启动线程（需要Runnable接口实现类）\npublic class TestThread3 implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//创建runnable接口的实现类对象\t\tTestThread3 testThread3 = new TestThread3();\t\t\t\t//创建线程对象，通过线程对象来开启线程，代理//\t\tThread thread = new Thread(testThread3);//\t\tthread.start();\t\tnew Thread(testThread3).start();\t\t\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;&#125;\n\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;//练习Thread，实现多线程同步下载图片public class TestThread2n implements Runnable&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2n(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader1 webDownloader = new WebDownloader1();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2n t1 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2n t2 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2n t3 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\tnew Thread(t1).start();\t\tnew Thread(t2).start();\t\tnew Thread(t3).start();\t&#125;&#125;//下载器class WebDownloader1&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n小结：\n\n继承Thread类\n子类继承Thread类具备多线程能力\n启动线程：子类对象.start()\n不建议使用：避免OOP单继承局限性\n\n\n实现Runnable接口\n实现接口Runnable具有多线程能力\n启动线程：传入目标对象+Thread对象.start()\n推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用\n\n\n\n多个线程同时操作一个对象，买火车票的例子\n//问题：多个线程操作同一个资源，线程不安全，数据紊乱public class TestThread4 implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\ttry &#123;\t\t\t\tThread.sleep(10);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread4 ticket = new TestThread4();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\n案例：龟兔赛跑\n//模拟龟兔赛跑public class Race implements Runnable&#123;\t//胜利者\tprivate static String winner; \tpublic static void main(String[] args) &#123;\t\tRace race = new Race();\t\tnew Thread(race,&quot;兔子&quot;).start();\t\tnew Thread(race,&quot;乌龟&quot;).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tfor(int i = 0; i &lt;= 100;i++) &#123;\t\t\t//模拟兔子休息\t\t\tif(&quot;兔子&quot;.equals(Thread.currentThread().getName() )&amp;&amp; i%10==5) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(56);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(&quot;乌龟&quot;.equals(Thread.currentThread().getName() )) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(5);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\t//判断比赛是否结束\t\t\tboolean flag = gameOver(i);\t\t\t//如果比赛结束了，就停止程序\t\t\tif(flag) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;);\t\t&#125;\t\t&#125;\t//判断是否完成比赛\tprivate boolean gameOver(int steps) &#123;\t\t//判断是否有胜利者\t\tif(winner!=null) &#123;\t\t\treturn true;\t\t&#125;else &#123;\t\t\tif(steps==100) &#123;\t\t\t\twinner = Thread.currentThread().getName();\t\t\t\tSystem.out.println(&quot;winner is &quot;+winner);\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t\treturn false;\t&#125;&#125;\n\n1.2.3 实现Callable接口创建线程方式三（了解即可）：实现Callable接口（需要返回值类型）→重写call()方法（需要抛出异常）→创建目标对象→创建关闭服务\nimport java.io.File;import java.net.URL;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import org.apache.commons.io.FileUtils;//创建方式三：实现Callable接口/* * Callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 */public class TestCallable implements Callable&lt;Boolean&gt;&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestCallable(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic Boolean call() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t\treturn true;\t&#125;\tpublic static void main(String[] args) throws Exception &#123;\t\tTestCallable t1 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestCallable t2 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestCallable t3 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\t//创建执行服务 \t\tExecutorService ser = Executors.newFixedThreadPool(3);\t\t\t\t//提交执行\t\tFuture&lt;Boolean&gt; r1 = ser.submit(t1);\t\tFuture&lt;Boolean&gt; r2 = ser.submit(t2);\t\tFuture&lt;Boolean&gt; r3 = ser.submit(t3);\t\t\t\t//获取结果\t\tboolean rs1 = r1.get();\t\tboolean rs2 = r2.get();\t\tboolean rs3 = r3.get();\t\t\t\tSystem.out.println(rs1);\t\tSystem.out.println(rs2);\t\tSystem.out.println(rs3);\t\t//关闭服务\t\tser.shutdown();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\nLamda表达式语法：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }\n作用：简化代码，避免匿名内部类定义过多\nFunction Interface（函数式接口）：只包含唯一一个抽象方法\n可以通过lamda表达式来创建函数式接口的对象\n推导lambda表达式\npublic class TestLambda1 &#123;\t//3.静态内部类\tstatic class Like2 implements ILike&#123;\t\t@Override\t\tpublic void lambda() &#123;\t\t\tSystem.out.println(&quot;I like lambda2&quot;);\t\t&#125;\t\t\t&#125;\t\tpublic static void main(String[] args) &#123;\t\tILike like = new Like();\t\tlike.lambda();\t\tlike = new Like2();\t\tlike.lambda();\t\t\t\t//4.局部内部类\t\tclass Like3 implements ILike&#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda3&quot;);\t\t\t&#125;\t\t\t\t&#125;\t\tlike = new Like3();\t\tlike.lambda();\t\t\t\t//5.匿名内部类，没有类的名称，必须借助接口或者父类\t\tlike = new ILike() &#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda4&quot;);\t\t\t&#125;\t\t&#125;;\t\tlike.lambda();\t\t\t\t//6.用lambda简化\t\tlike = () -&gt; &#123;\t\t\tSystem.out.println(&quot;I like lambda5&quot;);\t\t&#125;;\t\tlike.lambda();\t&#125;&#125;//1.定义一个函数式接口interface ILike&#123;\tvoid lambda();&#125;//2.实现类class Like implements ILike&#123;\t@Override\tpublic void lambda() &#123;\t\tSystem.out.println(&quot;I like lambda&quot;);\t&#125;\t&#125;\n\n简化lambda表达式：1.省略参数类型 2.省略括号\n静态代理示例（婚庆公司）\npublic class StaticProxy &#123;\tpublic static void main(String[] args) &#123;        You you = new You(); \t\tyou.HappyMarry();        //\t\tnew Thread(()-&gt;System.out.println(&quot;我爱你&quot;)).start();//\t\tnew WeddingCompany(new You()).HappyMarry();\t\t//代理\t\tWeddingCompany weddingCompany = new WeddingCompany(new You());\t\tweddingCompany.HappyMarry();\t&#125;&#125;interface Marry&#123;\tvoid HappyMarry();&#125;//真实角色class You implements Marry&#123;\t@Override\tpublic void HappyMarry() &#123;\t\tSystem.out.println(&quot;结婚了，开心&quot;);\t\t\t&#125;&#125;//代理角色class WeddingCompany implements Marry&#123;\tprivate Marry target;\t\tpublic WeddingCompany(Marry target) &#123;\t\tthis.target = target;\t&#125;\t@Override\tpublic void HappyMarry() &#123;\t\tbefore();\t\tthis.target.HappyMarry(); //真实对象\t\tafter();\t&#125;\tprivate void after() &#123;\t\tSystem.out.println(&quot;结婚之后，收尾款&quot;);\t\t\t&#125;\tprivate void before() &#123;\t\tSystem.out.println(&quot;结婚之前，布置现场&quot;);\t\t\t&#125;\t&#125;\n\n静态代理模式总结：\n\n真实对象和代理对象都要实现同一个接口\n代理对象代理真实对象\n\n好处：\n\n代理对象可以做很多真实对象做不了的事情\n真实对象专注做自己的事情\n\n1.3 线程状态1.3.1 五大状态\n\n1.3.2 线程停止\n不推荐使用JDK提供的stop()、destroy()方法【已废弃】\n推荐线程自己停下来（建议使用一标志位进行终止变量）\n\n//测试stop//1.建议线程正常停止--&gt;利用次数，不建议死循环//2.建议使用标志位//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法public class TestStop implements Runnable&#123;\tprivate boolean flag = true;\tpublic static void main(String[] args) &#123;\t\tTestStop testStop = new TestStop();\t\tnew Thread(testStop).start();\t\tfor(int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t\tif(i == 900) &#123;\t\t\t\t//调用stop()方法切换标志位，让线程停止\t\t\t\ttestStop.stop();\t\t\t\tSystem.out.println(&quot;线程停止&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tint i = 0;\t\twhile(flag) &#123;\t\t\tSystem.out.println(&quot;run ... Thread&quot;+i++);\t\t&#125;\t\t&#125;\tpublic void stop() &#123;\t\tthis.flag = false;\t&#125;&#125;\n\n1.3.3 线程休眠sleep(毫秒)→就绪\n每个对象有个锁，sleep不会释放锁\n//模拟网络延时：放大问题的发生性public class TestSleep implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t//模拟延时\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestSleep ticket = new TestSleep();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\nimport java.text.SimpleDateFormat;import java.util.Date;public class TestSleep2&#123;\tpublic static void main(String[] args) &#123;\t\t//模拟倒计时\t\ttry &#123;\t\t\ttenDown();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t//打印当前系统时间\t\tDate startTime = new Date(System.currentTimeMillis());\t\twhile(true) &#123;\t\t\ttry &#123;\t\t\t\tSystem.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\t\t\t\tThread.sleep(1000);\t\t\t\tstartTime = new Date(System.currentTimeMillis()); //更新当前时间\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t&#125;\tpublic static void tenDown() throws InterruptedException &#123;\t\tint num = 3;\t\twhile(true) &#123;\t\t\tThread.sleep(1000);\t\t\tSystem.out.println(num--);\t\t\tif(num&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t&#125;&#125;\n\n1.3.4 线程礼让Yield让当前线程暂停但不阻塞，转为就绪状态\n礼让不一定成功\n//测试礼让线程，礼让不一定成功public class TestYield &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tMyYield myYield = new MyYield();\t\tnew Thread(myYield,&quot;a&quot;).start();\t\tnew Thread(myYield,&quot;b&quot;).start();\t&#125;&#125;class MyYield implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);\t\tThread.yield(); //礼让\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);\t&#125;\t&#125;\n\n1.3.5 线程强制执行Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞（可以看作是插队）\n//测试join方法public class TestJoin implements Runnable&#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\t//启动我们的线程\t\tTestJoin testJoin = new TestJoin();\t\tThread thread = new Thread(testJoin);\t\tthread.start();\t\tfor (int i = 0; i &lt; 500; i++) &#123;\t\t\tif(i==200) &#123;\t\t\t\tthread.join();//插队\t\t\t&#125;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;线程vip来了&quot;+i);\t\t&#125;\t\t&#125;&#125;\n\n1.3.6 线程优先级优先高的不一定先执行，默认是5\n//测试线程的优先级public class TestPriority&#123;\tpublic static void main(String[] args) &#123;\t\t//主线程默认优先级\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\tMyPriority myPriority = new MyPriority();\t\tThread t1 = new Thread(myPriority);\t\tThread t2 = new Thread(myPriority);\t\tThread t3 = new Thread(myPriority);\t\tThread t4 = new Thread(myPriority);\t\t//先设置优先级，再启动\t\tt1.start();\t\tt2.setPriority(1);\t\tt2.start();\t\tt3.setPriority(4);\t\tt3.start();\t\tt4.setPriority(Thread.MAX_PRIORITY); //MAX_PRIORITY=10\t\tt4.start();\t&#125;&#125;class MyPriority implements Runnable&#123;\t@Override\tpublic void run() &#123;\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\t\t&#125;\t&#125;\n\n1.3.7 守护（daemon）线程线程分为用户线程和守护线程\n虚拟机必须确保用户线程（如，后台记录操作日志，监控内存，垃圾回收等待）执行完毕，但不用等待守护线程执行完毕\n//测试守护线程//上帝守护你public class TestDaemon &#123;\tpublic static void main(String[] args) &#123;\t\tGod god = new God();\t\tYou you = new You();\t\tThread thread = new Thread(god);\t\tthread.setDaemon(true); //默认是false表示是用户线程，正常的线程都是用户线程\t\tthread.start(); //守护线程启动\t\tnew Thread(you).start(); //用户线程启动\t&#125;&#125;//上帝class God implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tSystem.out.println(&quot;上帝保佑着你&quot;);\t\t&#125;\t&#125;\t&#125;//你class You implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 36500; i++) &#123;\t\t\tSystem.out.println(&quot;开心活着&quot;);\t\t&#125;\t\tSystem.out.println(&quot;====Good bye!====&quot;);\t&#125;\t&#125;\n\n1.4 线程同步多个线程操作同一资源（并发）\n线程同步是一种等待机制，多个需要同时访问同一对象的线程进图该对象的等待池形成队列，等待前面线程使用完毕，下一线程再使用\n形成条件：队列+锁（synchronized）\n1.4.1 同步方法及同步块三个不安全案例1.不安全的买票\n//不安全的买票(线程不安全）public class UnsafeBuyTicket &#123;\tpublic static void main(String[] args) &#123;\t\tBuyTicket station = new BuyTicket();\t\tnew Thread(station,&quot;苦逼的我&quot;).start();\t\tnew Thread(station,&quot;牛逼的你们&quot;).start();\t\tnew Thread(station,&quot;可恶的黄牛党&quot;).start();\t&#125;\t&#125;class BuyTicket implements Runnable&#123;\t\t//票\tprivate int ticketNum = 10;\tboolean flag = true; //外部停止方式\t@Override\tpublic void run() &#123;\t\t//买票\t\twhile(flag) &#123;\t\t\tbuy();\t\t&#125;\t&#125;\tprivate void buy() &#123;\t\tif(ticketNum&lt;=0) &#123;\t\t\tflag = false;\t\t\treturn;\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//买票        System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--);\t&#125;\t&#125;\n\n2.不安全的取钱\n//不安全的取钱（两个人）public class UnsafeBank &#123;\tpublic static void main(String[] args) &#123;\t\tAccount account = new Account(100,&quot;结婚基金&quot;);\t\tDrawing you = new Drawing(account,50,&quot;你&quot;);\t\tDrawing GF = new Drawing(account,100,&quot;女朋友&quot;);\t\tyou.start();\t\tGF.start();\t&#125;&#125;//账户class Account&#123;\tint money; //余额\tString name; //卡名\tpublic Account(int money, String name) &#123;\t\tsuper();\t\tthis.money = money;\t\tthis.name = name;\t&#125;&#125;//银行：模拟取款class Drawing extends Thread&#123;\tAccount account;\t//取了多少钱\tint drawingMoney;\t//现在手里有多少钱\tint nowMoney;\tpublic Drawing(Account account,int drawingMoney,String name) &#123;\t\tsuper(name);\t\tthis.account = account;\t\tthis.drawingMoney = drawingMoney;\t&#125;\t//取钱\t@Override\tpublic void run() &#123;\t\t//判断有没有钱\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\treturn;\t\t&#125;\t\t//放大问题的发生性\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//卡内余额 = 余额 - 取的钱\t\taccount.money = account.money - drawingMoney;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;&#125;\n\n3.不安全的集合\n//线程不安全的集合//添加到同一位置被覆盖public class UnsafeList &#123;\tpublic static void main(String[] args) &#123;\t\tList&lt;String&gt; list = new ArrayList&lt;String&gt;();\t\tfor (int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\nsynchronized同步方法：public synchronized void method(int args) { }\nsynchronized方法控制对“对象”的访问，每个对象对象对应一把锁，每个synchronized方法都必须获得调用该方法的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行\n同步块：synchronized(Obj) { }\nObj称为同步监视器\n\nObj可以是任何对象，但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this\n\npublic void run() &#123;\t\t//锁的对象就是变化的量，需要增删改的对象\t\tsynchronized (account) &#123;\t\t\t//判断有没有钱\t\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\t\treturn;\t\t\t&#125;\t\t\t//放大问题的发生性\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t//卡内余额 = 余额 - 取的钱\t\t\taccount.money = account.money - drawingMoney;\t\t&#125;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;\n\nCopyOnWriteArrayListJUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。Callable接口也在JUC中。\nimport java.util.concurrent.CopyOnWriteArrayList;//测试JUC安全类型的集合public class TestJUC &#123;\tpublic static void main(String[] args) &#123;\t\tCopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();\t\tfor(int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(3000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\n1.4.2 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“的问题\n//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class DeadLock &#123;\tpublic static void main(String[] args) &#123;\t\tMakeup g1 = new Makeup(0,&quot;灰姑娘&quot;);\t\tMakeup g2 = new Makeup(1,&quot;白雪公主&quot;);\t\tg1.start();\t\tg2.start();\t&#125;&#125;//口红class Lipstick&#123;\t&#125;//镜子class Mirror&#123;\t&#125;class Makeup extends Thread&#123;\t//需要的资源只有一份，用static来保证只有一份\tstatic Lipstick lipstick = new Lipstick();\tstatic Mirror mirror = new Mirror();\t\tint choice; //选择\tString girlName; //选择化妆品的人\t\tMakeup(int choice,String girlName)&#123;\t\tthis.choice = choice;\t\tthis.girlName = girlName;\t&#125;\t@Override\tpublic void run() &#123;\t\t//化妆\t\ttry &#123;\t\t\tmakeup();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t\t//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t\t\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t\t\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n锁中锁（多个对象互相嵌套的锁）使多个线程互相抱着对方需要的资源，然后形成僵持\n解决方法：锁分开写，不要同时占有多个资源\n//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t&#125;\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125;\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t&#125;\n\n产生死锁的四个必要条件：\n\n互斥条件\n请求与保持条件\n不剥夺条件\n循环等待条件\n\n1.4.3 Lock锁从JDK 5.0开始，Java提供了更强大的线程同步机制——显式定义同步锁对象来实现同步。同步锁使用Lock对象充当，Lock锁也包含在JUC内\nReentrantLock（可重入锁）类实现了Lock，可以显式加锁、释放锁\n使用格式：\nLock lock=new ReentrantLock();lock.lock();try&#123;    //处理任务&#125;catch(Exception ex)&#123;     &#125;finally&#123;    lock.unlock();   //释放锁&#125;\n\n测试Lock类（买票）：\nimport java.util.concurrent.locks.ReentrantLock;//测试Lock类public class TestLock &#123;\tpublic static void main(String[] args) &#123;\t\tTestLock2 testLock2 = new TestLock2(); \t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t&#125;&#125;class TestLock2 implements Runnable&#123;\tint ticketNum = 10;\t\t//定义Lock锁\tprivate final ReentrantLock lock = new ReentrantLock();\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tlock.lock();//加锁\t\t\ttry &#123;\t\t\t\tif(ticketNum &gt; 0) &#123;\t\t\t\t\ttry &#123;\t\t\t\t\t\tThread.sleep(1000);\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t\t\t\tSystem.out.println(ticketNum--);\t\t\t\t&#125;else &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;finally &#123;\t\t\t\t//解锁\t\t\t\tlock.unlock();\t\t\t&#125;\t\t\t\t&#125;\t&#125;&#125;\n\nsynchronized与Lock对比\n\nLock是显式锁（手动开启和关闭锁），synchronized是隐式锁，自动释放\n使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）\n\n1.4.4 线程通信线程通信方法：\n\n注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常\n生产者消费者问题解决方法：\n\n利用缓冲区解决：管程法\n//测试生产者消费者模型--&gt;利用缓冲区解决：管程法//生产者，消费者，产品，缓冲区public class TestPC &#123;\tpublic static void main(String[] args) &#123;\t\tSynContainer container = new SynContainer();\t\t\t\tnew Producer(container).start();\t\tnew Consumer(container).start();\t&#125;&#125;//生产者class Producer extends Thread&#123;\tSynContainer container;\tpublic Producer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t\t//生产\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\tcontainer.push(new Chicken(i));\t\t\tSystem.out.println(&quot;生产了第&quot;+i+&quot;只鸡&quot;);\t\t&#125;\t&#125;&#125;//消费者class Consumer extends Thread&#123;\tSynContainer container;\tpublic Consumer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t//消费\t\t@Override\t\tpublic void run() &#123;\t\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\t\tSystem.out.println(&quot;消费了第&quot;+container.pop().id+&quot;只鸡&quot;);\t\t\t&#125;\t\t\t\t&#125;&#125;//产品class Chicken&#123;\tint id; //产品编号\tpublic Chicken(int id) &#123;\t\tthis.id = id;\t&#125;\t&#125;//缓冲区class SynContainer&#123;\t//需要一个容器大小\tChicken[] chickens = new Chicken[10];\t//容器计数器\tint count = 0;\t\t//生产者放入产品\tpublic synchronized void push(Chicken chicken) &#123;\t\t//如果容器满了，就需要等待消费者消费\t\tif(count == chickens.length) &#123;\t\t\t//通知消费者消费，生产等待\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果没有满，我们就需要丢入产品\t\tchickens[count] = chicken;\t\tcount++;\t\t\t\t//可以通知消费者消费了\t\tthis.notifyAll();\t&#125;\t//消费者消费产品\tpublic synchronized Chicken pop() &#123;\t\t//判断能否消费\t\tif(count==0) &#123;\t\t\t//等待生产者生产\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果可以消费\t\tcount--;\t\tChicken chicken = chickens[count];\t\t\t//吃完了，通知生产者生产\t\tthis.notifyAll();\t\treturn chicken;\t\t\t&#125;&#125;\n\n利用标志位解决：信号灯法\npackage com.zhg.thread;//测试生产者消费者模型2--&gt;利用标志位解决：信号灯法public class TestPC2 &#123;\tpublic static void main(String[] args) &#123;\t\tTV tv = new TV();\t\tnew Player(tv).start();\t\tnew Watcher(tv).start();\t&#125;&#125;//生产者--&gt;演员class Player extends Thread&#123;\tTV tv;\tpublic Player(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\tif(i%2==0) &#123;\t\t\t\tthis.tv.play(&quot;快乐大本营&quot;);\t\t\t&#125;else &#123;\t\t\t\tthis.tv.play(&quot;广告&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;//消费者--&gt;观众class Watcher extends Thread&#123;\tTV tv;\tpublic Watcher(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\ttv.watch();\t\t&#125;\t&#125;&#125;//产品--&gt;节目class TV&#123;\t\t//演员表演，观众等待 T\t//观众观看，演员等待 F\tString voice;//表演的节目\tboolean flag = true;\t\t//表演\tpublic synchronized void play(String voice) &#123;\t\t\t\tif(!flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(&quot;演员表演了：&quot;+voice);\t\t//通知观众观看\t\tthis.notifyAll(); //通知唤醒\t\tthis.voice = voice;\t\tthis.flag = !this.flag;\t&#125;\t\t//观看\tpublic synchronized void watch() &#123;\t\tif(flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;观众观看了：&quot;+voice);\t\t//通知演员表演\t\tthis.notifyAll();\t\tthis.flag = !this.flag;\t&#125;&#125;\n\n\n\n线程池背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。\n好处：\n\n提高响应速度\n降低资源消耗\n便于线程管理\n\nJDK 5.0起提供了线程池相关API：ExecutorService和Executors\n\nExecutorService：真正的线程池接口。\n\nExecutor：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。\n\n\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//测试线程池public class TestPool &#123;\tpublic static void main(String[] args) &#123;\t\t//1.创建服务，创建线程池\t\t//newFixedThreadPool 参数为线程池大小\t\tExecutorService service = Executors.newFixedThreadPool(10);\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\t//2.关闭连接\t\tservice.shutdown();\t&#125;&#125;class MyThread implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tSystem.out.println(Thread.currentThread().getName());\t\t\t&#125;&#125;","tags":["Java","JavaSE","多线程"]},{"title":"LeetCode 140.单词拆分II","url":"/2020/11/01/LeetCode140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II/","content":"题目描述：\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n说明：\n\n分隔时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n\n示例1：\n输入:s = “catsanddog”wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]输出:[  “cats and dog”,  “cat sand dog”]\n示例2：\n输入:s = “pineapplepenapple”wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]输出:[  “pine apple pen apple”,  “pineapple pen apple”,  “pine applepen apple”]解释: 可以重复使用字典中的单词。\n示例3：\n输入:s = “catsandog”wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出:[]\n概述：动态规划求是否有解、回溯算法求所有具体解。题目问可不可以拆分，没有问具体怎么拆分，通常考虑使用动态规划解决；题目如果问一个问题的所有的具体解，一般而言使用回溯算法（DFS）完成。\n动态规划求是否有解：\nimport java.util.HashSet;import java.util.List;import java.util.Set;public class Solution &#123;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);        int len = s.length();        // 状态定义：以 s[i] 结尾的子字符串是否符合题意        boolean[] dp = new boolean[len];        for (int right = 0; right &lt; len; right++) &#123;            // 分类讨论 1：不拆分，substring 右端点不包含，所以是 right + 1            if (wordSet.contains(s.substring(0, right + 1))) &#123;                dp[right] = true;                continue;            &#125;            // 分类讨论 2：拆分            for (int left = right - 1; left &gt;= 0; left--) &#123;                if (wordSet.contains(s.substring(left + 1, right + 1)) &amp;&amp; dp[left]) &#123;                    dp[right] = true;                    // 这个 break 很重要，一旦得到 dp[right] = True ，循环不必再继续                    break;                &#125;            &#125;        &#125;        return dp[len - 1];    &#125;&#125;\n\n回溯算法求所有具体解：\n回溯的时间复杂度在最坏情况下高达 O(n^n)。时间复杂度高的原因是存在大量重复计算，可以通过动态规划+深度优先搜索或者记忆化搜索的方式降低时间复杂度。\n1.动态规划+深度优先搜索\nimport java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.HashSet;import java.util.List;import java.util.Set;public class Solution &#123;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        // 为了快速判断一个单词是否在单词集合中，需要将它们加入哈希表        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);        int len = s.length();        // 第 1 步：动态规划计算是否有解        // dp[i] 表示「长度」为 i 的 s 前缀子串可以拆分成 wordDict 中的单词        // 长度包括 0 ，因此状态数组的长度为 len + 1        boolean[] dp = new boolean[len + 1];        // 0 这个值需要被后面的状态值参考，如果一个单词正好在 wordDict 中，dp[0] 设置成 true 是合理的        dp[0] = true;        for (int right = 1; right &lt;= len; right++) &#123;            // 如果单词集合中的单词长度都不长，从后向前遍历是更快的            for (int left = right - 1; left &gt;= 0; left--) &#123;                // substring 不截取 s[right]，dp[left] 的结果不包含 s[left]                if (wordSet.contains(s.substring(left, right)) &amp;&amp; dp[left]) &#123;                    dp[right] = true;                    // 这个 break 很重要，一旦得到 dp[right] = True ，不必再计算下去                    break;                &#125;            &#125;        &#125;        // 第 2 步：回溯算法搜索所有符合条件的解        List&lt;String&gt; res = new ArrayList&lt;&gt;();        if (dp[len]) &#123;            Deque&lt;String&gt; path = new ArrayDeque&lt;&gt;();            dfs(s, len, wordSet, dp, path, res);            return res;        &#125;        return res;    &#125;    private void dfs(String s, int len, Set&lt;String&gt; wordSet, boolean[] dp, Deque&lt;String&gt; path, List&lt;String&gt; res) &#123;        if (len == 0) &#123;            res.add(String.join(&quot; &quot;,path));            return;        &#125;        // 可以拆分的左边界从 len - 1 依次枚举到 0        for (int i = len - 1; i &gt;= 0; i--) &#123;            String suffix = s.substring(i, len);            if (wordSet.contains(suffix) &amp;&amp; dp[i]) &#123;                path.addFirst(suffix);                dfs(s, i, wordSet, dp, path, res);                path.removeFirst();            &#125;        &#125;    &#125;&#125;\n\n2.记忆化搜索\nclass Solution &#123;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map = new HashMap&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;();        List&lt;List&lt;String&gt;&gt; wordBreaks = backtrack(s, s.length(), new HashSet&lt;String&gt;(wordDict), 0, map);        List&lt;String&gt; breakList = new LinkedList&lt;String&gt;();        for (List&lt;String&gt; wordBreak : wordBreaks) &#123;            breakList.add(String.join(&quot; &quot;, wordBreak));        &#125;        return breakList;    &#125;    public List&lt;List&lt;String&gt;&gt; backtrack(String s, int length, Set&lt;String&gt; wordSet, int index, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map) &#123;        if (!map.containsKey(index)) &#123;            List&lt;List&lt;String&gt;&gt; wordBreaks = new LinkedList&lt;List&lt;String&gt;&gt;();            if (index == length) &#123;                wordBreaks.add(new LinkedList&lt;String&gt;());            &#125;            for (int i = index + 1; i &lt;= length; i++) &#123;                String word = s.substring(index, i);                if (wordSet.contains(word)) &#123;                    List&lt;List&lt;String&gt;&gt; nextWordBreaks = backtrack(s, length, wordSet, i, map);                    for (List&lt;String&gt; nextWordBreak : nextWordBreaks) &#123;                        LinkedList&lt;String&gt; wordBreak = new LinkedList&lt;String&gt;(nextWordBreak);                        wordBreak.offerFirst(word);                        wordBreaks.add(wordBreak);                    &#125;                &#125;            &#125;            map.put(index, wordBreaks);        &#125;        return map.get(index);    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/word-break-ii\n","tags":["算法","LeetCode","DFS","记忆化搜索","动态规划"]},{"title":"JavaWeb入门","url":"/2020/11/03/JavaWeb%E5%85%A5%E9%97%A8/","content":"1 环境配置1.1 TomcatTomcat服务器目录\n\nsever.xml可以配置启动的端口号，配置主机的名称\n&lt;!--配置启动的端口号--&gt;&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!--配置主机的名称--&gt;&lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;&gt;\n\n默认端口号：\ntomcat：8080\nmysql：3306\nhttp：80\nhttps：443\n1.2 MavenMaven项目架构管理工具，自动导入和配置jar包\nMaven核心思想：约定大于配置\nMaven会规定如何编写java代码\n镜像：mirrors\n&lt;!--阿里云镜像--&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;\n\n建立一个本地仓库 localRepository\n&lt;localRepository&gt;C:\\apache-maven-3.6.3\\maven-repo&lt;/localRepository&gt;\n\n在IDEA中使用Maven\n\n\n\nMaven项目目录\n\nMaven Web应用项目目录\n\n\npom.xml是maven项目的核心文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Maven版本和头文件--&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--一开始配置的GAV--&gt;  &lt;groupId&gt;com.zhg&lt;/groupId&gt;  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;&lt;!--package：项目打包的方式jar：Java应用war：JavaWeb应用--&gt;  &lt;name&gt;javaweb-01-maven Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#x27;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;&lt;!--配置--&gt;  &lt;properties&gt;    &lt;!--项目的默认构建编码--&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;!--编码版本--&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;!--项目依赖--&gt;  &lt;dependencies&gt;    &lt;!--具体依赖的jar包配置文件--&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;!--项目构建--&gt;  &lt;build&gt;    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.8.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.22.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;\n\nMaven的高级之处在于，它会帮你导入jar包依赖的jar包\n配置resouces节点防止资源导出失败\n&lt;build&gt;    .......      &lt;resources&gt;        &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.properties&lt;/include&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;    ......&lt;/build&gt;\n\nMaven的使用\n地址：https://mvnrepository.com/\n2 HTTP两个时代：\n\nhttp1.0：\nHTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n\nhttp2.0\nHTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源\n\n\n网站访问过程：\n\n输入域名，回车；\n检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有输入域名的映射\n有：直接返回并访问对应的ip地址\n没有：去DNS服务器找，找到就返回并访问\n\n\n\nHTTP请求：\n访问百度请求：\nRequest URL: https://www.baidu.com/ Request Method: GETStatus Code: 200 OKRemote Address: 36.152.44.95:443Accept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7Cache-Control: max-age=0Connection: keep-alive\n\n请求行：请求方式（GET, POST, HEAD, DELETE, PUT, TRACT…）\nRequest URL: https://www.baidu.com/ Request Method: GET\n\n消息头：\nAccept: text/html // 支持的数据类型Accept-Encoding: gzip, deflate, br // 支持的编码格式Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7 // 语言环境Cache-Control: max-age=0 // 缓存控制Connection: keep-alive //保持连接HOST...\n\n\nHTTP响应：\n访问百度响应：\nRequest URL: https://www.baidu.com/ Request Method: GETStatus Code: 200 OKRemote Address: 36.152.44.95:443Cache-Control: privateConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8\n\n响应体：\nAccept: text/html // 支持的数据类型Accept-Encoding: gzip, deflate, br // 支持的编码格式Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7 // 语言环境Cache-Control: max-age=0 // 缓存控制Connection: keep-alive //保持连接HOST...Refresh...Location...\n\n响应状态码：\n200 请求响应成功\n3** 请求重定向\n404 找不到资源\n5** 服务器代码错误 502：网关错误\n3 ServletServlet程序开发步骤：\n\n编写一个类，实现Servlet接口\n把开发好的Java类部署到Web服务器中\n\n用IDEA开发Servlet程序步骤：\n\n构建一个普通的Maven项目，删掉里面的src目录，之后就在项目里创建module，这个空工程就是Maven的主工程\n\n创建子模块（Maven Web应用）\n父项目pom.xml中会有\n&lt;modules&gt;        &lt;module&gt;servlet-01&lt;/module&gt;&lt;/modules&gt;\n\n子项目pom.xml中会有\n&lt;parent&gt;    &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;    &lt;groupId&gt;com.zhg&lt;/groupId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;\n\nMaven环境优化（更新web.xml，创建java和resources目录）\n\n编写Servlet程序\n\n编写普通类\n实现Servlet接口，这里直接继承HttpServlet\n\n\n\nServlet接口→GenericServlet→HttpServlet→自己写的Servlet类\n\n编写Servlet映射\n\n配置Tomcat\n\n\n一个Servlet可以映射到多个路径\n默认请求路径\n&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;error&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n映射路径可以自定义后缀（*.do）\n注意：*前不能加路径！\n具体指定的映射路径优先级更高\n3.1 ServletContextweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用\n\n共享数据\n//servlet1设置共享数据ServletContext context = this.getServletContext();String username = &quot;XXX&quot;;context.setAttribute(&quot;username&quot;,username);//servlet2读取共享数据ServletContext context = this.getServletContext();String username = (String) context.getAttribute(&quot;username&quot;);\n\n获取初始化参数\n&lt;context-param&gt;    &lt;param-name&gt;url&lt;/param-name&gt;    &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;  &lt;/context-param&gt;\n\nServletContext context = this.getServletContext();String url = context.getInitParameter(&quot;url&quot;);\n\n请求转发\nServletContext context = this.getServletContext();context.getRequestDispatcher(&quot;/xx&quot;).forward(req,resp);\n\n读取资源文件\nServletContext context = this.getServletContext();InputStream is = context.getResourceAsStream(&quot;/WEB-  INF/classes/db.properties&quot;);Properties prop = new Properties();prop.load(is);String user = prop.getProperty(&quot;username&quot;);\n\n\n\n3.2 ServletResponse\n发送数据\n\npublic ServletOutputStream getOutputStream() throws IOException;public PrintWriter getWriter() throws IOException;\n\n\n发送响应头\n\npublic void setCharacterEncoding(String charset);public void setContentLength(int len);public void setContentLengthLong(long len);public void setContentType(String type);public void setDateHeader(String name, long date);public void addDateHeader(String name, long date);public void setHeader(String name, String value);public void addHeader(String name, String value);public void setIntHeader(String name, int value);public void addIntHeader(String name, int value);\n\n\n响应状态码\n\n/**     * Status code (100) indicating the client can continue.     */    public static final int SC_CONTINUE = 100;    /**     * Status code (101) indicating the server is switching protocols     * according to Upgrade header.     */    public static final int SC_SWITCHING_PROTOCOLS = 101;    /**     * Status code (200) indicating the request succeeded normally.     */    public static final int SC_OK = 200;    /**     * Status code (201) indicating the request succeeded and created     * a new resource on the server.     */    public static final int SC_CREATED = 201;    /**     * Status code (202) indicating that a request was accepted for     * processing, but was not completed.     */    public static final int SC_ACCEPTED = 202;    /**     * Status code (203) indicating that the meta information presented     * by the client did not originate from the server.     */    public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;    /**     * Status code (204) indicating that the request succeeded but that     * there was no new information to return.     */    public static final int SC_NO_CONTENT = 204;    /**     * Status code (205) indicating that the agent &lt;em&gt;SHOULD&lt;/em&gt; reset     * the document view which caused the request to be sent.     */    public static final int SC_RESET_CONTENT = 205;    /**     * Status code (206) indicating that the server has fulfilled     * the partial GET request for the resource.     */    public static final int SC_PARTIAL_CONTENT = 206;    /**     * Status code (300) indicating that the requested resource     * corresponds to any one of a set of representations, each with     * its own specific location.     */    public static final int SC_MULTIPLE_CHOICES = 300;    /**     * Status code (301) indicating that the resource has permanently     * moved to a new location, and that future references should use a     * new URI with their requests.     */    public static final int SC_MOVED_PERMANENTLY = 301;    /**     * Status code (302) indicating that the resource has temporarily     * moved to another location, but that future references should     * still use the original URI to access the resource.     *     * This definition is being retained for backwards compatibility.     * SC_FOUND is now the preferred definition.     */    public static final int SC_MOVED_TEMPORARILY = 302;    /**    * Status code (302) indicating that the resource reside    * temporarily under a different URI. Since the redirection might    * be altered on occasion, the client should continue to use the    * Request-URI for future requests.(HTTP/1.1) To represent the    * status code (302), it is recommended to use this variable.    */    public static final int SC_FOUND = 302;    /**     * Status code (303) indicating that the response to the request     * can be found under a different URI.     */    public static final int SC_SEE_OTHER = 303;    /**     * Status code (304) indicating that a conditional GET operation     * found that the resource was available and not modified.     */    public static final int SC_NOT_MODIFIED = 304;    /**     * Status code (305) indicating that the requested resource     * &lt;em&gt;MUST&lt;/em&gt; be accessed through the proxy given by the     * &lt;code&gt;&lt;em&gt;Location&lt;/em&gt;&lt;/code&gt; field.     */    public static final int SC_USE_PROXY = 305;     /**     * Status code (307) indicating that the requested resource      * resides temporarily under a different URI. The temporary URI     * &lt;em&gt;SHOULD&lt;/em&gt; be given by the &lt;code&gt;&lt;em&gt;Location&lt;/em&gt;&lt;/code&gt;      * field in the response.     */    public static final int SC_TEMPORARY_REDIRECT = 307;    /**     * Status code (400) indicating the request sent by the client was     * syntactically incorrect.     */    public static final int SC_BAD_REQUEST = 400;    /**     * Status code (401) indicating that the request requires HTTP     * authentication.     */    public static final int SC_UNAUTHORIZED = 401;    /**     * Status code (402) reserved for future use.     */    public static final int SC_PAYMENT_REQUIRED = 402;    /**     * Status code (403) indicating the server understood the request     * but refused to fulfill it.     */    public static final int SC_FORBIDDEN = 403;    /**     * Status code (404) indicating that the requested resource is not     * available.     */    public static final int SC_NOT_FOUND = 404;    /**     * Status code (405) indicating that the method specified in the     * &lt;code&gt;&lt;em&gt;Request-Line&lt;/em&gt;&lt;/code&gt; is not allowed for the resource     * identified by the &lt;code&gt;&lt;em&gt;Request-URI&lt;/em&gt;&lt;/code&gt;.     */    public static final int SC_METHOD_NOT_ALLOWED = 405;    /**     * Status code (406) indicating that the resource identified by the     * request is only capable of generating response entities which have     * content characteristics not acceptable according to the accept     * headers sent in the request.     */    public static final int SC_NOT_ACCEPTABLE = 406;    /**     * Status code (407) indicating that the client &lt;em&gt;MUST&lt;/em&gt; first     * authenticate itself with the proxy.     */    public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;    /**     * Status code (408) indicating that the client did not produce a     * request within the time that the server was prepared to wait.     */    public static final int SC_REQUEST_TIMEOUT = 408;    /**     * Status code (409) indicating that the request could not be     * completed due to a conflict with the current state of the     * resource.     */    public static final int SC_CONFLICT = 409;    /**     * Status code (410) indicating that the resource is no longer     * available at the server and no forwarding address is known.     * This condition &lt;em&gt;SHOULD&lt;/em&gt; be considered permanent.     */    public static final int SC_GONE = 410;    /**     * Status code (411) indicating that the request cannot be handled     * without a defined &lt;code&gt;&lt;em&gt;Content-Length&lt;/em&gt;&lt;/code&gt;.     */    public static final int SC_LENGTH_REQUIRED = 411;    /**     * Status code (412) indicating that the precondition given in one     * or more of the request-header fields evaluated to false when it     * was tested on the server.     */    public static final int SC_PRECONDITION_FAILED = 412;    /**     * Status code (413) indicating that the server is refusing to process     * the request because the request entity is larger than the server is     * willing or able to process.     */    public static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;    /**     * Status code (414) indicating that the server is refusing to service     * the request because the &lt;code&gt;&lt;em&gt;Request-URI&lt;/em&gt;&lt;/code&gt; is longer     * than the server is willing to interpret.     */    public static final int SC_REQUEST_URI_TOO_LONG = 414;    /**     * Status code (415) indicating that the server is refusing to service     * the request because the entity of the request is in a format not     * supported by the requested resource for the requested method.     */    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;    /**     * Status code (416) indicating that the server cannot serve the     * requested byte range.     */    public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;    /**     * Status code (417) indicating that the server could not meet the     * expectation given in the Expect request header.     */    public static final int SC_EXPECTATION_FAILED = 417;    /**     * Status code (500) indicating an error inside the HTTP server     * which prevented it from fulfilling the request.     */    public static final int SC_INTERNAL_SERVER_ERROR = 500;    /**     * Status code (501) indicating the HTTP server does not support     * the functionality needed to fulfill the request.     */    public static final int SC_NOT_IMPLEMENTED = 501;    /**     * Status code (502) indicating that the HTTP server received an     * invalid response from a server it consulted when acting as a     * proxy or gateway.     */    public static final int SC_BAD_GATEWAY = 502;    /**     * Status code (503) indicating that the HTTP server is     * temporarily overloaded, and unable to handle the request.     */    public static final int SC_SERVICE_UNAVAILABLE = 503;    /**     * Status code (504) indicating that the server did not receive     * a timely response from the upstream server while acting as     * a gateway or proxy.     */    public static final int SC_GATEWAY_TIMEOUT = 504;    /**     * Status code (505) indicating that the server does not support     * or refuses to support the HTTP protocol version that was used     * in the request message.     */    public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\n\n应用：\n\n浏览器输出消息\n\n下载文件\nimport javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class FileServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //下载步骤：        //1.获取下载文件的路径        //String realPath = this.getServletContext().getRealPath(&quot;/1.png&quot;);        String realPath = &quot;C:\\\\Users\\\\zhomg\\\\Documents\\\\Java\\\\JavaEE\\\\javaweb-02-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png&quot;;        System.out.println(&quot;下载文件的路径：&quot;+realPath);        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;)+1); //获取下载文件名        //2.设置浏览器响应头        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));        //3.获取下载文件的输入流        FileInputStream in = new FileInputStream(realPath);        //4.创建缓冲区和输出流        int len = 0;        byte[] buffer = new byte[1024];        ServletOutputStream out = resp.getOutputStream();        //5.读取输入流并存储到缓冲区，使用输出流将缓冲区中的数据输出到客户端        while((len=in.read(buffer))!=-1)&#123;            out.write(buffer,0,len);        &#125;        in.close();        out.close();    &#125;\n\n验证码\n@Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //让浏览器自动刷新        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);        //在内存中创建一个图片        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);        //得到图片，Graphics对象相当于画笔        Graphics2D g = (Graphics2D)image.getGraphics();        //设置图片的背景颜色        g.setColor(Color.WHITE);        g.fillRect(0,0,45,20);        //给图片写数据        g.setColor(Color.BLUE);        g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD,20));        g.drawString(makeNum(),0,20);        //设置浏览器打开方式为图片        resp.setContentType(&quot;image/jpeg&quot;);        //关闭浏览器缓存        resp.setDateHeader(&quot;expires&quot;,-1);        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);        //把图片写给浏览器        ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream());    &#125;    private String makeNum()&#123;        Random random = new Random();        String num = random.nextInt(10000)+&quot;&quot;;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 4-num.length(); i++) &#123;            sb.append(&quot;0&quot;);        &#125;        num = sb.toString() + num;        return num;    &#125;\n\n重定向\n\n\nA→B，B通知A访问另一个Web资源C\npublic void sendRedirect(String location) throws IOException;/*相当于resp.setHeader(&quot;Location&quot;,/r/success.jsp);resp.setStatus(302);*/\n\n重定向和转发的区别\n相同点\n\n页面都会实现跳转\n\n不同点\n\n请求转发时，URL不会产生变化 307\n重定向时，URL会产生变化 302\n\n&lt;form action=&quot;$&#123;pageContext.request.getContextPath&#125;/login&quot; method=&quot;get&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    ...    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n\n\n3.3 ServletRequestRequest是用户（客户端）的请求，可以获取客户端的各种信息\n应用：\n\n获取前端传递的参数\n\nStirng username = req.getParameter(&quot;username&quot;);\n\n\n请求转发\n\n//这里的/代表当前web应用根目录req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);\n\n4 Cookie &amp; Session4.1 Cookie\n从请求中拿到cookie信息\n服务器响应给客户端cookie\n\nCookie[] cookies = req.getCookies();cookie.getName(); //获得cookie中的keycookie.getValue(); new Cookie(&quot;lastLoginTime&quot;,System.currentTimeMills()+&quot;&quot;);cookie.setMaxAge(24*60*60);//cookie.setMaxAge(0);将cookie设置过期resp.addCookie(cookie); //响应给客户端一个cookie\n\nCookie只能存放一个大小限制为4KB的字符串信息\n编码解码：\nURLEncoder.encode(&quot;中文&quot;，&quot;utf-8&quot;);URLDecoder.decode(copkie.getValue(),&quot;utf-8&quot;);\n\n4.2 SessionHttpSession session = req.getSession();session.removeAttribute(&quot;name&quot;);//手动注销Sessionsession.invalidate();\n\n会话自动过期：web.xml配置\n&lt;!--设置session默认失效的时间--&gt;&lt;session-config&gt;\t&lt;!--15分钟后session自动失效--&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;\n\n5 JSPJSP执行原理：\ntomcat服务器中有一个work目录；\nIDEA中使用tomcat的会在IDEA中产生一个work目录\n\n发现页面转变成了Java程序\n\n浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet\nJSP最终也会被转换为一个Java类\nJSP本质上就是一个Servlet\n//初始化public void _jspInit() &#123;&#125;//销毁public void _jspDestroy() &#123;&#125;//JSPServicepublic void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)\n\n\n判断请求\n内置对象 \n\nfinal javax.servlet.jsp.PageContext pageContext;final javax.servlet.ServletContext application; //applicationContextfinal javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null;final java.lang.Object page = this; //当前页面javax.servlet.http.HttpServletRequest request;final javax.servlet.http.HttpServletResponse response;\n\n\n输出页面前增加的代码\n\nresponse.setContentType(&quot;text/html; charset=UTF-8&quot;);pageContext = _jspxFactory.getPageContext(this, request, response,null, false, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();out = pageContext.getOut();_jspx_out = out;\n\n可以在JSP页面中直接使用内置对象\nJSP基础语法\n\nJSP表达式&lt;%=(var/exp)%&gt;\n\nJSP脚本&lt;%(script)%&gt;\n\nJSP声明&lt;%!(statement)%&gt;\n\n\n区别：\nJSP声明会被编译到JSP生成的类中，而JSP表达式和脚本则会被生成到_jspService方法中\nJSP注释：&lt;%--注释--%&gt;，不会在客户端（浏览器）显示\nEL表达式：${var}\n5.1 JSP指令\npage指令\n\n&lt;%--自动生成--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;Java&quot; %&gt;&lt;%--导入jar包--%&gt;&lt;%@ page import=&quot;java.util.*&quot; %&gt;&lt;%--定制错误页面--%&gt;&lt;%@ page errorPage=&quot;error/500.jsp&quot; %&gt;\n\nweb.xml\n&lt;error-page&gt;\t&lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/error/404.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;\t&lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/error/500.jsp&lt;/location&gt;&lt;/error-page&gt;\n\n\ninclude指令\n\n&lt;%@include file=&quot;common/header.jsp&quot; %&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=&quot;common/footer.jsp&quot; %&gt;&lt;%--JSP标签--%&gt;&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;\n\n区别：\ninclude指令将三个页面的内容一并输出，本质是一个页面\ninclude标签是主页面调用两个子页面，本质还是三个页面\n作用域大小不同的内置对象\n&lt;%\t//底层→高层（作用域）：page→request→session→application\t//JVM：双亲委派机制\tpageContext.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一个页面中有效    request.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一次请求中有效    session.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一次会话中有效    application.setAttribute(&quot;name1&quot;,&quot;1&quot;); //servletContext,在打开服务器期间有效%&gt;\n\n双亲委派机制的作用：\n1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。\n拓展：请求转发\n&lt;%\tpageContext.forward(&quot;/index.jsp&quot;);\t//request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request,response);%&gt;\n\n5.2 JSP标签JSP标签\n&lt;jsp:forward page = &quot;/jsptag2.jsp&quot;&gt;\t&lt;jsp:param name = &quot;name&quot; value = &quot;xxx&quot;&gt;&lt;/jsp:param&gt;    &lt;jsp:param name = &quot;age&quot; value = &quot;18&quot;&gt;&lt;/jsp:param&gt;&lt;/jsp:forward&gt;\n\nJSTL标签→弥补HTML标签的不足\n使用jstl标签的maven依赖\n&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;\n\n核心标签\n&lt;%--引入JSTL核心标签库，才能使用JSTL标签--%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;\n\n\n格式化标签，SQL标签，XML标签\n6 JavaBeanJavaBean特定写法：\n\n必须要有一个无参构造\n属性必须私有化\n必须有对应的get/set方法\n\n一般用来和数据库字段做映射ORM\nORM：对象关系映射\n\n表→类\n字段→属性\n行→对象\n\n过滤器，文件上传，邮件发送\n7 MVC三层架构Model\n\n业务处理：业务逻辑（Service）\n数据持久层：CRUD（Dao）\n\nView\n\n展示数据\n提供链接发起Servlet请求（a, form, img…）\n\nController(Servlet)\n\n接收用户的请求：（req：请求参数、Session信息…）\n交给业务层处理相应的代码\n控制视图的跳转\n\n8 FilterFilter：过滤器，用来过滤网站的数据\n\n处理中文乱码\n登录验证\n\nFilter开发步骤：\n\n导包\n编写过滤器\n\nimport javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);    &#125;    /*    1.在过滤特定请求时，Filter所有代码都会执行    2.注意务必通过chain.doFilter让过滤器继续通行     */    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        request.setCharacterEncoding(&quot;utf-8&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        System.out.println(&quot;CharacterEncodingFilter执行前...&quot;);        chain.doFilter(request,response);        System.out.println(&quot;CharacterEncodingFilter执行后...&quot;);    &#125;    @Override    public void destroy() &#123;        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);    &#125;&#125;\n\n\nweb.xml配置Filter\n\n&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.zhg.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n9 Listener\n编写一个监听器（实现监听器的接口）\n\nimport javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class OnlineCounterListener implements HttpSessionListener &#123;    @Override    public void sessionCreated(HttpSessionEvent se) &#123;        ServletContext ctx = se.getSession().getServletContext();        Integer onlineCount = (Integer)ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count+1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;    @Override    public void sessionDestroyed(HttpSessionEvent se) &#123;        ServletContext ctx = se.getSession().getServletContext();        Integer onlineCount = (Integer)ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count-1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;&#125;\n\n\n在web.xml中注册监听器\n\n&lt;listener&gt;    &lt;listener-class&gt;com.zhg.listener.OnlineCounterListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n10 JDBC环境搭建\nmaven导入jar包\n&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n\n\n10.2 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n11 Ajax\nAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n$.ajax(&#123; \ttype: &quot;POST&quot;, \turl: &quot;$&#123;pageContext.request.contextPath&#125;/jsp/user.do&quot;,    dataType: &quot;json&quot;,    success:function(data)&#123;    \t...\t&#125;,    error:function(data)&#123;        ...    &#125;&#125;);\n\n11.1 JSON\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n使用阿里巴巴的fastjson.jar包\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;\n\nServlet中设置一个Map结果集\nMap&lt;String,String&gt; resultMap = new HashMap&lt;&gt;();...resp.setContentType(&quot;application/json&quot;);PrintWriter writer = resp.getWritter();// JSONArray 阿里巴巴的JSON工具类 → 转换格式// Map（[&quot;key1&quot;:&quot;value1&quot;]）→JSON（&#123;key:value&#125;）writter.write(JSONArray.toJSONString(resultMap));writer.flush();writer.close();\n\n12 Web项目开发用户请求数据流：前端页面（Ajax/表单提交）→Servlet→Service（处理事务）→Dao→JDBC→数据库\n12.1 上传文件实现文件上传需要jar包common-io，上传组件common-fileupload\n在页面中创建上传按钮\n&lt;form action=&quot;/upload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n上传文件处理代码（Servlet）\n// 判断上传文件是普通表单还是带文件的表单if(!ServletFileUpload.isMultipartContent(request))&#123;    return;&#125;// 创建上传文件的保存路径，建议保存在WEB-INF路径下，安全，用户无法直接访问上传的文件String uploadPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);File uploadFile = new File(uploadPath);if(!uploadFile.exists())&#123;    uploadFile.mkdir();&#125;// 临时路径，假如文件超过了预期的大小，就把这个文件放到一个临时文件中，过几天自动删除，或者提醒用户转存为永久String tmpPath = this.getServletContext().getRealPath(&quot;/WEB-INF/tmp&quot;);File tmpFile = new File(tmpPath);if(!tmpFile.exists())&#123;    tmpFile.mkdir();&#125;// 1.创建DiskFileItemFactory对象，处理文件上传路径或文件大小限制DiskFileItemFactory factory = new DiskFileItemFactory();// 通过这个工厂设置一个缓冲区，当上传文件大于缓冲区时，将其放到临时文件中factory.setSizeThreshold(1024*1024); // 缓存区大小为1Mfactory.setRepository(tmpFile);// 2.获取ServletFileUploadServletFileUpload upload = new ServletFileUpload(factory);// 监听文件上传进度upload.setProgressListener(new ProgressListener()&#123;    @Override    public void update(long pByteRead,long pContentLength,int pItem)&#123;        System.out.println(&quot;总大小：&quot;+pContentLength+&quot;已上传：&quot;+pBytesRead);    &#125;&#125;);upload.setHeaderEncoding(&quot;UTF-8&quot;);upload.setFileSizeMax(1024*1024*10); // 设置总共能上传10M文件// 3.解析前端请求，封装成FileItem对象List&lt;FileItem&gt; fileItems = upload.parseRequest(request);for(FileItem fileItem : fileItems)&#123;    if(fileItem.isFormField())&#123; //普通的表单        // getFieldName指的是前端表单控件的name        String name = fileItem.getFieldName();        String value = fileItem.getString(&quot;UTF-8&quot;);        System.out.println(name+&quot;:&quot;+value);    &#125;else&#123; //上传文件        String uploadFileName = fileItem.getName();        System.out.println(&quot;上传的文件名：&quot;+uploadFileName);        if(uploadFileName.trim().equals(&quot;&quot;)||uploadFileName==null)&#123;            continue;        &#125;        String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(/)+1);        String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(.)+1);        String uuidPath = UUID.randomUUID().toString();                String realPath = uploadPath+&quot;/&quot;+uuidPath;        File realPathFile = new File(realPath);        if(!realPathFile.exists())&#123;            realPathFile.mkdir();        &#125;        InputStream inputStream = fileItem.getInputStream();        FileOutputStream fos = new FileOutputStream(realPath+&quot;/&quot;+fileName);        byte[] buffer = new byte[1024*1024];        int len = 0;        while((len = inputStream.read(buffer)) != -1)&#123;            fos.write(buffer,0,len);        &#125;        fos.close();        inputStream.close();                msg = &quot;文件上传成功！&quot;;        fileItem.delete(); // 上传成功，清除临时文件    &#125;&#125;\n\nServletFileUpload负责上传得文件数据，并将表单中每个输入项封装成一个FileItem对象，在使用ServletFileUpload对象解析请求时需要DiskFileItemFactory对象（通过ServletFileUpload对象的构造方法或setFileItemFactory()方法设置ServletFileUpload对象的FileItemFactory属性）\n上传的注意事项：\n\n为保护服务器安全，上传文件应该放在外界无法直接访问的目录下（WEB-INF）\n为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名（时间戳，UUID，MD5，位运算）\n要限制上传文件的最大值\n可以限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法\n\n12.2 发送邮件协议：SMTP和POP3/IMAP、MIME\n当两台不同的服务器进行消息通讯时，是SMTP进行握手，A服务器发送邮件到B服务器，B服务器的SMTP会替本地用户接受外面发过来的邮件，然后POP3/IMAP去读取SMTP收取的邮件\nSMTP是邮局，POP3是快递员，快递员只会去邮局领取邮件，而不是直接去发件人手上直接拿，两个地区（邮箱服务器）邮件收发也是通过邮局（SMTP）来完成\n收发邮件步骤：\n\n用户A的邮箱为&#x78;&#120;&#x78;&#x40;&#113;&#113;&#x2e;&#x63;&#109;，通过foxmail客户端写好一封邮件点击发送，即提交到了QQ邮箱服务器，使用的是SMTP协议。\nQQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是qq邮箱，会直接存储到自己的存储空间，\n如果不是则会发送到指定邮箱服务器，使用的也是SMTP协议。163服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件\n用户B收到消息后，打开客户端访问163服务器（也可以自己敲命令直接访问），163服务器会去调用POP3服务\nPop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。\n将读取到的邮件返回给客户端软件\n\n用Java实现邮件收发，首先应该准备JavaMail API和Java Activation Framework（mail.jar, activation.jar）\nSession：定义整个程序所需程序环境信息（主机名、端口号、协议）\nMessage：邮件\nTransport（发送邮件）→Store（接收邮件）\nProperties prop = new Properties();prop.setProperty(&quot;mail.host&quot;,&quot;smtp.qq.com&quot;);prop.setProperty(&quot;mail.transport.protocol&quot;,&quot;smtp&quot;);prop.setProperty(&quot;mail.smtp.auth&quot;,true); // 需要验证用户名密码// QQ邮箱还需要设置SSL加密MailSSLSocketFactory sf = new MailSSLSocketFactory();sf.setTrustAllHosts(true);prop.put(&quot;mail.smtp.ssl.enable&quot;,&quot;true&quot;);prop.put(&quot;mail.smtp.ssl.socketFactory&quot;,sf);// 使用JavaMail发送邮件的5个步骤// 1.创建定义整个应用程序所需环境信息的Session对象// 只有QQ邮箱需要Session session = Session.getDefaultInstance(prop,new Authenticator()&#123;    public PasswordAuthentication getPasswordAuthentication()&#123;        // 发送人邮件用户名、授权码        return new PasswordAuthentication(&quot;xxxxx@qq.com&quot;,&quot;授权码&quot;); //授权码可以在QQ邮箱 设置 → 开启POP3/SMTP服务后获取    &#125;&#125;);//开启Session的debug模式，可以查看程序发送Email的运行状态session.setDebug(true);// 2.通过Session得到Transport对象Transport ts = session.getTransport();// 3.使用邮箱的用户名和授权码连接邮件服务器ts.connect(&quot;smtp.qq.com&quot;,&quot;xxxxx@qq.com&quot;,&quot;授权码&quot;)    // 4.创建邮件MimeMessage message = new MimeMessage(session);message.setFrom(new InternetAddress(&quot;xxxxx@qq.com&quot;)); // 指明发件人message.setRecipient(Message.RecipientType.To,new InternetAddress(&quot;yyyyy@qq.com&quot;)); // 指明收件人// 4.1.发送只含文本的简单邮件message.setSubject(&quot;只含文本的简单邮件&quot;);message.setContent(&quot;你好啊！&quot;,&quot;text/html;charset=UTF-8&quot;);// 4.2.发送带图片/附件的邮件message.setSubject(&quot;带图片的邮件&quot;);// 图片MimeBodyPart image = new MimeBodyPart();DataHandler dh = new DataHandler(new FileDataSource(&quot;src/resouces/xxx.jpg&quot;));image.setDataHandler(dh);image.setContentID(&quot;bz.jpg&quot;);// 文本MimeBodyPart text = new MimeBodyPart();text.setContent(&quot;这是一封带图片&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;的邮件&quot;,&quot;text/html;charset=UTF-8&quot;);// 附件MimeBodyPart attachment = new MieBodyPart();attachment.setDataHandler(new DataHandler(new FileDataSource(&quot;src/resources/1.txt&quot;)));attachment.setFileName(&quot;1.txt&quot;);// 拼装邮件正文内容MimeMultipart mm1 = new MimeMultipart();mm.addBodyPart(text);mm.addBodyPart(image);// MimeMultipart.subType:alternative(超文本) → related(内嵌资源) → mixed(附件)mm.setSubType(&quot;related&quot;); // 图片文本内嵌成功MimeBodyPart contextText = new MimeBodyPart();contentText.setContent(mm1);//拼接附件MimeMultipart allFile = new MimeMultipart();allFile.addBodyPart(attachment); allFile.addBodyPart(contentText);allFile.setSubType(&quot;mixed&quot;);// 设置到消息中，保存修改message.setContent(mm);message.saveChanges();   // 5.发送邮件ts.sendMessage(message,message.getAllRecipients());// 6.关闭连接ts.close();\n\n","tags":["Java","JavaWeb","Servlet","Session","Cookie","JSP"]},{"title":"LeetCode 57.插入区间","url":"/2020/11/04/LeetCode57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/","content":"题目描述：\n给出一个无重叠的 ，按照区间起始端点排序的区间列表。\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n示例1：\n输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]\n示例2：\n输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]\n思路：找出所有与新插入区间 newInterval = [left,right] 重叠的区间集合并将这些区间合并\n\n遍历 intervals 的区间 [li,ri] \n\n如果 ri &lt; left 或者 li &gt; right，说明 [li,ri] 与 newInterval不重叠，可直接将 [li,ri] 加入答案\n否则， [li,ri] 与 newInterval重叠，需要将 [li,ri] 与 newInterval合并\n\npublic int[][] insert(int[][] intervals, int[] newInterval) &#123;    int left = newInterval[0];    int right = newInterval[1];    boolean placed = false;    List&lt;int[]&gt; ansList = new ArrayList&lt;int[]&gt;();    for (int[] interval : intervals) &#123;        if (interval[0] &gt; right) &#123;            // 在插入区间的右侧且无交集            if (!placed) &#123;                ansList.add(new int[]&#123;left, right&#125;);                placed = true;                                &#125;            ansList.add(interval);        &#125; else if (interval[1] &lt; left) &#123;            // 在插入区间的左侧且无交集            ansList.add(interval);        &#125; else &#123;            // 与插入区间有交集，计算它们的并集            left = Math.min(left, interval[0]);            right = Math.max(right, interval[1]);        &#125;    &#125;    if (!placed) &#123;        ansList.add(new int[]&#123;left, right&#125;);    &#125;    int[][] ans = new int[ansList.size()][2];    for (int i = 0; i &lt; ansList.size(); ++i) &#123;        ans[i] = ansList.get(i);    &#125;    return ans;&#125;\n\n链接：https://leetcode-cn.com/problems/insert-interval\n类似题目：56.合并区间\n题目描述：\n给出一个区间的集合，请合并所有重叠的区间。\n示例1：\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]\n示例2：\n输入: intervals = [[1,4],[4,5]]输出: [[1,5]]\n思路：按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。\n\n然后将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间。如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，直接将这个区间加入数组 merged 的末尾；否则，需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。\npublic int[][] merge(int[][] intervals) &#123;    if (intervals.length == 0) &#123;        return new int[0][2];    &#125;    Arrays.sort(intervals, (int[] interval1, int[] interval2) -&gt; interval1[0] - interval2[0]);    List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;();    for (int i = 0; i &lt; intervals.length; ++i) &#123;        int L = intervals[i][0], R = intervals[i][1];        if (merged.size() == 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123;            merged.add(new int[]&#123;L, R&#125;);        &#125; else &#123;            merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);        &#125;    &#125;    return merged.toArray(new int[merged.size()][]);&#125;\n\n链接：https://leetcode-cn.com/problems/merge-intervals\n","tags":["算法","LeetCode","数组","排序"]},{"title":"LeetCode 1356.根据数字二进制下1的数目排序","url":"/2020/11/06/Leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/","content":"题目描述：\n给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。\n如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。\n请你返回排序后的数组。\n示例1：\n输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]\n示例2：\n输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]\n思路：调用系统自带的排序函数，改写一下排序规则即可\n统计数字二进制下1的数目：\n// 方法一int bitCount(int n) &#123;    int count = 0;    while (n &gt; 0) &#123;        if((n &amp; 1) == 1)  count++;        n &gt;&gt;= 1 ;    &#125;    return count;&#125;// 方法二int bitCount(int n) &#123;    int count = 0;    while (n != 0) &#123;        n &amp;= (n-1);        count++;    &#125;    return count;&#125;\n\n改写排序规则:\npublic int[] sortByBits(int[] arr) &#123;    int[] bit = new int[10001];    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    for (int x : arr) &#123;        list.add(x);        bit[x] = bitCount(x);    &#125;    Collections.sort(list, (Integer x,Integer y) -&gt; &#123;        if (bit[x] != bit[y]) &#123;            return bit[x] - bit[y];        &#125; else &#123;            return x - y;        &#125;    &#125;);    //return list.stream().mapToInt(Integer::intValue).toArray();    for (int i = 0; i &lt; arr.length; ++i) &#123;        arr[i] = list.get(i);    &#125;    return arr;&#125;public int bitCount(int n) &#123;    int count = 0;    while (n != 0) &#123;        n &amp;= (n-1);        count++;    &#125;    return count;&#125;\n\n\n链接：https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\n","tags":["算法","LeetCode","排序","位运算"]},{"title":"Java优先级队列（PriorityQueue）","url":"/2020/11/10/Java%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88PriorityQueue%EF%BC%89/","content":"PriorityQueue，即优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。\nJava中PriorityQueue实现了Queue接口，不允许放入null元素以及不可比较的对象（没有实现Comparable接口的对象）；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆。PriorityQueue 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。\n用法示例：\npublic class App &#123;    public static void main(String[] args) &#123;        //通过改造器指定排序规则        PriorityQueue&lt;Student&gt; q = new PriorityQueue&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;            public int compare(Student o1, Student o2) &#123;                //按照分数低到高，分数相等按名字                if(o1.getScore() == o2.getScore())&#123;                    return o1.getName().compareTo(o2.getName());                &#125;                return o1.getScore() - o2.getScore();            &#125;        &#125;);        //入列        q.offer(new Student(&quot;dafei&quot;, 20));        q.offer(new Student(&quot;will&quot;, 17));        q.offer(new Student(&quot;setf&quot;, 30));        q.offer(new Student(&quot;bunny&quot;, 20));        //出列        System.out.println(q.poll());  //Student&#123;name=&#x27;will&#x27;, score=17&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;bunny&#x27;, score=20&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;dafei&#x27;, score=20&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;setf&#x27;, score=30&#125;    &#125;&#125;\n\nLeetCode相关题目：\nLeetCode 347.前K个高频元素\n题目描述：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\nclass Solution &#123;    public int[] topKFrequent(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; occurrences = new HashMap&lt;Integer, Integer&gt;();        for (int num : nums) &#123;            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);        &#125;        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] m, int[] n) &#123;                return m[1] - n[1];            &#125;        &#125;);        for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;            int num = entry.getKey(), count = entry.getValue();            if (queue.size() == k) &#123;                if (queue.peek()[1] &lt; count) &#123;                    queue.poll();                    queue.offer(new int[]&#123;num, count&#125;);                &#125;            &#125; else &#123;                queue.offer(new int[]&#123;num, count&#125;);            &#125;        &#125;        int[] ret = new int[k];        for (int i = 0; i &lt; k; ++i) &#123;            ret[i] = queue.poll()[0];        &#125;        return ret;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/top-k-frequent-elements\nLeetCode 973.最接近原点的K的点\n题目描述：我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。\nclass Solution &#123;    public int[][] kClosest(int[][] points, int K) &#123;        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] array1, int[] array2) &#123;                return array2[0] - array1[0];            &#125;        &#125;);        for (int i = 0; i &lt; K; ++i) &#123;            pq.offer(new int[]&#123;points[i][0] * points[i][0] + points[i][1] * points[i][1], i&#125;);        &#125;        int n = points.length;        for (int i = K; i &lt; n; ++i) &#123;            int dist = points[i][0] * points[i][0] + points[i][1] * points[i][1];            if (dist &lt; pq.peek()[0]) &#123;                pq.poll();                pq.offer(new int[]&#123;dist, i&#125;);            &#125;        &#125;        int[][] ans = new int[K][2];        for (int i = 0; i &lt; K; ++i) &#123;            ans[i] = points[pq.poll()[1]];        &#125;        return ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/k-closest-points-to-origin/\n","tags":["算法","LeetCode","Java","JavaSE","数据结构"]},{"title":"Mybatis教程","url":"/2020/11/14/Mybatis%E6%95%99%E7%A8%8B/","content":"Mybatis教程官方文档：https://mybatis.org/mybatis-3/zh/index.html\n1 简介\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n获取方式：\n\nMaven\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.3&lt;/version&gt;&lt;/dependency&gt;\n\nGithub：https://github.com/mybatis/mybatis-3/tree/master/src/site\n\n\n数据持久化就是将程序的数据在持久状态和瞬时状态转化的过程（内存：断电即失）\nMybatis框架简化JDBC代码操作，sql与java代码分离\n2 编写Mybatis程序思路：搭建环境→导入Mybatis→编写代码→测试\n\n搭建环境\n创建数据库→新建maven项目（删除src目录）→导入maven依赖\n&lt;dependencies&gt;        &lt;!--mysql驱动--&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--junit--&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建一个模块\n编写mybatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1031&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n编写mybatis工具类\nimport org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory → sqlSessionpublic class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static&#123;        try &#123;            // 使用Mybatis首先获取sqlSessionFactory对象            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。    // 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n编写代码\n\n实体类\n\n// 实体类public class User &#123;    private int id;    private String name;    private String pwd;    public User() &#123;    &#125;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\nDao接口\n\nimport com.zhg.pojo.User;import java.util.List;public interface UserDao &#123;    List&lt;User&gt; getUserList();&#125;\n\n\n接口实现类（UserDaoImpl.java → UserMapper.xml）\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.zhg.dao.UserDao&quot;&gt;    &lt;!--select查询语句--&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.zhg.pojo.User&quot;&gt;    select * from mybatis.user;  &lt;/select&gt;&lt;/mapper&gt;\n\n\njunit测试\n\nimport com.zhg.pojo.User;import com.zhg.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123;    @Test    public void test()&#123;        // 第一步：获得SqlSession对象        SqlSession sqlSession = MybatisUtils.getSqlSession();        // 方式一：getMapper        UserDao userDao = sqlSession.getMapper(UserDao.class);        List&lt;User&gt; userList = userDao.getUserList();//      // 方式二：不推荐//        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.zhg.dao.UserDao.getUserList&quot;);        for (User user : userList) &#123;            System.out.println(user);        &#125;        // 关闭SqlSession        sqlSession.close();    &#125;&#125;\n\n可能遇到的问题：\n\n配置文件没有注册\n绑定接口错误\n方法名不对\n返回类型不对\nMaven导出资源问题\n\n注意点：\norg.apache.ibatis.binding.BindingException\njunit测试\n\n\n3 CRUDnamespace（命名空间）中绑定的包名与Dao/Mapper接口名要一致\nselect查询语句：\n\nid：namespace绑定接口中的方法名\n\nresultType：SQL语句执行的返回类型\n\nparameterType：参数类型\n\nMap：#{key}\n类：#{field}\n基本类型：直接取到\n\n多个参数用Map或注解\n\n\nUserMapper.xml\n&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zhg.pojo.User&quot;&gt;    select * from user where id = #&#123;id&#125;;&lt;/select&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.zhg.pojo.User&quot;&gt;    insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt;\n\njunit测试\nSqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User user = userMapper.getUserById(1);System.out.println(user);int count = userMapper.addUser(new User(4,&quot;XXX&quot;,&quot;111111&quot;));if(count &gt; 0)&#123;\tSystem.out.println(&quot;插入成功！&quot;);&#125;// 更新(增删改)数据库数据需要提交事务！sqlSession.commit();\n\n4 配置解析4.1 核心配置文件mybatis-config.xml\nconfiguration（配置）\n\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\n\n\n\n\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n\n\n环境配置（environments）\nMybatis可以配置多个环境，每个SQLSessionFactory实例只能选择一种环境。\nMybatis的默认事务管理器是JDBC，默认数据源类型为POOLED。\n\n属性（properties）\n可以通过properties属性实现引用配置文件（db.properties）\n\n这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。\n\n编写配置文件（db.properties）\ndriver = com.mysql.cj.jdbc.Driverurl = jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=trueusername = rootpassword = 1031\n\n核心配置文件中引入外部配置文件（优先使用）\n&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;1031&quot;/&gt;&lt;/properties&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;\n\n类型别名（typeAliases）\n\n类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。\n\n mybatis-config.xml\n &lt;typeAliases&gt;    &lt;!--可以给实体类起别名--&gt;    &lt;typeAlias type=&quot;com.zhg.pojo.User&quot; alias=&quot;User&quot;/&gt;    &lt;!--扫描包，默认别名为类名（首字母小写）--&gt;    &lt;package name=&quot;com.zhg.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\nUserMapper.xml\n &lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;    select * from user;&lt;/select&gt;\n\n可以在实体类前加注解@Alias(“XXX”)起别名\n\n设置（settings）\n\n\n\n\n\n设置名\n描述\n有效值\n默认值\n\n\n\ncacheEnabled\n全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。\ntrue | false\ntrue\n\n\nlazyLoadingEnabled\n延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。\ntrue | false\nfalse\n\n\nmapUnderscoreToCamelCase\n是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。\ntrue | false\nfalse\n\n\nlogImpl\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\n未设置\n\n\n\n其他配置\n\n类型处理器（typeHandlers）\n对象工厂（objectFactory）\nplugins插件\nmybatis-generator-core\nmybatis-plus\n通用mapper\n\n\n\n\n映射器（mappers）\n&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;com/zhg/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;com.zhg.dao.UserMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;com.zhg.dao&quot;/&gt;&lt;/mappers&gt;\n\n注意点：\n\n接口和Mapper配置文件必须同名\n接口和Mapper配置文件必须在同一包下\n\n\n\n4.2 生命周期和作用域生命周期和作用域错误的使用会导致非常严重的并发问题\nSqlSessionFactoryBuilder：一旦创建SqlSessionFactory就不在需要\nSqlSessionFactory（线程池）：一旦被创建就应该在运行期间一直存在\n5 结果映射解决实体类属性名和数据库表字段名不一致的问题\nUserMapper.xml\n&lt;!--结果集映射--&gt;&lt;resultMap id = &quot;userResultMap&quot; type = &quot;User&quot;&gt;\t&lt;!--column对应数据库中的字段，property对应实体类中的属性--&gt;    &lt;!--    &lt;result column = &quot;id&quot; property = &quot;id&quot;/&gt;    &lt;result column = &quot;name&quot; property = &quot;name&quot;/&gt;\t--&gt;\t&lt;result column = &quot;pwd&quot; property = &quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    select * from user where id = #&#123;id&#125;;&lt;/select&gt;\n\n6 日志6.1 日志工厂通过在核心配置文件中的settings中设置logImpl的值来设定在Mybatis中所用日志的具体实现\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING \n &lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n\n6.2 LOG4J\nLog4j是Apache的一个开源项目，通过使用Log4j，我们可以\n\n控制日志信息输送的目的地是控制台、文件、GUI组件；\n控制每一条日志的输出格式；\n通过定义每一条日志信息的级别，更加细致地控制日志的生成过程；\n通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n\n\n导入log4j的jar包\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\nlog4j.properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/zhg.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n设置log4j为日志的实现\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt;\n\n\n\nlog4j的简单使用\n\n在使用log4j的类中，导入包org.apache.log4j.Logger\n\n日志对象，参数为当前类的class\nstatic Logger logger = Logger.getLogger(UserDaoTest.class);\n\n日志级别\nlogger.info(&quot;info&quot;);logger.debug(&quot;debug&quot;);logger.error(&quot;error&quot;);\n\n\n\n7 分页7.1 limit分页SELECT * FROM user LIMIT startIndex,pageSize;\n\n接口\n// 分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n\nMapper.xml\n&lt;select id = &quot;getUserBylimit&quot; parameterType = &quot;map&quot; resultMap = &quot;useMap&quot;&gt;    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;\n\n测试\n@Testpublic void getUserByLimit()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();    map.put(&quot;startIndex&quot;,1);    map.put(&quot;pageSize&quot;,2);        List&lt;User&gt; userList = mapper.getUserByLimit(map);    for(User user:userList)&#123;        System.out.println(user);    &#125;        sqlSession.close();&#125;\n\n\n\n7.2 RowBounds分页\n接口\n// 分页2List&lt;User&gt; getUserRowBounds();mapper.xml\n\n&lt;!--分页--&gt;&lt;select id = &quot;getUserByRowBounds&quot; resultMap = &quot;userMap&quot;&gt;    select * from mybatis.user&lt;/select&gt;\n\n测试\n@Testpublic void getUserByRowBounds()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();        // RowBounds实现    RowBounds rowBounds = new RowBounds(1,2);        // 通过Java代码层面实现分页    List&lt;User&gt; userList = sqlSession.selectList(&quot;com.zhg.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);    for(User user:userList)&#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n7.3 分页插件PageHelper：https://pagehelper.github.io/\n8 使用注解开发面向接口编程，根本原因：解耦，使定义与实现的分离\n\n在接口方法上添加注解\npublic interface UserMapper &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt; getUserList();&#125;\n\n在核心配置文件中绑定接口\n&lt;mappers&gt;    &lt;mapper class=&quot;com.zhg.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;\n\n测试\n@Testpublic void test()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getUserList();    for (User user : users) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n本质：反射机制实现\n底层：动态代理\n使用注解实现CRUD\n\n添加注解\n// 方法存在多个参数时，参数前必须加上注解@Param()@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User getUserById(@Param(&quot;id&quot;) int id);@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)int addUser(User user);\n\n测试\nSqlSession sqlSession = MybatisUtils.getSqlSession(); // sqlSessionFactory.openSession(true) 开启自动提交事务UserMapper mapper = sqlSession.getMapper(UserMapper.class);User user = mapper.getUserById(1);System.out.println(user);mapper.addUser(new User(5,&quot;Hello&quot;,&quot;123456&quot;));sqlSession.close();\n\n\n\n@Param()注解\n\n基本类型的参数或者String类型，需要加上\n引用类型不需要加\n如果只有一个基本类型，可以忽略，但建议加上\n\n9 Lombok\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n\n在IDEA中安装Lombok插件\n\n在项目中导入lombok的jar包\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;\n\n在实体类上加注解\n@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@varexperimental @var@UtilityClass\n\n常用注解：\n@Data：无参构造，get，set，toString，hashcode，equals\n@AllArgsConstructor：有参构造\n@NoArgsConstructor：无参构造\n@ToString\n@EqualsAndHashCode\n\n\n10 多对一处理数据库创建表，学生和老师是多对一的关系\nCREATE TABLE `teacher` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;); CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);\n\n学生实体类：\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    int id;    String name;    Teacher teacher;&#125;\n\n10.1 按照查询嵌套处理StudentMapper.xml\n&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;    select * from student;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;    &lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;teacher&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;teacher&quot; resultType=&quot;Teacher&quot;&gt;    select * from teacher where id = #&#123;id&#125;;&lt;/select&gt;\n\n10.2 按照结果嵌套处理StudentMapper.xml\n&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;    select s.id sid,s.name sname,t.name tname    from student s,teacher t    where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;\n\n11 一对多处理一个老师拥有多个学生\n老师实体类\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Teacher &#123;    int id;    String name;    List&lt;Student&gt; students;&#125;\n\n11.1 按照结果嵌套处理TeacherMapper.xml\n&lt;select id=&quot;getTeacher&quot; resultMap=&quot;Teacher&quot;&gt;    select s.id sid,s.name sname,t.id tid,t.name tname    from student s,teacher t    where s.tid = t.id and t.id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;Teacher&quot; type=&quot;Teacher&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;tid&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt;    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;sid&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n\n11.2 按照查询嵌套处理&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent&quot;&gt;    select * from teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;    &lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentsByTeacherId&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTeacherId&quot; resultType=&quot;Student&quot;&gt;    select * from student where tid = #&#123;tid&#125;;&lt;/select&gt;\n\n小结：\n\n关联 - association【多对一】\n集合 - collection【一对多】\njavaType &amp; ofType\njavaType：属性的类型\nofType：集合的泛型\n\n\n\n12 动态SQL动态SQL：根据不同条件生成不同的SQL语句\n\n动态 SQL 是 MyBatis 的强大特性之一。利用动态 SQL，可以彻底摆脱拼接 SQL 语句的痛苦。如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\n\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n创建数据库表blog\nCREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8\n\n创建实体类Blog\nimport lombok.Data;import java.util.Date;@Datapublic class Blog &#123;    String id;    String title;    String author;    Date createTime; // 属性名和字段名不一致    int views;&#125;\n\n属性名和字段名不一致，需要在核心配置文件中添加&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;，在**Mapper.xm文件的select语句中返回ResultType时，返回字段会自动转换成驼峰命名，与实体类中的属性相对应。\n12.1 条件查询与更新根据提交数据查询与更新博客\n&lt;!--if--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog where 1 = 1    &lt;if test=&quot;title != null&quot;&gt;        and title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;&lt;!--where--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;if test=&quot;title != null&quot;&gt;        \ttitle = #&#123;title&#125;    \t&lt;/if&gt;    \t&lt;if test=&quot;author != null&quot;&gt;        \tand author = #&#123;author&#125;    \t&lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!--choose,只执行一个分支--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;choose&gt;            &lt;when test = &quot;title != null&quot;&gt;                title = #&#123;title&#125;            &lt;/when&gt;            &lt;when test = &quot;author != null&quot;&gt;                author = #&#123;author&#125;            &lt;/when&gt;            &lt;otherwise&gt;                views = #&#123;views&#125;            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!--set--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot; &gt;    update blog    &lt;set&gt;        &lt;if test=&quot;title != null&quot;&gt;        \ttitle = #&#123;title&#125;    \t&lt;/if&gt;    \t&lt;if test=&quot;author != null&quot;&gt;        \tand author = #&#123;author&#125;    \t&lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;;&lt;/update&gt;\n\n12.2 SQL片段提取重复SQL语句，方便复用！\n&lt;sql id = &quot;if&quot;&gt;\t&lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;include refid = &quot;if&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;\n\n12.3 集合遍历查询多个特定条件的记录\n&lt;select id=&quot;queryBlog&quot;  parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\tSELECT * FROM blog    &lt;where&gt;        &lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;        \tid = #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n13 缓存13.1 简介缓存，即存在内存中的临时数据。将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上数据库查询，而是从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n缓存减少了和数据库的交互次数，减少系统开销，提高系统效率。\n经常查询且不经常改变的数据，可以使用缓存！\n13.2 Mybatis缓存MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 \n默认情况下，只启用了本地的会话缓存（一级缓存，SQLSession级别缓存），它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存（namespace级别缓存），只需要在SQL 映射文件中添加一行&lt;cache/&gt;。为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过Cache接口自定义二级缓存。\n一级缓存一级缓存也叫本地缓存：SqlSession\n与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要获取相同的数据，直接从缓存拿，不需要重新查询数据库。\n缓存失效的情况：\n\n增删改操作\n手动清理缓存sqlSession.clearCache()\n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，即获得连接到关闭连接这个时间段。\n二级缓存二级缓存也叫全局缓存：namespace\n一级缓存作用域太低了，所以诞生了二级缓存\n工作机制：\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中。如果当前会话关闭了，这个会话对应的一级缓存就没了。但我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中，新的会话中查询信息时可以从二级缓存中获取内容。\n步骤：\n\n开启全局缓存\n&lt;!--显式开启全局缓存--&gt;&lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;\n\n在要使用二级缓存的Mapper中开启\n&lt;cache  eviction=&quot;FIFO&quot;  flushInterval=&quot;60000&quot;  size=&quot;512&quot;  readOnly=&quot;true&quot;/&gt;\n\n\n\n问题：二级缓存配置中没有加上readOnly=&quot;true&quot;，出现异常Caused by: java.io.NotSerializableException:com.zhg.pojo.User\n解决：需要将实体类序列化！public class User implements Serializable&#123;...&#125;\n小结：只要开启了二级缓存，在同一个Mapper下就有效。所有数据都会先放在一级缓存中，只有当会话提交或关闭时，才会转存到二级缓存中。\n自定义缓存\nEhCache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存，Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器，缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。\n\n\n导入jar包\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n配置文件ehcache.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;         updateCheck=&quot;false&quot;&gt;    &lt;!--       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：       user.home – 用户主目录       user.dir  – 用户当前工作目录       java.io.tmpdir – 默认临时文件路径     --&gt;    &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot;/&gt;    &lt;!--       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。     --&gt;    &lt;!--      name:缓存名称。      maxElementsInMemory:缓存最大数目      maxElementsOnDisk：硬盘最大缓存个数。      eternal:对象是否永久有效，一但设置了，timeout将不起作用。      overflowToDisk:是否保存到磁盘，当系统当机时      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。      clearOnFlush：内存数量最大时是否清除。      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。      FIFO，first in first out，这个是大家最熟的，先进先出。      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。   --&gt;    &lt;defaultCache            eternal=&quot;false&quot;            maxElementsInMemory=&quot;10000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;259200&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;      &lt;cache            name=&quot;cloud_user&quot;            eternal=&quot;false&quot;            maxElementsInMemory=&quot;5000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;1800&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;  &lt;/ehcache&gt;\n\nMapper.xml中指定使用的缓存实现\n&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n\n\n\n商业项目中常使用Redis数据库（键值对）来做缓存！\n","tags":["Java","Mybatis","SSM框架"]},{"title":"LeetCode 1122.数组的相对排序","url":"/2020/11/14/LeetCode1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","content":"题目描述：\n给你两个数组，arr1 和 arr2，\narr2 中的元素各不相同arr2 中的每个元素都出现在 arr1 中对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。\n示例：\n输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19]\n提示：\narr1.length, arr2.length &lt;= 10000 &lt;= arr1[i], arr2[i] &lt;= 1000arr2 中的元素 arr2[i] 各不相同arr2 中的每个元素 arr2[i] 都出现在 arr1 中\n我的解法：\n思路：迭代两个数组，将数组arr1中出现在数组arr2的元素前置，再将未出现在数组arr2的元素按升序排列。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        int m = arr1.length, n = arr2.length;        int flag = 0;        for(int i = 0; i &lt; n; i++)&#123;            for(int j = 0; j &lt; m; j++)&#123;                if(arr1[j] == arr2[i])&#123;                    if(flag != j)&#123;                        int tmp = arr1[flag];                        arr1[flag] = arr1[j];                        arr1[j] = tmp;                     &#125;                    flag++;                &#125;            &#125;        &#125;        Arrays.sort(arr1,flag,m);        return arr1;    &#125;&#125;\n\n官方解法一：自定义排序\n思路：使用排序并自定义比较函数。对于比较函数的元素x和y有没有出现在数组arr2中分情况考虑。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for(int num : arr1) list.add(num);        for(int i = 0; i &lt; arr2.length; i++) map.put(arr2[i], i);        Collections.sort(list, (x, y) -&gt; &#123;            if(map.containsKey(x) || map.containsKey(y)) return map.getOrDefault(x, 1001) - map.getOrDefault(y, 1001); // arr2[i] &lt;= 1000            return x - y;        &#125;);        for(int i = 0; i &lt; arr1.length; i++) arr1[i] = list.get(i);        return arr1;    &#125;&#125;\n\n官方解法二：计数排序\n思路：构造数组记录值等于下标 i 出现在数组arr1中的频次frequency[i]，再遍历数组arr2，将遍历到的元素 x 加入答案 并将frequency[x]清零。最后再遍历数组frequency，将frequency[x]不为0的元素x加入答案。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        int upper = 0;        for (int x : arr1) &#123;            upper = Math.max(upper, x);        &#125;        int[] frequency = new int[upper + 1];        for (int x : arr1) &#123;            ++frequency[x];        &#125;        int[] ans = new int[arr1.length];        int index = 0;        for (int x : arr2) &#123;            for (int i = 0; i &lt; frequency[x]; ++i) &#123;                ans[index++] = x;            &#125;            frequency[x] = 0;        &#125;        for (int x = 0; x &lt;= upper; ++x) &#123;            for (int i = 0; i &lt; frequency[x]; ++i) &#123;                ans[index++] = x;            &#125;        &#125;        return ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/relative-sort-array\n","tags":["算法","LeetCode","数组","排序"]},{"title":"POI和EasyExcel","url":"/2020/11/15/POI%E5%92%8CEasyExcel/","content":"POI和EasyExcel应用场景：\n\n将数据导出为Excel表格\n将Excel表格数据录入到数据库\n\n操作Excel表格目前比较流行的是Apache POI和阿里巴巴的EasyExcel\nApache POI\nApache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。\n\n官网：http://poi.apache.org/\n基本功能：\nHSSF － 提供读写Microsoft Excel格式档案的功能。（03）XSSF － 提供读写Microsoft Excel OOXML格式档案的功能。（07）HWPF － 提供读写Microsoft Word格式档案的功能。HSLF － 提供读写Microsoft PowerPoint格式档案的功能。HDGF － 提供读写Microsoft Visio格式档案的功能。\n导入依赖\n&lt;!-- xls(03) --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi&lt;/artifactId&gt;    &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- xls(07) --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;    &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日期格式化工具 --&gt;&lt;!-- https://mvnrepository.com/artifact/joda-time/joda-time --&gt;&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.10.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- test --&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;\n\nPOI-Excel写工作簿 → 工作表 → 行 → 列\n03版本\n@Testpublic void testWrite03() throws IOException &#123;    // 1.创建一个工作簿    Workbook workbook = new HSSFWorkbook();    // 2.创建一个工作表    Sheet sheet = workbook.createSheet(&quot;打卡记录03&quot;);    // 3.创建一个行    // 第一行    Row row1 = sheet.createRow(0);    // 4.创建一个单元格    Cell cell11 = row1.createCell(0);    cell11.setCellValue(&quot;姓名&quot;);    Cell cell12 = row1.createCell(1);    cell12.setCellValue(&quot;XXX&quot;);    // 第二行    Row row2 = sheet.createRow(1);    // 4.创建一个单元格    Cell cell21 = row2.createCell(0);    cell21.setCellValue(&quot;打卡时间&quot;);    Cell cell22 = row2.createCell(1);    String time = new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;);    cell22.setCellValue(time);    // 生成一张表（IO流）    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;打卡记录03.xls&quot;);    // 输出    workbook.write(fileOutputStream);    // 关闭流    fileOutputStream.close();    System.out.println(&quot;打卡记录03.xls生成完毕！&quot;);&#125;\n\n07版本\n@Testpublic void testWrite07() throws IOException &#123;    // 1.创建一个工作簿    Workbook workbook = new XSSFWorkbook();    // 2.创建一个工作表    Sheet sheet = workbook.createSheet(&quot;打卡记录07&quot;);    // 3.创建一个行    // 第一行    Row row1 = sheet.createRow(0);    // 4.创建一个单元格    Cell cell11 = row1.createCell(0);    cell11.setCellValue(&quot;姓名&quot;);    Cell cell12 = row1.createCell(1);    cell12.setCellValue(&quot;XXX&quot;);    // 第二行    Row row2 = sheet.createRow(1);    // 4.创建一个单元格    Cell cell21 = row2.createCell(0);    cell21.setCellValue(&quot;打卡时间&quot;);    Cell cell22 = row2.createCell(1);    String time = new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;);    cell22.setCellValue(time);    // 生成一张表（IO流）    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;打卡记录07.xlsx&quot;);    // 输出    workbook.write(fileOutputStream);    // 关闭流    fileOutputStream.close();    System.out.println(&quot;打卡记录07.xlsx生成完毕！&quot;);&#125;\n\n\n03版的xls最多只能容纳65536行数据\n\n07版的xlsx则没有限制，但耗时长\n\n\n可以使用SXSSFWorkbook读写大数据量的Excel表格，且耗时比XSSFWorkbook短，不过在使用SXSSFWorkbook读写Excel表格时会生成临时文件，处理结束时需加上((SXSSFWorkbook) workbook).dispose()将其清理。\n官方解释：实现”BigGridDemo”策略的流式XSSFWorkbook版本允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。但是注意，如果广泛使用例如合并区域，注释这类功能，将可能消耗大量内存。\nPOI-Excel读03版本\n@Testpublic void testRead03() throws IOException &#123;    // 获取文件流    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;打卡记录03.xls&quot;);    // 1.创建一个工作簿    Workbook workbook = new HSSFWorkbook(fileInputStream);    // 2.得到表    Sheet sheet = workbook.getSheetAt(0);    // 3.得到行    Row row = sheet.getRow(1);    // 4.得到列    Cell cell = row.getCell(1);    // 读取值的时候一定要注意类型！    System.out.println(cell.getStringCellValue());    fileInputStream.close();&#125;\n\n07版本\n@Testpublic void testRead07() throws IOException &#123;    // 获取文件流    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;打卡记录07.xlsx&quot;);    // 1.创建一个工作簿    Workbook workbook = new XSSFWorkbook(fileInputStream);    // 2.得到表    Sheet sheet = workbook.getSheetAt(0);    // 3.得到行    Row row = sheet.getRow(1);    // 4.得到列    Cell cell = row.getCell(1);    // 读取值的时候一定要注意类型！    System.out.println(cell.getStringCellValue());    fileInputStream.close();&#125;\n\n读取不同类型的数据类型\n@Testpublic void testCellType() throws Exception&#123;    // 获取文件流，读取工作簿    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;明细表.xls&quot;);    Workbook workbook = new HSSFWorkbook(fileInputStream);    Sheet sheet = workbook.getSheetAt(0);    // 获取标题内容    Row rowTitle = sheet.getRow(0);    if(rowTitle!=null)&#123;        int cellCount = rowTitle.getPhysicalNumberOfCells();        for(int cellNum = 0; cellNum &lt; cellCount; cellNum++)&#123;            Cell cell = rowTitle.getCell(cellNum);            if(cell != null)&#123;                String cellValue = cell.getStringCellValue();                System.out.print(cellValue + &quot; | &quot;);            &#125;        &#125;        System.out.println();    &#125;    // 获取表中内容    int rowCount = sheet.getPhysicalNumberOfRows();    for(int rowNum = 1; rowNum &lt; rowCount; rowNum++)&#123;        Row rowData = sheet.getRow(rowNum);        if(rowData!=null)&#123;            int cellCount = rowTitle.getPhysicalNumberOfCells();            for(int cellNum = 0; cellNum &lt; cellCount; cellNum++)&#123;                System.out.print(&quot;[&quot;+(rowNum+1)+&quot;-&quot;+(cellNum+1)+&quot;] &quot;);                Cell cell = rowData.getCell(cellNum);                // 匹配列的数据类型                if(cell != null)&#123;                    int cellType = cell.getCellType();                    String cellValue = &quot;&quot;;                    switch(cellType)&#123;                        case HSSFCell.CELL_TYPE_STRING:                            System.out.print(&quot;String - &quot;);                            cellValue = cell.getStringCellValue();                            break;                        case HSSFCell.CELL_TYPE_BOOLEAN:                            System.out.print(&quot;Boolean - &quot;);                            cellValue = String.valueOf(cell.getBooleanCellValue());                            break;                        case HSSFCell.CELL_TYPE_BLANK:                            System.out.print(&quot;Blank&quot;);                            break;                        case HSSFCell.CELL_TYPE_NUMERIC:                            System.out.print(&quot;Numeric - &quot;);                            if(HSSFDateUtil.isCellDateFormatted(cell))&#123;                                System.out.print(&quot;Date - &quot;);                                Date date = cell.getDateCellValue();                                cellValue = new DateTime(date).toString(&quot;yyyy-MM-dd&quot;);                            &#125;else &#123;                                System.out.print(&quot;Number - &quot;);                                cell.setCellType(HSSFCell.CELL_TYPE_STRING); // 防止数字过长，转化为字符串类型                                cellValue = cell.toString();                            &#125;                            break;                        case HSSFCell.CELL_TYPE_ERROR:                            System.out.println(&quot;Error&quot;);                            break;                    &#125;                    System.out.println(cellValue);                &#125;            &#125;        &#125;    &#125;    fileInputStream.close();&#125;\n\n计算公式\n@Testpublic void testFormula() throws IOException &#123;    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;公式.xls&quot;);    Workbook workbook = new HSSFWorkbook(fileInputStream);    Sheet sheet = workbook.getSheetAt(0);    Row row = sheet.getRow(1);    Cell cell = row.getCell(1);    // 拿到计算公式eval    FormulaEvaluator FormulaEvaluator = new HSSFFormulaEvaluator((HSSFWorkbook)workbook);        // 输出单元格的内容    int cellType = cell.getCellType();    switch(cellType)&#123;        case Cell.CELL_TYPE_FORMULA:            String formula = cell.getCellFormula();            System.out.println(formula);            // 计算            CellValue evaluate = FormulaEvaluator.evaluate(cell);            String cellValue = evaluate.formatAsString();            System.out.println(cellValue);            break;    &#125;    fileInputStream.close();&#125;\n\nEasyExcel\nEasyExcel重写了POI对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。\n\n官网：https://github.com/alibaba/easyexcel/\nEasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行一行读取数据，逐个解析。\n\n官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n导入依赖\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;    &lt;version&gt;2.2.6&lt;/version&gt;&lt;/dependency&gt;\n\nEasyExcel操作写入操作：固定类格式进行写入\nhttps://www.yuque.com/easyexcel/doc/write\n读取操作：根据监听器设置规则进行读取\nhttps://www.yuque.com/easyexcel/doc/read\n","tags":["Java","Excel"]},{"title":"LeetCode 222.完全二叉树的节点个数","url":"/2020/11/24/LeetCode222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","content":"题目描述：\n给出一个完全二叉树，求出该树的节点个数。\n示例：\n输入: [1,2,3,4,5,6]输出: 6\n解法一：简单递归\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null)&#123;            return 0;        &#125;        return countNodes(root.left) + countNodes(root.right) + 1;    &#125;&#125;\n\n但是解法一考虑到完全二叉树的性质。\n解法二：二分查找+位运算\n思路：首先求出二叉树高度，再根据二叉树高度算出节点个数范围，二分查找范围内中间节点，根据位运算判断中间节点是否存在。\n\nclass Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125;        int level = 0;        TreeNode node = root;        while (node.left != null) &#123;            level++;            node = node.left;        &#125;        int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1; // 2^n 可以写成 1&lt;&lt;n        while (low &lt; high) &#123;            int mid = (high - low + 1) / 2 + low;            if (exists(root, level, mid)) &#123;                low = mid;            &#125; else &#123;                high = mid - 1;            &#125;        &#125;        return low;    &#125;    public boolean exists(TreeNode root, int level, int k) &#123;        int bits = 1 &lt;&lt; (level - 1);        TreeNode node = root;        while (node != null &amp;&amp; bits &gt; 0) &#123;            if ((bits &amp; k) == 0) &#123;                node = node.left;            &#125; else &#123;                node = node.right;            &#125;            bits &gt;&gt;= 1;        &#125;        return node != null;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/\n","tags":["算法","LeetCode","位运算","二叉树","二分查找"]},{"title":"Spring5教程","url":"/2020/11/24/Spring5%E6%95%99%E7%A8%8B/","content":"1 Spring框架简介雏形：interface21框架\n创始人：Rod Johnson\n目标：解决企业级应用开发的复杂性，简化Java开发。\n文档地址：https://docs.spring.io/spring-framework/docs/current/reference/html/core.htmlhttps://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/\n下载地址：https://repo.spring.io/release/org/springframework/spring/\nGitHub：https://github.com/spring-projects/spring-framework\n&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n优点：开源免费，轻量级，非入侵式，支持事务处理，Java框架整合\n最大特性：控制反转（IOC），面向切面编程（AOP）\n总结：Spring是一个轻量级的控制反转和面向切面编程的框架\nSpring七大模块：\n\nSpring Boot\n\n快速开发的脚手架\n基于Spring Boot可以快速开发单个微服务\n约定大于配置\n\nSpring Cloud\n\n基于Spring Boot实现的\n\n弊端：”配置地狱“\n2 IOC理论推导2.1 IOC原型问题：需要根据用户需求修改源代码\n解决方法：使用set实现动态值注入\nprivate UserDao userDao;// 利用set进行动态实现值的注入public void setUserDao(UserDao userDao)&#123;    this.userDao = userDao;&#125;\n\n变化：程序主动创建对象 → 被动接受对象\n2.2 IOC本质控制反转IoC是一种设计思想，DI（依赖注入）是实现IoC的一种方法。面向对象编程中，对象的创建与对象间的依赖关系完全编写在程序中，由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是获得依赖对象的方式反转了。\n采用XML方式配置Bean的时候，Bean的定义是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入。\n3 HelloSpring创建类\npublic class Hello &#123;    String str;    public String getStr() &#123;        return str;    &#125;    public void setStr(String str) &#123;        this.str = str;    &#125;    @Override    public String toString() &#123;        return &quot;Hello&#123;&quot; +                &quot;str=&#x27;&quot; + str + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nSpring配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--bean：对象 id：变量名 class：类 property：类的属性 value：属性的值（基本数据类型） ref：引用其他创建的bean--&gt;    &lt;bean id=&quot;hello&quot; class=&quot;com.zhg.pojo.Hello&quot;&gt;        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试\nimport com.zhg.pojo.Hello;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123;    public static void main(String[] args) &#123;        // 获取Spring的上下文对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Hello hello = (Hello) context.getBean(&quot;hello&quot;);        System.out.println(hello.toString());    &#125;&#125;\n\n总结：\n\nSpring容器可以创建对象并设置对象属性的值\n依赖注入是利用类的set方法实现的\n\n4 IOC创建对象的方式\n使用无参构造创建对象（默认）\n\n使用有参构造创建对象\n\n参数下标\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n参数类型\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n参数名\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n\n\n\n\n总结：在配置文件加载的时候，Spring容器中管理的对象就已经初始化了！\n5 Spring配置5.1 别名&lt;!--可以通过别名获取到对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;&gt;&lt;/alias&gt;\n\n5.2 bean的配置&lt;!--\tid：bean的唯一标识，相当于对象名\tclass：包名+类型\tname：也是别名，可以同时取多个别名--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; name=&quot;user2 u2,u3;u4&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n5.3 importimport一般用于团队开发使用，可以将多个配置文件导入合并为一个。\napplicationContext.xml\n&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt;\n\n6 依赖注入6.1 构造器注入上文已经说过（4 IOC创建对象的方式）\n6.2 Set方式注入依赖注入\n\n依赖：bean对象的创建依赖于容器\n注入：bean对象的所有属性由容器来注入\n\nStudent实体类\npublic class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbys;    private Map&lt;String,String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    ...&#125;\n\napplicationContext.xml\n&lt;bean id=&quot;address&quot; class=&quot;com.zhg.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;...&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.zhg.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt;    &lt;!--数组注入--&gt;    &lt;property name=&quot;books&quot;&gt;    \t&lt;array&gt;            &lt;value&gt;book1&lt;/value&gt;            &lt;value&gt;book2&lt;/value&gt;            &lt;value&gt;book3&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name=&quot;hobbys&quot;&gt;    \t&lt;list&gt;            &lt;value&gt;hobby1&lt;/value&gt;            &lt;value&gt;hobby2&lt;/value&gt;            &lt;value&gt;hobby3&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--Map注入--&gt;    &lt;property name=&quot;card&quot;&gt;    \t&lt;map&gt;            &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;games&quot;&gt;    \t&lt;set&gt;            &lt;value&gt;hobby1&lt;/value&gt;            &lt;value&gt;hobby2&lt;/value&gt;            &lt;value&gt;hobby3&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!--null值注入--&gt;    &lt;property name=&quot;wife&quot;&gt;    \t&lt;null&gt;&lt;/null&gt;    &lt;/property&gt;    &lt;!--属性注入--&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;        \t&lt;prop key=&quot;pk1&quot;&gt;pv1&lt;/prop&gt;        \t&lt;prop key=&quot;pk2&quot;&gt;pv2&lt;/prop&gt;        \t&lt;prop key=&quot;pk3&quot;&gt;pv3&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n6.3 其他方式注入p命名空间注入&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;    &lt;/bean&gt;    &lt;bean name=&quot;john-modern&quot;        class=&quot;com.example.Person&quot;        p:name=&quot;John Doe&quot;        p:spouse-ref=&quot;jane&quot;/&gt;    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nc命名空间注入&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;    &lt;!-- traditional declaration with optional argument names --&gt;    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;        &lt;constructor-arg name=&quot;email&quot; value=&quot;[email protected]&quot;/&gt;    &lt;/bean&gt;    &lt;!-- c-namespace declaration with argument names --&gt;    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;[email protected]&quot;/&gt;&lt;/beans&gt;\n\n注意点：p命名空间和c命名空间不能直接使用，需要导入xml约束\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n\n6.4 bean的作用域\n\n\nScope\nDescription\n\n\n\nsingleton\n(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.\n\n\nprototype\nScopes a single bean definition to any number of object instances.\n\n\nrequest\nScopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nsession\nScopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\napplication\nScopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nwebsocket\nScopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\n单例模式（默认）Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，每次获取到的对象都是同一个对象。\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;XXX&quot; scope=&quot;singleton&quot;/&gt;\n\n原型模式Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; scope=&quot;prototype&quot;/&gt;\n\n其他\n其余的request、session、application等只能在Web开发中使用！\n7 Bean的自动装配\n自动装配是使用spring满足bean依赖的一种方法\nspring会在应用上下文中为某个bean寻找其依赖的bean\n\nSpring中bean有三种装配机制，分别是：\n\n在xml中显式配置；\n在java中显式配置；\n隐式的bean发现机制和自动装配。\n\nbeans.xml显示配置\n&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n7.1 byName自动装配&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; autowire=&quot;byName&quot;&gt;   &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n当一个bean节点带有 autowire byName的属性时。\n\n将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。\n去spring容器中寻找是否有此字符串名称id的对象。\n如果有，就取出注入；如果没有，就报空指针异常。\n\n7.2 byType自动装配&lt;bean class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; autowire=&quot;byType&quot;&gt;   &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n使用autowire byType需要保证：同一类型的对象，在spring容器中唯一！\n7.3 注解自动装配jdk1.5开始支持注解，spring2.5开始全面支持注解。\n准备工作：利用注解的方式注入属性。\n\n在spring配置文件中引入context文件头\n\n开启属性注解支持！\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n@Autowired\n@Autowired是按类型自动转配的，不支持id匹配；\n\n可以直接在类的属性名上使用，也可以在set方法上使用；\n\n可以不写set方法；\n\n需要导入spring-aop的包！\n\n\n@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat;\n\n@Qualifier\n@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配；\n@Qualifier不能单独使用。\n\nbeans.xml\n&lt;bean id=&quot;dog1&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;/&gt;\n\n实体类属性上添加注解\npublic class User &#123;\t@Autowired    @Qualifier(value = &quot;cat2&quot;)    private Cat cat;    @Autowired    @Qualifier(value = &quot;dog2&quot;)    private Dog dog;&#125;\n\n@Resource\n@Resource如有指定的name属性，先按该属性进行byName方式查找装配；\n其次再进行默认的byName方式进行装配；\n如果以上都不成功，则按byType的方式自动装配。\n都不成功，则报异常。\n\nbeans.xml\n&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;/&gt;\n\n实体类属性上添加注解\npublic class User &#123;   //如果允许对象为null，设置required = false,默认为true   @Resource(name = &quot;cat2&quot;)   private Cat cat;   @Resource   private Dog dog;   private String str;&#125;\n\n小结\n@Autowired与@Resource异同：\n\n@Autowired与@Resource都可以用来装配bean。都可以写在属性上，或写在setter方法上。\n\n@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n\n@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n\n\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n8 使用注解开发在spring4之后，想要使用注解形式，必须得要引入aop的包\n；在配置文件当中，还得要引入一个context约束。\n\nbean的实现\nbeans.xml配置扫描哪些包下的注解\n&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.zhg.pojo&quot;/&gt;\n\n在指定包下编写类，增加注解\n@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;   public String name = &quot;XXX&quot;;&#125;\n\n属性注入\n可以不用提供set方法，直接在直接名上添加@Value(“值”)\n@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;   @Value(&quot;XXX&quot;)   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;   public String name;&#125;\n\n如果提供了set方法，也可在set方法上添加@Value(“值”)\n\n衍生注解\n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。写上这些注解，就相当于将这个类交给Spring管理装配了！\n\n@Controller：web层\n@Service：service层\n@Repository：dao层\n\n\n自动装配\n@AutoWired，@Qualified，@Resource，详见上文。\n\n作用域\n@Scope(“singleton/prototype”)\n\n\n小结\nXML与注解比较\n\nXML可以适用任何场景 ，结构清晰，维护方便\n注解不是自己提供的类使用不了，开发简单方便\n\nxml与注解整合开发 （推荐最佳实践）\n\nxml管理bean\n注解完成属性注入\n使用过程中， 可以不用扫描，扫描是为了类上的注解\n\n&lt;context:annotation-config/&gt;作用：\n\n进行注解驱动注册，从而使注解生效\n用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册\n如果不扫描包，就需要手动配置bean\n如果不加注解驱动，则注入的值为null！\n\n基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。\nDog实体类\n@Component  //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123;   public String name = &quot;dog&quot;;&#125;\n\nMyConfig配置类\n@Configuration  //代表这是一个配置类public class MyConfig &#123;   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！   public Dog dog()&#123;       return new Dog();  &#125;&#125;\n\n测试\n@Testpublic void test()&#123;   ApplicationContext applicationContext =           new AnnotationConfigApplicationContext(MyConfig.class);   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);   System.out.println(dog.name);&#125;\n\n9 代理模式代理模式是Spring AOP的底层\n代理模式的分类：\n\n静态代理\n动态代理\n\n9.1 静态代理角色分析：\n\n抽象角色：一般使用接口或抽象类来解决\n真实角色：被代理的角色\n代理角色：代理真实角色，一般会做一些附属操作\n客户：访问代理对象的人\n\n代理模式的好处：\n\n可以使真实角色的操作更加纯粹，不用关注一些公共的业务\n公共业务交给代理角色，实现了业务的分工\n公共业务发生扩展的时候，方便集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低。\n\n9.2 动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是直接写好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口——JDK动态代理\n基于类：cglib\nJava字节码实现：JAVAssist\n\n\n\n需要了解两个类：Proxy，InvocationHandler\n【InvocationHandler：调用处理程序】\nInvocationHandler是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。\nObject invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。\n\n【Proxy  : 代理】\nProxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理对象的超类。\n//生成代理类//public static Object newProxyInstance(Classloader loader,类&lt;&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException//loader - 类加载器来定义代理类//interfaces - 代理类实现的接口列表//h - 调度方法调用的调用处理程序public Object getProxy()&#123;   return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);&#125;\n\n代码实现：\nRent - 抽象角色\n//抽象角色：租房public interface Rent &#123;   public void rent();&#125;\n\nHost  - 真实角色\n//真实角色：房东，房东要出租房子public class Host implements Rent&#123;   public void rent() &#123;       System.out.println(&quot;房屋出租&quot;);  &#125;&#125;\n\nProxyInvocationHandler - 代理角色\npublic class ProxyInvocationHandler implements InvocationHandler &#123;   private Rent rent;   public void setRent(Rent rent) &#123;       this.rent = rent;  &#125;   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色   public Object getProxy()&#123;       return Proxy.newProxyInstance(this.getClass().getClassLoader(),               rent.getClass().getInterfaces(),this);  &#125;   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.   // 处理代理实例上的方法调用并返回结果   @Override   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;       seeHouse();       //核心：本质利用反射实现！       Object result = method.invoke(rent, args);       fare();       return result;  &#125;   //看房   public void seeHouse()&#123;       System.out.println(&quot;带房客看房&quot;);  &#125;   //收中介费   public void fare()&#123;       System.out.println(&quot;收中介费&quot;);  &#125;&#125;\n\nClient - 租客\n//租客public class Client &#123;   public static void main(String[] args) &#123;       //真实角色       Host host = new Host();       //代理实例的调用处理程序       ProxyInvocationHandler pih = new ProxyInvocationHandler();       pih.setRent(host); //将真实角色放置进去！       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！       proxy.rent();  &#125;&#125;\n\n核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！\n动态代理的好处：\n\n可以使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 ；\n公共的业务由代理来完成 ，实现了业务的分工 ；\n公共业务发生扩展时变得更加集中和方便 ；\n一个动态代理 , 一般代理某一类业务；\n一个动态代理可以代理多个类，代理的是接口。\n\n10 AOPAOP（Aspect Oriented Programming），即面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\nAOP的相关概念：\n\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….\n切面（ASPECT）：横切关注点，被模块化的特殊对象。即，它是一个类。\n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。\n目标（Target）：被通知对象。\n代理（Proxy）：向目标对象应用通知之后创建的对象。\n切入点（PointCut）：切面通知 执行的“地点”的定义。\n连接点（JointPoint）：与切入点匹配的执行点。\n\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice。\n\n使用Spring实现Aop\n使用AOP织入，需要导入一个依赖包！\n&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n业务接口和实现类\npublic interface UserService &#123;   public void add();   public void delete();   public void update();   public void search();&#125;public class UserServiceImpl implements UserService&#123;   @Override   public void add() &#123;       System.out.println(&quot;增加用户&quot;);  &#125;   @Override   public void delete() &#123;       System.out.println(&quot;删除用户&quot;);  &#125;   @Override   public void update() &#123;       System.out.println(&quot;更新用户&quot;);  &#125;   @Override   public void search() &#123;       System.out.println(&quot;查询用户&quot;);  &#125;&#125;\n\n10.1 Spring API实现增强类：前置增强和后置增强\npublic class Log implements MethodBeforeAdvice &#123;   //method : 要执行的目标对象的方法   //objects : 被调用的方法的参数   //Object : 目标对象   @Override   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);  &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123;   //returnValue 返回值   //method被调用的方法   //args 被调用的方法的对象的参数   //target 被调用的目标对象   @Override   public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable &#123;       System.out.println(&quot;执行了&quot; + target.getClass().getName()       +&quot;的&quot;+method.getName()+&quot;方法,&quot;       +&quot;返回值：&quot;+returnValue);  &#125;&#125;\n\nspring的文件中注册bean , 并实现aop切入实现 , 注意导入约束 。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;   &lt;!--注册bean--&gt;   &lt;bean id=&quot;userService&quot; class=&quot;com.zhg.service.UserServiceImpl&quot;/&gt;   &lt;bean id=&quot;log&quot; class=&quot;com.zhg.log.Log&quot;/&gt;   &lt;bean id=&quot;afterLog&quot; class=&quot;com.zhg.log.AfterLog&quot;/&gt;   &lt;!--aop的配置--&gt;   &lt;aop:config&gt;       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;   &lt;/aop:config&gt;&lt;/beans&gt;\n\n测试\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;); // 接口！！！       userService.search();  &#125;&#125;\n\nSpring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来，实现公共业务的重复利用 。领域业务更纯粹，程序猿专注领域业务，其本质还是动态代理。\n10.2 自定义类实现自定义切入类\npublic class DiyPointcut &#123;   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   &#125;\n\nspring配置\n&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.zhg.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt;   &lt;!--第二种方式：使用AOP的标签实现--&gt;   &lt;aop:aspect ref=&quot;diy&quot;&gt;       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n测试：\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;);       userService.add();  &#125;&#125;\n\n10.3 注解实现注解实现的增强类\npackage com.zhg.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123;   @Before(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   @After(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   @Around(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void around(ProceedingJoinPoint jp) throws Throwable &#123;       System.out.println(&quot;环绕前&quot;);       System.out.println(&quot;签名:&quot;+jp.getSignature());       //执行目标方法proceed       Object proceed = jp.proceed();       System.out.println(&quot;环绕后&quot;);       System.out.println(proceed);  &#125;&#125;\n\nSpring配置文件中注册bean并增加支持注解的配置\n&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.zhg.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt;\n\n&lt;aop:aspectj-autoproxy/&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。其中有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当该属性为true时，表示使用CGLib动态代理技术织入增强。\n11 整合MyBatismaven导入相关jar包\n&lt;!--MyBatis和MySQL--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;   &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring相关--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectJ AOP 织入器--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-spring整合包--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;   &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--其他--&gt;&lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;\n\nmaven静态资源过滤配置\n&lt;build&gt;   &lt;resources&gt;       &lt;resource&gt;           &lt;directory&gt;src/main/java&lt;/directory&gt;           &lt;includes&gt;               &lt;include&gt;**/*.properties&lt;/include&gt;               &lt;include&gt;**/*.xml&lt;/include&gt;           &lt;/includes&gt;           &lt;filtering&gt;true&lt;/filtering&gt;       &lt;/resource&gt;   &lt;/resources&gt;&lt;/build&gt;\n\nmybatis-spring文档地址：http://mybatis.org/spring/zh/index.html\n11.1 整合实现一要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。\n\n使用SqlSessionFactoryBean创建SqlSessionFactory\n&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;   &lt;!--关联Mybatis--&gt;   &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/zhg/dao/*.xml&quot;/&gt;&lt;/bean&gt;\n\n配置数据源替换mybaits的数据源\n&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;   &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;\n\n注册sqlSessionTemplate\n&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;   &lt;!--利用构造器注入--&gt;   &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n增加Dao接口的实现类\npublic class UserDaoImpl implements UserMapper &#123;   //sqlSession不用我们自己创建了，Spring来管理   private SqlSessionTemplate sqlSession;   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;       this.sqlSession = sqlSession;  &#125;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = sqlSession.getMapper(UserMapper.class);       return mapper.selectUser();  &#125; &#125;\n\n注册bean实现\n&lt;bean id=&quot;userDao&quot; class=&quot;com.zhg.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\n测试\n@Testpublic void test()&#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);    List&lt;User&gt; user = mapper.selectUser();    System.out.println(user);&#125;\n\n\n\nmybatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;typeAliases&gt;       &lt;package name=&quot;com.zhg.pojo&quot;/&gt;   &lt;/typeAliases&gt;&lt;/configuration&gt;\n\n11.2 整合实现二第二种整合实现方法，mybatis-spring需要1.2.3版以上。\ndao继承Support类，直接利用 getSqlSession() 获得，然后直接注入SqlSessionFactory。比起方式1，不需要管理SqlSessionTemplate , 而且对事务的支持更加友好。\n将上文的UserDaoImpl修改一下\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);       return mapper.selectUser();  &#125;&#125;\n\n修改bean的配置\n&lt;bean id=&quot;userDao&quot; class=&quot;com.zhg.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;\n\n12 声明式事务事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用，用来确保数据的完整性和一致性。\n事务满足四个属性ACID（原子性，一致性，隔离性，持久性）\nSpring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式事务管理（AOP）。\n头文件tx**约束导入\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n事务管理器\n&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;\n\n事务的通知（Advice）配置\n&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;   &lt;tx:attributes&gt;       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;   &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n配置AOP\n&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt;   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.zhg.dao.*.*(..))&quot;/&gt;   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt;\n\n事务传播行为（propagation）是指多个事务方法相互调用时，事务在这些方法间的传播方式。Spring 支持 7 种事务传播行为（Transaction Propagation Behavior）：\n\n\n\n传播行为\n描述\n\n\n\nPROPAGATION_REQUIRED\n如果没有，就开启一个事务；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）\n\n\nRROPAGATION_REQUIRES_NEW\n如果没有，就开启一个事务；如果有，就将当前事务挂起。（方法A所在的事务就会挂起，方法B会起一个新的事务，等待方法B的事务完成以后，方法A才继续执行）\n\n\nPROPAGATION_NESTED\n如果没有，就开启一个事务；如果有，就在当前事务中嵌套其他事务\n\n\nPROPAGATION_SUPPORTS\n如果没有，就以非事务方式执行；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）\n\n\nPROPAGATION_NOT_SUPPORTED\n如果没有，就以非事务方式执行；如果有，就将当前事务挂起，（方法A所在的事务就会挂起，而方法B以非事务的状态运行完，再继续方法A的事务）\n\n\nPROPAGATION_NEVER\n如果没有，就以非事务方式执行；如果有，就抛出异常。\n\n\nPROPAGATION_MANDATORY\n如果没有，就抛出异常；如果有，就使用当前事务\n\n\n","tags":["Java","SSM框架","Spring"]},{"title":"Vue入门","url":"/2020/12/09/Vue%E5%85%A5%E9%97%A8/","content":"HTML+CSS+JS 视图：给用户看，刷新后台给的数据\n网络通信：axios\n页面跳转：vue-router\n状态管理：vuex\nVue-UI：ICE\n官网：https://cn.vuejs.org/\nVM：数据双向绑定\n虚拟DOM：利用内存\nVue集大成者：MVVM+DOM\nvue-element-admin：https://panjiachen.github.io/vue-element-admin-site/zh/\nVue下载地址\n开发版本：\nhttps://vuejs.org/js/vue.js\nhttps://vuejs.org/js/vue.min.js\nCDN：\nhttps://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\nhttps://cdn.bootcss.com/vue/2.5.16/vue.min.js\n1 Vue基础语法v-bind attribute 被称为指令，指令带有前缀v-\n条件：v-if\n循环：v-for\n事件：v-on\n组件：Vue.component\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app-7&quot;&gt;        &lt;ol&gt;            &lt;!--              现在我们为每个 todo-item 提供 todo 对象              todo 对象是变量，即其内容可以是动态的。            --&gt;            &lt;todo-item                    v-for=&quot;item in groceryList&quot;                    v-bind:todo=&quot;item&quot;                    v-bind:key=&quot;item.id&quot;            &gt;&lt;/todo-item&gt;        &lt;/ol&gt;    &lt;/div&gt;    &lt;script&gt;        Vue.component(&#x27;todo-item&#x27;, &#123;            props: [&#x27;todo&#x27;],            template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;        &#125;)            var app7 = new Vue(&#123;            el: &#x27;#app-7&#x27;,            data: &#123;                groceryList: [                    &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                    &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                    &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;                ]            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n2 网络通信JQuery，Ajax\nAxios 文档地址：http://www.axios-js.com/zh-cn/docs/\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;vue&quot;&gt;        &lt;div&gt;&#123;&#123;info.name&#125;&#125;&lt;/div&gt;        &lt;div&gt;&#123;&#123;info.address.street&#125;&#125;&lt;/div&gt;        &lt;a v-bind:href=&quot;info.url&quot;&gt;点我&lt;/a&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue(&#123;            el: &#x27;#vue&#x27;,            data()&#123;                return &#123;                    info: &#123;                        name: null,                        address: &#123;                            country: null,                            city: null,                            street: null                        &#125;,                        url: null                    &#125;                &#125;            &#125;,            mounted()&#123;                axios                    .get(&#x27;data.json&#x27;)                    .then(response =&gt; (this.info = response.data))            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\ndata.json\n&#123;  &quot;name&quot;:&quot;XXX&quot;,  &quot;url&quot;: &quot;http://baidu.com&quot;,  &quot;page&quot;: &quot;1&quot;,  &quot;isNonProfit&quot;:&quot;true&quot;,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;含光门&quot;,    &quot;city&quot;:&quot;陕西西安&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;,  &quot;links&quot;: [    &#123;      &quot;name&quot;: &quot;B站&quot;,      &quot;url&quot;: &quot;https://www.bilibili.com/&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;4399&quot;,      &quot;url&quot;: &quot;https://www.4399.com/&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;百度&quot;,      &quot;url&quot;: &quot;https://www.baidu.com/&quot;    &#125;  ]&#125;\n\n3 计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，应当使用计算属性。\n计算属性缓存 vs 方法\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;example&quot;&gt;        &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessageF() &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Timestamp now:&quot;&#123;&#123; nowF() &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Computed timestamp now:&quot;&#123;&#123; now &#125;&#125;&quot;&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue(&#123;            el: &#x27;#example&#x27;,            data: &#123;                message: &#x27;Hello&#x27;            &#125;,            // 在组件中            methods: &#123;                reversedMessageF: function () &#123;                    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;,                nowF: function () &#123;                    return Date.now()                &#125;            &#125;,            computed: &#123;                // 计算属性的 getter                reversedMessage: function () &#123;                    // `this` 指向 vm 实例                    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;,                now: function () &#123;                    return Date.now()                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。每当触发重新渲染时，调用方法将总会再次执行函数。\n为什么需要缓存？假设有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。可能有其他的计算属性依赖于 A。如果没有缓存，将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n4 插槽slotVue 实现了一套内容分发的 API，将 &lt;slot&gt; 元素作为承载分发内容的出口。可以把 slot 理解成一个占位符，当在子组件定义好一个 slot 标签，父组件传值时就会替换该标签内容。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;list&gt;        &lt;h1&gt;该数据不会被显示&lt;/h1&gt;        &lt;listname slot=&quot;listname&quot; v-bind:tit=&quot;tit&quot;&gt;&lt;/listname&gt;        &lt;item slot=&quot;item&quot; v-for=&quot;item in groceryList&quot; v-bind:item=&quot;item&quot;&gt;&lt;/item&gt;    &lt;/list&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;list&#x27;, &#123;        template: &#x27;&lt;div&gt;\\                    &lt;slot name=&quot;listname&quot;&gt;&lt;/slot&gt;\\                    &lt;ul&gt;\\                        &lt;slot name=&quot;item&quot;&gt;&lt;/slot&gt;\\                    &lt;/ul&gt;\\                    &lt;/div&gt;&#x27;    &#125;);    Vue.component(&#x27;item&#x27;, &#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&#x27;    &#125;)    Vue.component(&#x27;listname&#x27;, &#123;        props: [&#x27;tit&#x27;],        template: &#x27;&lt;p&gt;&#123;&#123; tit &#125;&#125;&lt;/p&gt;&#x27;    &#125;);    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            groceryList: [                &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;            ],            tit: &#x27;购物清单&#x27;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n如果&lt;list&gt;的template中没有包含一个&lt;slot&gt;元素,则该组件起始标签和结束标签之间的任何内容都会被抛弃。\n5 自定义事件组件内方法要操作Vue实例中的数据，可以在Vue实例中创建方法操作数据，通过HTML视图将实例中的方法赋给一个中间值（自定义事件），在组件内可以通过.$emit(eventName, […args])调用自定义事件。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;list&gt;        &lt;listname slot=&quot;listname&quot; :tit=&quot;tit&quot;&gt;&lt;/listname&gt;        &lt;item slot=&quot;item&quot; v-for=&quot;item in groceryList&quot; :item=&quot;item&quot; @remove=&quot;removeItem(item.id)&quot;&gt;&lt;/item&gt;    &lt;/list&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;list&#x27;, &#123;        template: `&lt;div&gt;                    &lt;slot name=&quot;listname&quot;&gt;&lt;/slot&gt;                    &lt;ul&gt;                        &lt;slot name=&quot;item&quot;&gt;&lt;/slot&gt;                    &lt;/ul&gt;                    &lt;/div&gt;`    &#125;);    Vue.component(&#x27;item&#x27;, &#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123;item.id&#125;&#125;---&#123;&#123; item.text &#125;&#125; &lt;button @click=&quot;rm&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            rm:function (index) &#123;                this.$emit(&#x27;remove&#x27;,index);            &#125;        &#125;    &#125;)    Vue.component(&#x27;listname&#x27;, &#123;        props: [&#x27;tit&#x27;],        template: &#x27;&lt;p&gt;&#123;&#123; tit &#125;&#125;&lt;/p&gt;&#x27;    &#125;);    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            groceryList: [                &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                &#123; id: 2, text: &#x27;其它&#x27; &#125;            ],            tit: &#x27;购物清单&#x27;        &#125;,        methods:&#123;            removeItem:function (index) &#123;                console.log(&quot;删除了&quot;+this.groceryList[index]);                this.groceryList.splice(index,1);            &#125;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n6 Vue-CliVue-cli 是一个官方提供的脚手架，用于快速生成一个Vue的项目模板。\n主要功能：\n\n统一的目录结构\n本地调试\n热部署\n单元测试\n集成打包上线\n\n需要提前下载安装Node.js以及淘宝镜像加速器（cnpm）\nnpm install cnpm -g# 或者npm install cnpm -g --registry=https://registry.npm.taobao.org\n\n项目搭建：在Vue项目文件夹下创建一个基于webpack模板的vue应用程序\n# myvue是项目名vue init webpack myvue\n\n然后一路选no即可；\n初始化并运行项目：\ncd myvuenpm install # 可使用cnpm加快速度npm run dev\n\n7 WebpackWebpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。\n安装webpack\nnpm install webpack -gnpm install webpack-cli -g\n\n使用webpack\n\n新建项目并在项目下创建modules文件夹，用于放置JS模块等资源文件；\n项目目录\n\n\n在modules文件夹下创建模块文件（hello.js，main.js）；\nhello.js\n//exports暴露一个方法exports.sayHi = function()&#123;    document.write(&quot;&lt;h1&gt;Webpack test&lt;/h1&gt;&quot;)&#125;\n\nmain.js\n//require导入一个模块var hello = require(&quot;./hello&quot;);hello.sayHi();\n\n在项目目录下创建webpack.config.js配置文件，使用webpack命令打包；\nwebpack.config.js\nmodule.exports = &#123;    entry:&#x27;./modules/main.js&#x27;,    output:&#123;        filename:&#x27;./js/bundle.js&#x27;    &#125;&#125;\n\nwebpack打包\n\n\n在项目目录下创建HTML页面（index.html）,导入webpack打包后的js文件。\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--前端的模块化开发--&gt;&lt;script src=&quot;dist/js/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n8 Vue-Router\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。\n\nVue-Router包含的功能有：\n\n嵌套的路由/视图表\n模块化的、基于组件的路由配置\n路由参数、查询、通配符\n基于 Vue.js 过渡系统的视图过渡效果\n细粒度的导航控制\n带有自动激活的 CSS class 的链接\nHTML5 历史模式或 hash 模式，在 IE9 中自动降级\n自定义的滚动条行为\n\n使用步骤：\n\n使用vue-cli搭建一个基于webpack模板的vue应用程序；\n\n新建components目录，存放编写的组件（Content.vue）；\nContent.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;内容页&lt;&#x2F;h1&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Content&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n在项目目录下使用cnpm install vue-router --save-dev命令安装vue-router；\n\n\n在src目录下新建一个文件夹router，专门存放路由；\nindex.js\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;//导入组件import Content from &#x27;../components/Content&#x27;//安装路由Vue.use(Router);//配置路由export default new Router(&#123;  routes:[    &#123;      path:&#x27;/content&#x27;,      component:Content    &#125;  ]&#125;)\n\n在main.js文件中导入并配置路由；\nmain.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import VueRouter from &#x27;vue-router&#x27;import  router from &#x27;./router&#x27;Vue.config.productionTip = false//显示声明使用VueRouterVue.use(VueRouter);new Vue(&#123;  el: &#x27;#app&#x27;,  //配置路由  router,  components: &#123; App &#125;,  template: &#x27;&lt;App/&gt;&#x27;&#125;)\n\n在App.vue中使用路由。\nApp.vue\n&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h1&gt;Hi&lt;&#x2F;h1&gt;    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容页&lt;&#x2F;router-link&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;,&#125;&lt;&#x2F;script&gt;&lt;style&gt;#app &#123;  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;&#x2F;style&gt;\n\n\n\n参数传递\n前端URL提交数据：\n&lt;!-- 命名的路由 --&gt;&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;this.$router.push(&quot;&#x2F;user&#x2F;&quot;+this.form.userid);\n\n参数传递路由配置（接受参数）：\nroutes:[    &#123;        path:&#x27;/user/:userId&#x27;，        name:&#x27;user&#x27;,        component:User,        props:true    &#125;]\n\n前端展示数据：\n&lt;template&gt;\t&#123;&#123;$router.params.userId&#125;&#125;\t&#123;&#123;userId&#125;&#125; &lt;&#x2F;template&gt;&lt;sript&gt;\texports default&#123;    \tprops:[&#39;userId&#39;],    \tname:&quot;User&quot;    \t    &#125;&lt;&#x2F;sript&gt;\n\n路由模式\n路由模式有两种：\n\nhash：路径带”#“（http://localhost/#/login）\nhistory：路径不带”#“（http://localhost/login）\n\n修改配置路由\nexport default new Router(    &#123;        mode:&#x27;history&#x27;,        routes:[                    ]    &#125;);\n\n\n\n重定向\nroutes:[    &#123;        path:&#x27;/goHome&#x27;，        redirect:&#x27;/main&#x27;    &#125;]\n\n404\nroutes:[    ...,    &#123;        path:*，        redirect:&#x27;/NotFound&#x27;    &#125;]\n\n嵌套路由：URL 中各段动态路径也按某种结构对应嵌套的各层组件。\n/user/foo/profile                     /user/foo/posts+------------------+                  +-----------------+| User             |                  | User            || +--------------+ |                  | +-------------+ || | Profile      | |  +------------&gt;  | | Posts       | || |              | |                  | |             | || +--------------+ |                  | +-------------+ |+------------------+                  +-----------------+\n\n配置嵌套路由（children属性）\nexport default new Router(&#123;   routes: [    &#123; path: &#x27;/user/:id&#x27;, component: User,      children: [        &#123;          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中          path: &#x27;profile&#x27;,          component: UserProfile        &#125;,        &#123;          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中          path: &#x27;posts&#x27;,          component: UserPosts        &#125;      ]    &#125;  ]&#125;);\n\n9 ElementUIElementUI是由饿了么开发的一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。\n测试：\n\n使用vue-cli搭建一个基于webpack模板的vue应用程序（vue init webpack 项目名）；\n\n安装依赖，安装需要的插件（vue-router, element-ui, sass-loader, node-sass）；\ncd 项目名cnpm install vue-router --save-devcnpm i element-ui -Scnpm install #安装依赖cnpm install sass-loader node-sass --save-devnpm run dev\n\n新建views目录，存放编写的视图（Main.vue，Login.vue）；\nLogin.vue\n&lt;template&gt;  &lt;div&gt;      &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;        &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;        &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;          &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;          &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;        &lt;&#x2F;el-form-item&gt;      &lt;&#x2F;el-form&gt;    &lt;el-dialog      title&#x3D;&quot;温馨提示&quot;      :visible.sync&#x3D;&quot;dialogVisible&quot;      width&#x3D;&quot;30%&quot;      :before-close&#x3D;&quot;handleClose&quot;&gt;      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;      &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export  default &#123;        name:&quot;Login&quot;,        data()&#123;            return &#123;                form:&#123;                    username: &#39;&#39;,                    password: &#39;&#39;                &#125;,                &#x2F;&#x2F;表单验证，需要再el-form-item 元素中增加prop属性                rules:&#123;                    username:[            &#123;required:true,message:&#39;账号不能为空&#39;,trigger:&#39;blur&#39;&#125;          ],            password:[            &#123;required: true,message: &#39;密码不能为空&#39;,trigger:&#39;blur&#39;&#125;          ]        &#125;,            &#x2F;&#x2F;对话框显示和隐藏            dialogVisible:false        &#125;        &#125;,        methods:&#123;            handleClose: function () &#123; console.log(&quot;Handle Close，空函数&quot;); &#125;,            onSubmit(formName) &#123;                &#x2F;&#x2F;为表单绑定验证功能                this.$refs[formName].validate((valid) &#x3D;&gt;&#123;                    if (valid)&#123;                        &#x2F;&#x2F;使用 vue-router路由到指定页面，该方式称之为编程式导航                        this.$router.push(&quot;&#x2F;main&quot;);                    &#125; else &#123;                        this.dialogVisible &#x3D; true;                        return false;                    &#125;                &#125;);            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;  .login-box&#123;    border: 1px solid #DCDFE6;    width: 350px;    margin:180px auto;    padding:35px 35px 15px 35px;    border-radius: 5px;    -webkit-border-radius: 5px;    -moz-border-radius: 5px;    box-shadow:0 0 25px #909399;  &#125;  .login-title&#123;    text-align:center;    margin:0 auto 40px auto;    color:#303133;  &#125;&lt;&#x2F;style&gt;\n\nMain.vue\n&lt;template&gt;    &lt;h1&gt;首页&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Main&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n新建router目录，存放配置的路由（index.js）;\nindex.js\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Main from &#x27;../views/Main&#x27;import Login from &#x27;../views/Login&#x27;Vue.use(Router);export default new Router(&#123;  routes:[    &#123;      path:&#x27;/main&#x27;,      component:Main    &#125;,    &#123;      path:&#x27;/login&#x27;,      component:Login    &#125;,  ]&#125;);\n\n在main.js文件中导入并配置路由。\nmain.js\n// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(router)Vue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123;  el: &#x27;#app&#x27;,  router,  render: h =&gt; h(App) //ElementUI&#125;)\n\n注意：遇到问题，可以考虑将sass降级：sass-loader:&quot;7.0.3&quot;，node-sass:&quot;4.7.2&quot;！\n\n\n10 路由钩子Vue的生命周期以及钩子函数\n\n路由钩子\nbeforeRouterEnter：进入路由前执行\nbeforeRouterEnter：进入路由后执行\nexport default&#123;\tprops:[&#39;id&#39;],\tname:&quot;UserProfile&quot;,\tbeforeRouteEnter:(to,from,next)&#x3D;&gt;&#123;\t\tconsole.log(&quot;准备进入个人信息页&quot;);\t\tnext();\t&#125;,\tbeforeRouterLeave:(to,from,next)&#x3D;&gt;&#123;\t\tconsole.log(&quot;准备离开个人信息页&quot;);\t\tnext();\t&#125;&#125;\n\n参数说明：\n\nto：路由将要跳转的路径信息\nfrom：路径跳转前的路径信息\nnext：路由的控制参数\nnext() 跳入下一页面\nnext(‘/path’) 改变路由的跳转方向，使其跳到另一路由\nnext(false) 返回原来的页面\nnext((vm)=&gt;{})仅在beforeRouterEnter中可用，vm是组件实例\n\n\n\n在钩子函数中使用异步请求\n安装并引用Axios\n入口文件main.js中\nimport Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios)\n\n使用路由钩子获取数据\n&lt;script&gt;    export  default &#123;        name:&quot;Login&quot;,        beforeRouteEnter:(to,from,next)&#x3D;&gt;&#123;            console.log(&quot;准备进入个人信息页&quot;);            next(vm&#x3D;&gt;&#123;                vm.getData();            &#125;);        &#125;,        beforeRouterLeave:(to,from,next)&#x3D;&gt;&#123;            console.log(&quot;准备离开个人信息页&quot;);            next();        &#125;,        methods:&#123;            getData:function()&#123;                this.axios(&#123;                    method:&#39;get&#39;,                    url:&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;                &#125;).then(function(response)&#123;                    console.log(response)                &#125;);            &#125;                  &#125;    &#125;&lt;&#x2F;script&gt;\n\n","tags":["前端","Vue"]},{"title":"LeetCode 62.不同路径","url":"/2020/12/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","content":"题目描述：\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n示例：\n输入：m = 3, n = 7输出：28\n解法一：动态规划\n思路： f(i,j) 表示从左上角走到 (i,j) 的路径数量，转移方程为 f(i,j)=f(i-1,j)+f(i,j-1) ，初始条件为 f(i,0)=f(0,j)=1 。\nclass Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[][] f = new int[m][n];        for (int i = 0; i &lt; m; ++i) &#123;            f[i][0] = 1;        &#125;        for (int j = 0; j &lt; n; ++j) &#123;            f[0][j] = 1;        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                f[i][j] = f[i - 1][j] + f[i][j - 1];            &#125;        &#125;        return f[m - 1][n - 1];    &#125;&#125;\n\n解法二：组合数学\n思路：从左上角到右下角过程中需要移动 m+n-2 次，其中有 m-1 次向下移动， n-1 次向右移动。问题相当于从 m+n-2  次移动次数中选择 m-1 次向下移动（或者 n-1次向右移动）。\nclass Solution &#123;    public int uniquePaths(int m, int n) &#123;        long ans = 1;        for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;            ans = ans * x / y;        &#125;        return (int) ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/unique-paths\n","tags":["算法","LeetCode","动态规划","数学"]},{"title":"SpringMVC教程","url":"/2020/12/10/SpringMVC%E6%95%99%E7%A8%8B/","content":"SpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。\nSpringMVC的特点：\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\n\n文档地址：https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#spring-webhttps://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/mvc.html\n1 SpringMVC执行原理Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\nSpringMVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\n\n当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n2 第一个MVC程序\nMaven导入依赖\n&lt;dependencies&gt;   &lt;dependency&gt;       &lt;groupId&gt;junit&lt;/groupId&gt;       &lt;artifactId&gt;junit&lt;/artifactId&gt;       &lt;version&gt;4.12&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework&lt;/groupId&gt;       &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;       &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;       &lt;version&gt;2.5&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;       &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;       &lt;version&gt;2.2&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;jstl&lt;/artifactId&gt;       &lt;version&gt;1.2&lt;/version&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;\n\n编写SpringMVC的配置文件springmvc-servlet.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;        &lt;!--前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!--后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置web.xml，注册DispatcherServlet\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--1.注册DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--启动级别-1--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n编写操作业务Controller （实现Controller接口）\npackage com.zhg.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123;    @Override    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        //ModelAndView 模型和视图        ModelAndView mv = new ModelAndView();        //封装对象，放在ModelAndView中。Model        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;);        //封装要跳转的视图，放在ModelAndView中        mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp        return mv;    &#125;&#125;\n\n在SpringMVC的配置文件中注册bean\n&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.zhg.controller.HelloController&quot;/&gt;\n\n编写跳转的jsp页面\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n\n\n遇到问题：访问出现404\n解决方案：添加发布项目中缺少的lib依赖\n使用注解开发\nMaven导入依赖\n\n\n编写SpringMVC的配置文件springmvc-servlet.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;    &lt;context:component-scan base-package=&quot;com.zhg.controller&quot;/&gt;    &lt;!--使SpringMVC不处理静态资源--&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--自动完成DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter两个实例的注入--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;        &lt;!--前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!--后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置web.xml，注册DispatcherServlet\n\n\n\n编写操作业务Controller （注解）\npackage com.zhg.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVAnnotation!&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n\n\n\n\n编写跳转的jsp页面\n\n3 RESTful风格RESTful是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应添加、 删除、修改、查询操作。\n在Spring MVC中可以使用  @PathVariable 注解，将方法参数的值对应绑定到一个URI模板变量上。\n//映射访问路径@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123;   String result = p1+p2;   //Spring MVC会自动实例化一个Model对象用于向视图中传值   model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);   //返回视图位置   return &quot;test&quot;;&#125;\n\nURL：http://localhost:8080/commit?p1=1&amp;p2=2 → http://localhost:8080/commit/1/2\n使用路径变量的好处：\n\n使路径变得更加简洁；\n获得参数更加方便，框架会自动进行类型转换；\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。\n\n使用method属性指定请求类型（如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等），可以收窄请求范围。\n//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.POST) //相当于组合注解@PostMapping(&quot;/hello&quot;)//其他组合注解：@GetMapping，@PostMapping，@PutMapping，@DeleteMapping，@PatchMappingpublic String index2(Model model)&#123;   model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);   return &quot;test&quot;;&#125;\n\n所有的地址栏请求默认都会是 HTTP GET 类型的。\n4 重定向和转发通过SpringMVC来实现转发和重定向（无需视图解析器）\n@Controllerpublic class ResultSpringMVC &#123;   @RequestMapping(&quot;/rsm/t1&quot;)   public String test1()&#123;       //转发       return &quot;/index.jsp&quot;;  &#125;   @RequestMapping(&quot;/rsm/t2&quot;)   public String test2()&#123;       //转发二       return &quot;forward:/index.jsp&quot;;  &#125;   @RequestMapping(&quot;/rsm/t3&quot;)   public String test3()&#123;       //重定向       return &quot;redirect:/index.jsp&quot;;       //可以重定向到另外一个请求实现       //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求  &#125;&#125;\n\n5 数据处理5.1 处理页面提交数据提交数据：http://localhost:8080/hello?username=XXX\n处理方法：\n//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123;   System.out.println(name);   return &quot;hello&quot;;&#125;\n\n后台输出：XXX\n提交对象要求提交的表单域和对象的属性名一致  , 参数使用对象即可\n实体类\npublic class User &#123;   private int id;   private String name;   private int age;   //构造   //get/set   //tostring()&#125;\n\n2、提交数据：http://localhost:8080/mvc04/user?name=XXX&amp;id=1&amp;age=15\n3、处理方法：\n@RequestMapping(&quot;/user&quot;)public String user(User user)&#123; //前端传递的参数名和对象名必须一致   System.out.println(user);   return &quot;hello&quot;;&#125;\n\n后台输出：User { id=1, name=’XXX’, age=15 }\n5.2 数据显示到前端\n通过ModelAndView\npublic class ControllerTest1 implements Controller &#123;   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;       //返回一个模型视图对象       ModelAndView mv = new ModelAndView();       mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);       mv.setViewName(&quot;test&quot;);       return mv;  &#125;&#125;\n\n通过ModelMap\n@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;   //封装要显示到视图中的数据   //相当于req.setAttribute(&quot;name&quot;,name);   model.addAttribute(&quot;name&quot;,name);   System.out.println(name);   return &quot;hello&quot;;&#125;\n\n通过Model\n@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;   //封装要显示到视图中的数据   //相当于req.setAttribute(&quot;name&quot;,name);   model.addAttribute(&quot;msg&quot;,name);   System.out.println(name);   return &quot;test&quot;;&#125;\n\n\n\n对比：\n\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；\n\nModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；\n\nModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。\n\n\n6 乱码问题乱码问题可以通过过滤器解决 , 而SpringMVC也提供了一个过滤器 , 可以在web.xml中配置。\n&lt;filter&gt;   &lt;filter-name&gt;encoding&lt;/filter-name&gt;   &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;   &lt;init-param&gt;       &lt;param-name&gt;encoding&lt;/param-name&gt;       &lt;param-value&gt;utf-8&lt;/param-value&gt;   &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;   &lt;filter-name&gt;encoding&lt;/filter-name&gt;   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n其他处理方法：\n\n修改tomcat配置文件（设置编码）\n&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;          connectionTimeout=&quot;20000&quot;          redirectPort=&quot;8443&quot; /&gt;\n\n自定义过滤器\nimport javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123;   @Override   public void destroy() &#123;  &#125;   @Override   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;       //处理response的字符编码       HttpServletResponse myResponse=(HttpServletResponse) response;       myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);       // 转型为与协议相关对象       HttpServletRequest httpServletRequest = (HttpServletRequest) request;       // 对request包装增强       HttpServletRequest myrequest = new MyRequest(httpServletRequest);       chain.doFilter(myrequest, response);  &#125;   @Override   public void init(FilterConfig filterConfig) throws ServletException &#123;  &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123;   private HttpServletRequest request;   //是否编码的标记   private boolean hasEncode;   //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰   public MyRequest(HttpServletRequest request) &#123;       super(request);// super必须写       this.request = request;  &#125;   // 对需要增强方法 进行覆盖   @Override   public Map getParameterMap() &#123;       // 先获得请求方式       String method = request.getMethod();       if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;           // post请求           try &#123;               // 处理post乱码               request.setCharacterEncoding(&quot;utf-8&quot;);               return request.getParameterMap();          &#125; catch (UnsupportedEncodingException e) &#123;               e.printStackTrace();          &#125;      &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;           // get请求           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();           if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次               for (String parameterName : parameterMap.keySet()) &#123;                   String[] values = parameterMap.get(parameterName);                   if (values != null) &#123;                       for (int i = 0; i &lt; values.length; i++) &#123;                           try &#123;                               // 处理get乱码                               values[i] = new String(values[i]                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);                          &#125; catch (UnsupportedEncodingException e) &#123;                               e.printStackTrace();                          &#125;                      &#125;                  &#125;              &#125;               hasEncode = true;          &#125;           return parameterMap;      &#125;       return super.getParameterMap();  &#125;   //取一个值   @Override   public String getParameter(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       if (values == null) &#123;           return null;      &#125;       return values[0]; // 取回参数的第一个值  &#125;   //取所有值   @Override   public String[] getParameterValues(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       return values;  &#125;&#125;\n\n\n\n7 JSON\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写的同时，也易于机器解析和生成，并有效地提升网络传输效率，目前使用特别广泛。\n\nJSON 键值对是用来保存 JavaScript 对象的一种方式，任何JavaScript 支持的类型都可以通过 JSON 来表示，格式&#123;&quot;key&quot;: &quot;value&quot;&#125;。\nJSON和JavaScript对象互转\n//将JSON字符串转换为JavaScript对象var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;//将JavaScript对象转换为JSON字符串var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;\n\nController返回JSON数据Jackson导入依赖并配置SpringMVC需要的配置\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.11.3&lt;/version&gt;&lt;/dependency&gt;\n\nUser实体类\npackage com.zhg.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;   private String name;   private int age;   private String sex;   &#125;\n\nUserController\n@Controller//可以在类上直接使用@RestController，相当于在该类下所有的方法上都添加了@ResponseBodypublic class UserController &#123;    @RequestMapping(&quot;/json1&quot;)    @ResponseBody //不跳转页面，而是返回字符串到当前页面    public String json1() throws JsonProcessingException &#123;        //创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper = new ObjectMapper();        //创建一个对象        User user = new User(&quot;user&quot;, 18, &quot;男&quot;);        //将对象解析成为json格式        String str = mapper.writeValueAsString(user);        //由于@ResponseBody注解，这里会将str转成json格式返回。        return str;    &#125;        //输出集合    @RequestMapping(&quot;/json2&quot;)    @ResponseBody     public String json2() throws JsonProcessingException &#123;        //创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper = new ObjectMapper();        //创建多个对象        User user1 = new User(&quot;user1&quot;, 18, &quot;男&quot;);        User user2 = new User(&quot;user2&quot;, 18, &quot;男&quot;);        User user3 = new User(&quot;user3&quot;, 18, &quot;男&quot;);        User user4 = new User(&quot;user4&quot;, 18, &quot;男&quot;);        List&lt;User&gt; list = new ArrayList&lt;User&gt;();        list.add(user1);        list.add(user2);        list.add(user3);        list.add(user4);        //将我们的对象解析成为json格式        String str = mapper.writeValueAsString(list);        return str;    &#125;        //输出时间（时间戳）    @RequestMapping(&quot;/json3&quot;)    @ResponseBody    public String json3() throws JsonProcessingException &#123;        ObjectMapper mapper = new ObjectMapper();        //创建时间一个对象，java.util.Date        Date date = new Date();        //将我们的对象解析成为json格式        String str = mapper.writeValueAsString(date);         return str;    &#125;    //输出时间（自定义时间格式）    @RequestMapping(&quot;/json4&quot;)    @ResponseBody    public String json3() throws JsonProcessingException &#123;        ObjectMapper mapper = new ObjectMapper();        //不使用时间戳的方式        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        //自定义日期格式对象        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        //指定日期格式        mapper.setDateFormat(sdf);        Date date = new Date();        String str = mapper.writeValueAsString(date);        return str;    &#125;    &#125;\n\n乱码问题\n通过@RequestMaping的produces属性设置编码格式为utf-8，返回的类型为json\n//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)\n\n通过Spring配置统一解决乱码问题\n&lt;mvc:annotation-driven&gt;   &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;   &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n\n抽取为JSON工具类\nimport com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123;      public static String getJson(Object object) &#123;       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);  &#125;   public static String getJson(Object object,String dateFormat) &#123;       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try &#123;           return mapper.writeValueAsString(object);      &#125; catch (JsonProcessingException e) &#123;           e.printStackTrace();      &#125;       return null;  &#125;&#125;\n\nFastjsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt;\n\nfastjson 三个主要的类：\n\nJSONObject代表json对象（实现Map接口）\n\nJSONArray代表json对象数组（List接口）\n\nJSON代表JSONObject和JSONArray的转化\n\n\nimport com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.zhg.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123;   public static void main(String[] args) &#123;       User user1 = new User(&quot;user1&quot;, 18, &quot;男&quot;);       User user2 = new User(&quot;user2&quot;, 18, &quot;男&quot;);       User user3 = new User(&quot;user3&quot;, 18, &quot;男&quot;);       User user4 = new User(&quot;user4&quot;, 18, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);  &#125;&#125;\n\n8 整合SSM整合步骤：\n\n新建Maven项目，导入相关依赖并设置资源过滤；\n&lt;dependencies&gt;    &lt;!--Junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--数据库驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.mchange&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Servlet - JSP --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mybatis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;2.0.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n编写MyBatis配置文件；\n\ndatabase.properties（数据库配置文件）\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTCjdbc.username=rootjdbc.password=1031\n\nmybatis-config.xml（Mybatis配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;      &lt;typeAliases&gt;       &lt;package name=&quot;com.zhg.pojo&quot;/&gt;   &lt;/typeAliases&gt;   &lt;!--&lt;mappers&gt;       &lt;mapper resource=&quot;com/zhg/dao/BookMapper.xml&quot;/&gt;   &lt;/mappers&gt;--&gt;&lt;/configuration&gt;\n\n\n\n编写Spring配置文件；\n\nspring-dao.xml（Spring整合Mybatis配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 配置整合mybatis --&gt;   &lt;!-- 1.关联数据库文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;   &lt;!-- 2.数据库连接池 --&gt;   &lt;!--数据库连接池       dbcp 半自动化操作 不能自动连接       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）   --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;       &lt;!-- 配置连接池属性 --&gt;       &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;       &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;       &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;       &lt;!-- c3p0连接池的私有属性 --&gt;       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;       &lt;!-- 关闭连接后不自动commit --&gt;       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;       &lt;!-- 获取连接超时时间 --&gt;       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;       &lt;!-- 当获取连接失败重试次数 --&gt;       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;    &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;&lt;!--    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;--&gt;&lt;!--        &amp;lt;!&amp;ndash; 注入sqlSessionFactory &amp;ndash;&amp;gt;--&gt;&lt;!--        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;--&gt;&lt;!--        &amp;lt;!&amp;ndash; 给出需要扫描Dao接口包 &amp;ndash;&amp;gt;--&gt;&lt;!--        &lt;property name=&quot;basePackage&quot; value=&quot;com.zhg.dao&quot;/&gt;--&gt;&lt;!--    &lt;/bean&gt;--&gt;    &lt;bean id=&quot;bookMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.zhg.dao.BookMapper&quot; /&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nspring-service.xml（Spring整合Service层配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 扫描service相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.zhg.service&quot; /&gt;   &lt;!--BookServiceImpl注入到IOC容器中--&gt;   &lt;!--&lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.zhg.service.BookServiceImpl&quot;&gt;       &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;   &lt;/bean&gt;--&gt;   &lt;!-- 配置事务管理器 --&gt;   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n编写SpringMVC配置文件；\n\nweb.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;&gt;   &lt;!--DispatcherServlet--&gt;   &lt;servlet&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;             &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;       &lt;/init-param&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;   &lt;/servlet&gt;   &lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;   &lt;!--encodingFilter--&gt;   &lt;filter&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;filter-class&gt;          org.springframework.web.filter.CharacterEncodingFilter       &lt;/filter-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;utf-8&lt;/param-value&gt;       &lt;/init-param&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;      &lt;!--Session过期时间--&gt;   &lt;session-config&gt;       &lt;session-timeout&gt;15&lt;/session-timeout&gt;   &lt;/session-config&gt;   &lt;/web-app&gt;\n\nspring-mvc.xml（SpringMVC配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;   &lt;!-- 配置SpringMVC --&gt;   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;   &lt;mvc:annotation-driven /&gt;   &lt;!-- 2.静态资源默认servlet配置--&gt;   &lt;mvc:default-servlet-handler/&gt;   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;   &lt;/bean&gt;   &lt;!-- 4.扫描web相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.zhg.controller&quot; /&gt;&lt;/beans&gt;\n\n\n\nSpring配置整合。\napplicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;   &lt;import resource=&quot;spring-dao.xml&quot;/&gt;   &lt;import resource=&quot;spring-service.xml&quot;/&gt;   &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;   &lt;/beans&gt;\n\n\n\n9 Ajax\nAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n利用AJAX可以实现：\n\n注册时，输入用户名自动检测用户是否已经存在；\n登陆时，提示用户名密码错误；\n删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除；\n……\n\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。jQuery 提供多个与 AJAX 有关的方法，其本质就是 XMLHttpRequest，对原生JS代码进行了封装，方便调用！\nAjaxController\n@Controllerpublic class AjaxController &#123;   @RequestMapping(&quot;/a1&quot;)   public void ajax1(String name , HttpServletResponse response) throws IOException &#123;       if (&quot;admin&quot;.equals(name))&#123;           response.getWriter().print(&quot;true&quot;);      &#125;else&#123;           response.getWriter().print(&quot;false&quot;);      &#125;  &#125;&#125;\n\nindex.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt;   &lt;title&gt;$Title$&lt;/title&gt;  &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;   &lt;script&gt;       function a1()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,               data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;,               success:function (data,status) &#123;                   alert(data);                   alert(status);              &#125;          &#125;);      &#125;   &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt;\n\n获取一个集合对象，展示到前端页面\nUserController\n@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123;   List&lt;User&gt; list = new ArrayList&lt;User&gt;();   list.add(new User(&quot;user1&quot;,3,&quot;男&quot;));   list.add(new User(&quot;user2&quot;,3,&quot;男&quot;));   list.add(new User(&quot;user3&quot;,3,&quot;男&quot;));   return list; //由于@RestController注解，将list转成json格式返回&#125;\n\nuser.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt;   &lt;tr&gt;       &lt;td&gt;姓名&lt;/td&gt;       &lt;td&gt;年龄&lt;/td&gt;       &lt;td&gt;性别&lt;/td&gt;   &lt;/tr&gt;   &lt;tbody id=&quot;content&quot;&gt;   &lt;/tbody&gt;&lt;/table&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;   $(function () &#123;       $(&quot;#btn&quot;).click(function () &#123;           $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;               console.log(data)               var html=&quot;&quot;;               for (var i = 0; i &lt;data.length ; i++) &#123;                   html+= &quot;&lt;tr&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;/tr&gt;&quot;              &#125;               $(&quot;#content&quot;).html(html);          &#125;);      &#125;)  &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注册提示效果\nRegisterController\n@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123;   String msg = &quot;&quot;;   //模拟数据库中存在数据   if (name!=null)&#123;       if (&quot;admin&quot;.equals(name))&#123;           msg = &quot;OK&quot;;      &#125;else &#123;           msg = &quot;用户名输入错误&quot;;      &#125;  &#125;   if (pwd!=null)&#123;       if (&quot;123456&quot;.equals(pwd))&#123;           msg = &quot;OK&quot;;      &#125;else &#123;           msg = &quot;密码输入有误&quot;;      &#125;  &#125;   return msg; //由于@RestController注解，将msg转成json格式返回&#125;\n\nlogin.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;ajax&lt;/title&gt;   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;   &lt;script&gt;       function a1()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,               data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;,               success:function (data) &#123;                   if (data.toString()==&#x27;OK&#x27;)&#123;                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                  &#125;else &#123;                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                  &#125;                   $(&quot;#userInfo&quot;).html(data);              &#125;          &#125;);      &#125;       function a2()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,               data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;,               success:function (data) &#123;                   if (data.toString()==&#x27;OK&#x27;)&#123;                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                  &#125;else &#123;                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                  &#125;                   $(&quot;#pwdInfo&quot;).html(data);              &#125;          &#125;);      &#125;   &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;  用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;   &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;   &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n10 拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。\n过滤器与拦截器的区别：拦截器是AOP思想的具体应用。\n过滤器\n\nservlet规范中的一部分，任何java web工程都可以使用\n在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截\n\n拦截器 \n\n拦截器是SpringMVC框架里的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的\n\n自定义拦截器\nimport org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123;   //在请求处理的方法之前执行   //如果返回true执行下一个拦截器   //如果返回false就不执行下一个拦截器   public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;       System.out.println(&quot;------------处理前------------&quot;);       return true;  &#125;   //在请求处理方法执行之后执行   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;       System.out.println(&quot;------------处理后------------&quot;);  &#125;   //在dispatcherServlet处理后执行,做清理工作.   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;       System.out.println(&quot;------------清理------------&quot;);  &#125;&#125;\n\n配置拦截器\n&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;       &lt;!--/** 包括路径及其子路径--&gt;       &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;       &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;       &lt;mvc:mapping path=&quot;/**&quot;/&gt;       &lt;!--bean配置的就是拦截器--&gt;       &lt;bean class=&quot;com.zhg.interceptor.MyInterceptor&quot;/&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n验证用户是否登录\nUserController\nimport org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;   //跳转到登陆页面   @RequestMapping(&quot;/jumplogin&quot;)   public String jumpLogin() throws Exception &#123;       return &quot;login&quot;;  &#125;   //跳转到成功页面   @RequestMapping(&quot;/jumpSuccess&quot;)   public String jumpSuccess() throws Exception &#123;       return &quot;success&quot;;  &#125;   //登陆提交   @RequestMapping(&quot;/login&quot;)   public String login(HttpSession session, String username, String pwd) throws Exception &#123;       // 向session记录用户身份信息       System.out.println(&quot;接收前端===&quot;+username);       session.setAttribute(&quot;user&quot;, username);       return &quot;success&quot;;  &#125;   //退出登陆   @RequestMapping(&quot;logout&quot;)   public String logout(HttpSession session) throws Exception &#123;       // session 过期       session.invalidate();       return &quot;login&quot;;  &#125;&#125;\n\n用户登录拦截器\nimport org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class LoginInterceptor implements HandlerInterceptor &#123;   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;       // 如果是登陆页面则放行       System.out.println(&quot;uri: &quot; + request.getRequestURI());       if (request.getRequestURI().contains(&quot;login&quot;)) &#123;           return true;      &#125;       HttpSession session = request.getSession();       // 如果用户已登陆也放行       if(session.getAttribute(&quot;user&quot;) != null) &#123;           return true;      &#125;       // 用户没有登陆跳转到登陆页面       request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);       return false;  &#125;   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;  &#125;      public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;  &#125;&#125;\n\nSpringMVC配置文件中的注册拦截器\n&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;       &lt;mvc:mapping path=&quot;/**&quot;/&gt;       &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.zhg.interceptor.LoginInterceptor&quot;/&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n11 文件上传下载如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver，而且必须将表单的method设置为POST，并将enctype设置为multipart/form-data（用户选择的文件以二进制数据发送给服务器）。\n表单中的enctype 属性：\n\napplication/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。\nmultipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。\ntext/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。\n\nSpring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。\n11.1 文件上传\n导入文件上传的jar包，commons-fileupload；\n&lt;!--文件上传--&gt;&lt;dependency&gt;   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;   &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt;   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;   &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;   &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n配置multipartResolver；\n&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;   &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;   &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;   &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;   &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt;\n\nCommonsMultipartFile 的 常用方法：\n\nString getOriginalFilename()：获取上传文件的原名\nInputStream getInputStream()：获取文件流\nvoid transferTo(File dest)：将上传文件保存到一个目录文件中\n\n\n编写上传文件的表单；\n&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt;\n\n编写上传文件的FileController。\nimport org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@Controllerpublic class FileController &#123;   //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象   //批量上传CommonsMultipartFile则为数组即可   @RequestMapping(&quot;/upload&quot;)   public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;       //获取文件名 : file.getOriginalFilename();       String uploadFileName = file.getOriginalFilename();       //如果文件名为空，直接回到首页！       if (&quot;&quot;.equals(uploadFileName))&#123;           return &quot;redirect:/index.jsp&quot;;      &#125;       System.out.println(&quot;上传文件名 : &quot;+uploadFileName);       //上传路径保存设置       String path = request.getServletContext().getRealPath(&quot;/upload&quot;);       //如果路径不存在，创建一个       File realPath = new File(path);       if (!realPath.exists())&#123;           realPath.mkdir();      &#125;       System.out.println(&quot;上传文件保存地址：&quot;+realPath);       InputStream is = file.getInputStream(); //文件输入流       OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流       //读取写出       int len=0;       byte[] buffer = new byte[1024];       while ((len=is.read(buffer))!=-1)&#123;           os.write(buffer,0,len);           os.flush();      &#125;       os.close();       is.close();       return &quot;redirect:/index.jsp&quot;;  &#125;    /** 采用file.Transto 来保存上传的文件*/    @RequestMapping(&quot;/upload2&quot;)    public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;        //上传路径保存设置        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);        File realPath = new File(path);        if (!realPath.exists())&#123;            realPath.mkdir();        &#125;        //上传文件地址        System.out.println(&quot;上传文件保存地址：&quot;+realPath);        //通过CommonsMultipartFile的方法直接写文件（注意这个时候）        file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));        return &quot;redirect:/index.jsp&quot;;    &#125;&#125;\n\n\n\n11.2 文件下载编写下载文件的Controller\n@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123;   //要下载的图片地址   String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);   String  fileName = &quot;基础语法.jpg&quot;;   //1、设置response 响应头   response.reset(); //设置页面不缓存,清空buffer   response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码   response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据   //设置响应头   response.setHeader(&quot;Content-Disposition&quot;,           &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));   File file = new File(path,fileName);   //2、 读取文件--输入流   InputStream input=new FileInputStream(file);   //3、 写出文件--输出流   OutputStream out = response.getOutputStream();   byte[] buff =new byte[1024];   int index=0;   //4、执行 写出操作   while((index= input.read(buff))!= -1)&#123;       out.write(buff, 0, index);       out.flush();  &#125;   out.close();   input.close();   return null;&#125;\n\n\n\n","tags":["Java","SSM框架","SpringMVC"]},{"title":"日期时间处理","url":"/2020/12/10/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/","content":"Java日期时间Date&amp;Calendar菜鸟教程 - Java日期时间：https://www.runoob.com/java/java-date-time.html\njava.util.Date：https://docs.oracle.com/javase/8/docs/api/java/util/Date.html\njava.text.SimpleDateFormat：https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\njava.util.Calendar：https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html\nDate类封装了当前的日期和时间，可以用来比较两个日期。\nimport java.util.Date;  public class DateDemo &#123;   public static void main(String args[]) &#123;       // 初始化 Date 对象       Date date = new Date();               // 使用 toString() 函数显示日期时间       System.out.println(date.toString());   &#125;&#125;// 通过getTime()，before() after() equals()，compareTo()三种方法比较时间\n\nSimpleDateFormat类可以将字符串和日期时间相互转化（格式化日期或解析字符串为时间）。\nimport  java.util.*;import java.text.*; // 通过sdf.format(date)格式化日期public class SDFDemo1 &#123;   public static void main(String args[]) &#123;       Date dNow = new Date( );      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;);       System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));   &#125;&#125;// 通过sdf.parse(string)解析字符串为时间public class SDFDemo2 &#123;    public static void main(String args[]) &#123;      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);        String input = args.length == 0 ? &quot;1818-11-11&quot; : args[0];        System.out.print(input + &quot; Parses as &quot;);        Date t;        try &#123;           t = ft.parse(input);           System.out.println(t);       &#125; catch (ParseException e) &#123;           System.out.println(&quot;Unparseable using &quot; + ft);       &#125;   &#125;&#125;\n\nCalendar类可以设置和获取日期数据的特定部分，在日期的这些部分加上或者减去值。\nimport java.util.Calendar;public class CalendarDemo &#123;    public static void main(String[] args) &#123;        // 初始值        Calendar cal = Calendar.getInstance(); //得到当前时间        cal.setTimeInMillis(0); //转换成格林威治时间,由于中国时区设置是GMT+8,所以打印格林威治时间得到的是1970-01-01 08:00:00.                // 获取值        int year = cal.get(Calendar.YEAR); //年        int month = cal.get(Calendar.MONTH) + 1; //月(必须要+1)        int date = cal.get(Calendar.DATE); //日        int hour = cal.get(Calendar.HOUR_OF_DAY); //时        int minute = cal.get(Calendar.MINUTE); //分        int second = cal.get(Calendar.SECOND); //秒        int day = cal.get(Calendar.DAY_OF_WEEK); //星期(Locale.ENGLISH情况下，周日是1)        // 设置值        cal.set(2013, 5, 4, 13, 44, 51); //年月日时分秒(月份0代表1月)        cal.set(Calendar.YEAR, 2014); //年        cal.set(Calendar.MONTH, 0); //月(月份0代表1月)        cal.set(Calendar.DATE, 11); //日        cal.set(Calendar.HOUR_OF_DAY, 15); //时        cal.set(Calendar.MINUTE, 33); //分        cal.set(Calendar.SECOND, 32); //秒                // 比较值        // before(),after(),equals(),compareTo()        String startTime = &quot;2012-12-12 12:45:39&quot;;          String endTime = &quot;2012-12-12 12:45:40&quot;;          SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);          Date startDate = sdf.parse(startTime);          Date endDate = sdf.parse(endTime);          Calendar start = Calendar.getInstance();          Calendar end = Calendar.getInstance();          start.setTime(startDate);          end.setTime(endDate);          if(start.before(end))&#123;              System.err.println(&quot;开始时间小于结束时间&quot;);          &#125;else if(start.after(end))&#123;              System.err.println(&quot;开始时间大于结束时间&quot;);          &#125;else if(start.equals(end))&#123;              System.err.println(&quot;开始时间等于结束时间&quot;);          &#125;          /*               * start &lt; end 返回-1               * start = end 返回0               * start &gt; end 返回1               */          int count = start.compareTo(end);          System.err.println(count);                // 运算值        cal.add(Calendar.YEAR, 1); //年        cal.add(Calendar.MONTH, 1); //月        cal.add(Calendar.DATE, 1); //日        cal.add(Calendar.HOUR_OF_DAY, -1); //时        cal.add(Calendar.MINUTE, 1); //分        cal.add(Calendar.SECOND, 1); //秒        cal.add(Calendar.DATE, 7); //周            &#125;&#125;\n\nDate/Time在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：\n\n非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。\n设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。\n时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。\n\nJava 8引入了新的API Date/Time，以解决较旧的java.util.Date和java.util.Calendar的问题，新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\njava.time：https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\n最常用的类是LocalDate，LocalTime和LocalDateTime。 顾名思义，它们代表观察者上下文中的本地日期/时间。这些类主要用于不需要在上下文中明确指定时区的情况。\nimport java.time.*;import java.time.temporal.ChronoUnit;import java.time.temporal.TemporalAdjusters;import java.util.Calendar;import java.util.Date;public class LocalDateTimeDemo &#123;    public static void main(String[] args) &#123;        // LocalDate        // 创建日期        LocalDate today = LocalDate.now(); // 获取当前日期的实例        LocalDate date1 = LocalDate.of(2015, 2, 20); // 通过年月日数值获取指定日期的实例        LocalDate date2 = LocalDate.parse(&quot;2015-02-20&quot;); // 通过字符串获取指定日期的实例        // 日期加减        LocalDate tomorrow = LocalDate.now().plusDays(1); // 天        LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS); // 指定时间单位        // 获取日期相关信息        DayOfWeek sunday = LocalDate.parse(&quot;2016-06-12&quot;).getDayOfWeek(); // 查询日期星期        int twelve = LocalDate.parse(&quot;2016-06-12&quot;).getDayOfMonth(); // 查询日期月份天数        boolean leapYear = LocalDate.now().isLeapYear(); // 判断日期年份是否是闰年        // 获取日期当天/当月最开始时刻        LocalDateTime beginningOfDay = LocalDate.parse(&quot;2016-06-12&quot;).atStartOfDay();        LocalDate firstDayOfMonth = LocalDate.parse(&quot;2016-06-12&quot;).with(TemporalAdjusters.firstDayOfMonth());        // LocalTime        // 创建时间        LocalTime now = LocalTime.now();        LocalTime time1 = LocalTime.parse(&quot;06:30&quot;);        LocalTime time2 = LocalTime.of(6, 30);        // 时间加减        LocalTime sevenThirty = LocalTime.parse(&quot;06:30&quot;).plus(1, ChronoUnit.HOURS);        // 获取时间相关信息        int six = LocalTime.parse(&quot;06:30&quot;).getHour();        boolean isBefore = LocalTime.parse(&quot;06:30&quot;).isBefore(LocalTime.parse(&quot;07:30&quot;)); // 比较时间先后        LocalTime maxTime = LocalTime.MAX;        // LocalDateTime        // 创建日期时间        LocalDateTime curDatetime = LocalDateTime.now();        LocalDateTime dateTime1 = LocalDateTime.of(2015, Month.FEBRUARY, 20, 06, 30);        LocalDateTime dateTime2 = LocalDateTime.parse(&quot;2015-02-20T06:30:00&quot;);        // 组合日期和时间        LocalDate date = LocalDate.of(2014,02,26);        LocalTime time = LocalTime.of(12,23,20);        LocalDateTime dt1 = LocalDateTime.of(date,time);        //LocalDate结合LocalTime成一个LocalDateTime        LocalDateTime dt2 = date.atTime(13,45,20);        //LocalDate结合LocalTime成一个LocalDateTime        LocalDateTime dt3 = date.atTime(time);        //LocalTime结合LocalDate成LocalDateTime        LocalDateTime dt4 = time.atDate(date);                // 日期时间加减        LocalDateTime nextDay = curDatetime.plusDays(1);        LocalDateTime preTime = curDatetime.minusHours(2);        // 将Date和Calendar转换为Instant再转换为LocalDateTime        Date date = new Date();        Calendar calendar = Calendar.getInstance();        LocalDateTime dateTimeC1 = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());        LocalDateTime dateTimeC2 = LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());        LocalDateTime dateTimeC3 = LocalDateTime.ofEpochSecond(1465817690, 0, ZoneOffset.UTC);                // DateTime格式化        // 格式化        LocalDateTime localDateTime = LocalDateTime.of(2015, Month.JANUARY, 25, 6, 30);        String localDateString1 = localDateTime.format(DateTimeFormatter.ISO_DATE); // ISO日期格式：2015-01-25        String localDateString2 = localDateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));        String localDateString3 = localDateTime.format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)); // SHORT:15-1-25 上午6:30 MEDIUM:2015-1-25 6:30:00 LONG:2015年1月25日 上午06时30分00秒    &#125;&#125;\n\n当需要处理时区特定的日期和时间时，Java 8提供了ZonedDateTime， ZoneId用于表示不同区域的标识符。使用时区的另一种方法是使用具有偏移量的日期时间OffsetDateTime。\nimport java.time.*;import java.util.Set;public class ZonedDateTimeDemo &#123;    public static void main(String[] args) &#123;        ZoneId zoneId = ZoneId.of(&quot;Europe/Paris&quot;); // 创建巴黎时区        Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds(); //获取所有时区的ZoneId        // 本地日期时间localDateTime转换成特定时区的zonedDateTime1        LocalDateTime localDateTime = LocalDateTime.now();        ZonedDateTime zonedDateTime1 = ZonedDateTime.of(localDateTime, zoneId);        // 解析字符串生成时区日期时间zonedDateTime2        ZonedDateTime zonedDateTime2 = ZonedDateTime.parse(&quot;2015-05-03T10:15:30+01:00[Europe/Paris]&quot;);                // 创建具有偏移量的日期时间OffsetDateTime        ZoneOffset offset = ZoneOffset.of(&quot;+02:00&quot;);        OffsetDateTime offSetByTwo = OffsetDateTime.of(localDateTime, offset);    &#125;\n\nPeriod类表示以年、月和日为单位的时间数量，广泛用于修改给定日期的值或获取两个日期之间的差异；Duration类表示以秒和纳米秒为单位的时间数量，与Period类似，Duration类用于处理时间。\nimport java.time.Duration;import java.time.LocalDate;import java.time.LocalTime;import java.time.Period;import java.time.temporal.ChronoUnit;public class PeriodDurationDemo &#123;    public static void main(String[] args) &#123;        // Period        // 创建两个本地日期        LocalDate initialDate = LocalDate.parse(&quot;2007-05-10&quot;);        LocalDate finalDate = initialDate.plus(Period.ofDays(5));        // 计算两个日期的差值        int five1 = Period.between(initialDate, finalDate).getDays();        long five2 = ChronoUnit.DAYS.between(initialDate, finalDate);        // Duration        // 创建两个本地时间        LocalTime initialTime = LocalTime.of(6, 30, 0);        LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));        // 计算两个时间的差值        long thirty1 = Duration.between(initialTime, finalTime).getSeconds();        long thirty2 = ChronoUnit.SECONDS.between(initialTime, finalTime);    &#125;&#125;\n\nJoda-TimeJodaTime 提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。（Joda-Time的作者（Stephen Colebourne）和Oracle的作者在JSR 310下共同领导，开发了Java SE 8软件包中java.time。）\nJoda-Time主要的特点包括：\n\n易于使用：Calendar让获取”正常的”的日期变得很困难，使它没办法提供简单的方法，而Joda-Time能够 直接进行访问域并且索引值1就是代表January。\n易于扩展：JDK支持多日历系统是通过Calendar的子类来实现，这样就显示的非常笨重而且事实 上要实现其它日历系统是很困难的。Joda-Time支持多日历系统是通过基于Chronology类的插件体系来实现。\n提供一组完整的功能：它打算提供 所有关系到date-time计算的功能．Joda-Time当前支持6种日历系统，而且在将来还会继续添加。有着比JDK Calendar更好的整体性能等等。\n\n文档地址：https://www.joda.org/joda-time/userguide.html\n导入Maven依赖\n&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;\n\n与java.time类似，Joda-Time有5个最常用的date-time类：Instant, DateTime, LocalDate, LocalTime, LocalDateTime，都是不可变的类。\nimport org.joda.time.DateTime;import org.joda.time.LocalDate;public class JodaTimeDemo &#123;    public static void main(String[] args) &#123;        DateTime today = new DateTime();        DateTime datetorrow = today.plusDays(1);        System.out.println(today.toString(&quot;yyyy-MM-dd&quot;));//2020-12-14        System.out.println(today.toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));//2020-12-14 17:19:39        System.out.println(datetorrow.toString(&quot;yyyy-MM-dd&quot;));//2020-12-15        System.out.println(&quot;......................&quot;);        //获得一个时间的副本，将day设置成自己制定的时间,不改变月份，只改变日期        DateTime d1 = today.withDayOfMonth(1);        System.out.println(d1.toString(&quot;yyyy-MM-dd&quot;));//2020-12-01        System.out.println(&quot;......................&quot;);        LocalDate localDate = new LocalDate();        System.out.println(localDate);//2020-12-14        System.out.println(&quot;........................&quot;);        //获取当前时间三个月后的月份的最后一天        localDate = localDate.plusMonths(3).dayOfMonth().withMaximumValue();        System.out.println(localDate);//2021-03-31        System.out.println(&quot;........................&quot;);        //计算二年前第三个月第一天的日期        DateTime dateTime = new DateTime();        DateTime dateTime2 = dateTime.minusYears(2).monthOfYear().setCopy(3).                dayOfMonth().withMinimumValue();        System.out.println(dateTime2.toString(&quot;yyyy-MM-dd&quot;));//2018-03-01    &#125;&#125;\n\nInterval表示两个 instant 之间的间隔，左闭右开，而java time 中没有提供类似l的 API，因为 JSR-310 标准中没有这个概念。\nDateTime dt1 = new DateTime();DateTime dt2 = new DateTime().plusDays(1);Interval interval = new Interval(dt1.toInstant(), dt2.toInstant());\n\nMySQL日期时间官网文档：https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html\nMySQL中重要的内建日期函数\n\n\n\n函数\n描述\n\n\n\nNOW()\n返回当前的日期和时间\n\n\nCURDATE()\n返回当前的日期\n\n\nCURTIME()\n返回当前的时间\n\n\nDATE()\n提取日期或日期/时间表达式的日期部分\n\n\nTIME()\n返回参数表达式中的时间部分\n\n\nEXTRACT()\n返回日期/时间的单独部分\n\n\nDATE_ADD()\n向日期添加指定的时间间隔\n\n\nDATE_SUB()\n从日期减去指定的时间间隔\n\n\nDATEDIFF()\n返回两个日期之间的天数\n\n\nDATE_FORMAT()\n用不同的格式显示日期/时间\n\n\nDAY()\nDAYOFMONTH() 的别名\n\n\nDAYNAME()\n返回某天在用星期中的名称\n\n\nDAYOFMONTH()\n返回某天是当月的第几天 （1-31）\n\n\nDAYOFWEEK()\n返回某天是该星期的第几天\n\n\nDAYOFYEAR()\n返回某天是一年中的第几天（1-366）\n\n\nLAST_DAY()\n返回参数日期所在月份的最后一天\n\n\nDATE_FORMAT()\n根据格式字符串对日期值进行格式化\n\n\n项目应用根据数据库员工出勤记录生成月报表统计每名员工的出勤率。\n出勤记录表tb_attendance-record\n\n出勤月报表示例\n\n\nAttendanceRecordMapper.java（接口）\n//查询某员工某月出勤数int countOneMonth(@Param(&quot;eid&quot;) int eid,@Param(&quot;month&quot;) String month);//查询某员工某月未迟到出勤数int countEarlyOneMonth(@Param(&quot;eid&quot;) int eid,@Param(&quot;month&quot;) String month,@Param(&quot;time&quot;) String time);\n\nAttendanceRecordMapper.xml\n&lt;select id=&quot;countOneMonth&quot; resultType=&quot;_int&quot;&gt;    select ifnull(t.count,0) from    report.tb_employee e    left join  (select count(1) count,e.id eid    from report.tb_employee e    join report.tb_attendance_record r    on e.id = r.employee_id    where date_format(r.attendance_date,&#x27;%Y-%m&#x27;) = #&#123;month&#125;    group by e.id) as t    on e.id = t.eid    where id = #&#123;eid&#125;&lt;/select&gt;&lt;select id=&quot;countEarlyOneMonth&quot; resultType=&quot;_int&quot;&gt;    select ifnull(t.count,0) from    report.tb_employee e    left join  (select count(1) count,e.id eid    from report.tb_employee e    join report.tb_attendance_record r    on e.id = r.employee_id    where date_format(r.attendance_date,&#x27;%Y-%m&#x27;) = #&#123;month&#125; and time(r.accurate_time) &amp;lt; #&#123;time&#125;    group by e.id) as t    on e.id = t.eid    where id = #&#123;eid&#125;&lt;/select&gt;\n\nAttendanceRecordService（接口）\n//获取月出勤记录List&lt;Map&lt;String,String&gt;&gt; getMonthList(String month);//获取月出勤迟到记录List&lt;Map&lt;String,String&gt;&gt; getMonthLateList(String month, String time);\n\nAttendanceRecordServiceImpl（实现类）\n@Overridepublic List&lt;Map&lt;String, String&gt;&gt; getMonthList(String month) &#123;    List&lt;Employee&gt; employees = employeeMapper.getAll();    ArrayList&lt;Map&lt;String, String&gt;&gt; records = new ArrayList&lt;&gt;();    for (Employee employee : employees) &#123;        Map&lt;String, String&gt; record = new LinkedHashMap&lt;&gt;();        int id = employee.getId();        record.put(&quot;id&quot;,String.valueOf(id));        String name = employee.getName();        record.put(&quot;name&quot;,name);        int attendance = attendanceRecordMapper.countOneMonth(employee.getId(),month);        int countDay = DateUtil.getCountDay(month);        double attendanceRate = (double)(Math.round(attendance * 1.0 / countDay * 100) / 100.0);        record.put(&quot;attendanceRate&quot;,String.valueOf(attendanceRate));        record.put(&quot;attendanceDay&quot;,String.valueOf(attendance));        record.put(&quot;absenceDay&quot;,String.valueOf(countDay - attendance));        records.add(record);    &#125;    return records;&#125;@Overridepublic List&lt;Map&lt;String, String&gt;&gt; getMonthLateList(String month, String time) &#123;    List&lt;Employee&gt; employees = employeeMapper.getAll();    ArrayList&lt;Map&lt;String, String&gt;&gt; records = new ArrayList&lt;&gt;();    for (Employee employee : employees) &#123;        int lateDay = DateUtil.getCountDay(month) - attendanceRecordMapper.countEarlyOneMonth(employee.getId(),month,time);        if(lateDay &gt; 0)&#123;            Map&lt;String, String&gt; record = new LinkedHashMap&lt;&gt;();            int id = employee.getId();            record.put(&quot;id&quot;,String.valueOf(id));            record.put(&quot;name&quot;,String.valueOf(employee.getName()));            record.put(&quot;lateDay&quot;,String.valueOf(lateDay));            records.add(record);        &#125;    &#125;    return records;&#125;\n\nDateUtil.java\nimport java.text.SimpleDateFormat;import java.util.Calendar;public class DateUtil &#123;    public static Calendar getNextMonth(String month)&#123;        Calendar cal = Calendar.getInstance();        try &#123;            cal.setTime(new SimpleDateFormat(&quot;yyyy-MM&quot;).parse(month));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        cal.add(Calendar.MONTH, 1);        cal.set(Calendar.DAY_OF_MONTH,1);        return cal;    &#125;    public static int getMonthDay(String month)&#123;        Calendar cal = Calendar.getInstance();        try &#123;            cal.setTime(new SimpleDateFormat(&quot;yyyy-MM&quot;).parse(month));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        //获取某月最大天数        int monthDay = cal.getActualMaximum(Calendar.DAY_OF_MONTH);        return monthDay;    &#125;    public static int getCountDay(String month)&#123;        Calendar today = Calendar.getInstance();        Calendar nextMonth = DateUtil.getNextMonth(month);        int countDay = DateUtil.getMonthDay(month);        if(today.compareTo(nextMonth) == -1)&#123;            countDay = Calendar.getInstance().get(Calendar.DAY_OF_MONTH);        &#125;        return countDay;    &#125;&#125;\n\n","tags":["Java","JavaSE","MySQL","项目"]},{"title":"LeetCode 389.找不同","url":"/2020/12/18/LeetCode389-%E6%89%BE%E4%B8%8D%E5%90%8C/","content":"题目描述：\n给定两个字符串 s 和 t，它们只包含小写字母。\n字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。\n请找出在 t 中被添加的字母。\n示例：\n输入：s = “abcd”, t = “abcde”输出：”e”\n解法一：计数\n思路：遍历字符串 s 和 t，对其中字符的计数值加1 / 减1，被添加的字符的计数值为 -1。\n解法二：求和\n思路：分别求出字符串 s 和 t 中每个字符的ASCII码值的和，两者的差值即为添加字符的ASCII码。\n解法三：位运算\n异或的性质：\n\n交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b\n任何数于0异或为任何数 0 ^ n =&gt; n\n相同的数异或为0: n ^ n =&gt; 0\n\n思路：对两个字符串每个字符进行异或，找出求字符串中出现奇数次的字符。\nclass Solution &#123;    public char findTheDifference(String s, String t) &#123;        int ret = 0;        for (int i = 0; i &lt; s.length(); ++i) &#123;            ret ^= s.charAt(i);        &#125;        for (int i = 0; i &lt; t.length(); ++i) &#123;            ret ^= t.charAt(i);        &#125;        return (char) ret;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/find-the-difference/\n","tags":["算法","LeetCode","位运算"]},{"title":"SpringBoot教程","url":"/2021/03/20/SpringBoot%E6%95%99%E7%A8%8B/","content":"1 简介Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像Maven整合了所有的jar包，Spring Boot整合了所有的框架 。\n所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，由于原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。\nSpring Boot的主要优点：\n\n为所有Spring开发者更快的入门\n开箱即用，提供各种默认配置来简化项目配置\n内嵌式容器简化Web项目\n没有冗余代码生成和XML配置的要求\n\n2 第一个SpringBoot程序官方提供了一个快速生成的网站，IDEA集成了这个网站，可以在官网（https://start.spring.io/）直接下载后导入IDEA开发；一般都是直接使用IDEA创建一个SpringBoot项目。\n1、在主程序的同级目录下，新建一个controller包；\n2、在包中新建一个HelloController类；\nimport org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;Hello World&quot;;    &#125;&#125;\n\n3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回（控制台输出了 Tomcat 访问的端口号）。\n3 运行原理启动器 spring-boot-starter\nSpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 。\nspringboot-boot-starter-xxx：spring-boot的场景启动器\nspring-boot-starter-web：导入web模块正常运行所依赖的组件\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n主启动类 XXXApplication\n//@SpringBootApplication 来标注一个主配置类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class XXXApplication &#123;   public static void main(String[] args) &#123;     //以为是启动了一个方法，没想到启动了一个服务      SpringApplication.run(SpringbootApplication.class, args);   &#125;&#125;\n\n@SpringBootApplication\nSprnig Boot项目的核心注解，目的是开启自动配置 ，运行标注类的main方法来启动SpringBoot应用。\n@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(    excludeFilters = &#123;@Filter(    type = FilterType.CUSTOM,    classes = &#123;TypeExcludeFilter.class&#125;), @Filter(    type = FilterType.CUSTOM,    classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;    // ......&#125;\n\n​    @ComponentScan\n​    自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中。\n​    @SpringBootConfiguration：SpringBoot的配置类\n// 点进去得到下面的 @Component@Configuration // 这是一个配置类public @interface SpringBootConfiguration &#123;&#125;@Component // 启动类本身也是Spring中的一个组件public @interface Configuration &#123;&#125;\n\n​    @EnableAutoConfiguration：开启自动配置\n​        @AutoConfigurationPackage ：自动配置包\n @Import(&#123;Registrar.class&#125;) // Spring底层注解@import ， 给容器中导入一个组件// Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描注册到Spring容器public @interface AutoConfigurationPackage &#123;&#125;\n\n​        @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 \n​        AutoConfigurationImportSelector ：自动配置导入选择器\n​        getCandidateConfigurations → loadFactoryNames → loadSpringFactories\n​        获取资源 “META-INF/spring.factories”（spring.factories 中有很多自动配置类，这就是自动配置根源所在），将读取到的资源遍历，封装成为一个Properties，返回启动自动导入配置文件的注解类：EnableAutoConfiguration\n结论：\n\nSpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，并将这些值作为自动配置类导入容器，自动配置类就生效，从而进行自动配置工作；\nSpringBoot会给容器中导入非常多的自动配置类 （xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件 ，免去了我们手动编写配置注入功能组件等的工作；\n整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中。\n\nSpringApplication.run分析\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication主要做了以下四件事情：\n\n推断应用的类型是普通的项目还是Web项目；\n\n查找并加载所有可用初始化器 ， 设置到initializers属性中；\n\n找出所有的应用程序监听器，设置到listeners属性中；\n\n推断并设置main方法的定义类，找到运行的主类。\n\n\n构造器：\npublic SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;    // ......    this.webApplicationType = WebApplicationType.deduceFromClasspath();    this.setInitializers(this.getSpringFactoriesInstances();    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));    this.mainApplicationClass = this.deduceMainApplicationClass();&#125;\n\nrun方法执行流程\n\n4 YAML配置SpringBoot使用一个全局的配置文件 ：application.properties(key=value) / application.yml(key: value)。该配置文件可以修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了。\n\nYAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写，在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）\n\n这种语言以数据作为中心，而不是以标记语言为重点！\n4.1 基础语法# 普通键值对k: v# 对象/Mapobj: \tk1: v1    k2: v2obj: &#123;k1: v1,k2: v2&#125;#数组/List/Setarr:\t- e1\t- e2\t- e3arr: [e1,e2,e3]\n\n注意：单引号中特殊字符最终会变成和普通字符一样输出！\n4.2 注入配置文件通过**@Value**给bean设置注入值（通过@Autowired注入）\n@Component //注册beanpublic class Dog &#123;    @Value(&quot;阿黄&quot;)    private String name;    @Value(&quot;18&quot;)    private Integer age;    //有参无参构造、get、set方法、toString()方法 &#125;\n\n\n\n复杂实体类Person\n@Component //注册bean到容器中public class Person &#123;    private String name;    private Integer age;    private Boolean happy;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;        //有参无参构造、get、set方法、toString()方法  &#125;\n\nyaml配置实体类属性\nperson:  name: XXX  age: 3  happy: false  birth: 2000/01/01  maps: &#123;k1: v1,k2: v2&#125;  lists:   - code   - girl   - music  dog:    name: 旺财    age: 1\n\n配置文件占位符\nperson:    name: XXX$&#123;random.uuid&#125; # 随机uuid    age: $&#123;random.int&#125;  # 随机int    happy: false    birth: 2000/01/01    maps: &#123;k1: v1,k2: v2&#125;    lists:      - code      - girl      - music    dog:      name: $&#123;person.hello:other&#125;_旺财      age: 1\n\n通过**@ConfigurationProperties**读取yaml配置实体属性\n/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123;    private String name;    private Integer age;    private Boolean happy;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;&#125;\n\nIDEA提示，SpringBoot配置处理器没有找到。可以导入配置文件处理器的Maven依赖。\n&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;  &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n\n\nproperties配置文件注入\n配置文件user.properties\nuser.name=XXXuser.age=18user.sex=男\n\n通过**@PropertySource**读取properties文件，使用@Value进行注入。\n@Component //注册bean@PropertySource(value = &quot;classpath:user.properties&quot;)public class User &#123;    //直接使用@value    @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值    private String name;    @Value(&quot;#&#123;9*2&#125;&quot;)  // #&#123;SpEL&#125; Spring表达式    private int age;    @Value(&quot;男&quot;)  // 字面量    private String sex;&#125;\n\n@Value VS @ConfigurationProperties\n\n@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加；\n\n松散绑定（yml中写的last-name，这个和lastName是一样的）： - 后面跟着的字母默认是大写的；\n\nJSR303数据校验：在字段是增加一层过滤器验证 ， 可以保证数据的合法性；\n\n复杂类型封装，yml中可以封装对象 ， 使用value则不支持。\n\n\n4.3 多配置选择application.properties\nspring.profiles.active=devserver.port=8080\n\napplication-dev.properties\nserver.port=8081\n\napplication-test.properties\nserver.port=8082\n\napplication.yml\nserver:\tport: 8081spring:\tprofiles:\t\tactive: dev---server:\tport: 8082spring:\tprofiles:dev\t---server:\tport: 8083spring:\tprofiles:test\n\n4.4 自动配置原理SpringBoot官方文档中有大量的配置。自动配置类根据当前不同的条件（@Conditional派生注解）判断，决定这个配置类是否生效，一旦这个配置类生效，这个配置类就会给容器中添加各种组件；\n这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类。\nxxxxAutoConfigurartion：自动配置类：给容器中添加组件\nxxxxProperties：封装配置文件中相关属性\n可以通过启用debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效。\n5 JSR303数据校验Springboot中可以用@validated来校验数据，保证数据的重要性。\n@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated  //数据校验public class Person &#123;    @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式    private String name;&#125;\n\n常见数据校验注解\n@NotNull(message=&quot;名字不能为空&quot;)private String userName;@Max(value=120,message=&quot;年龄最大不能查过120&quot;)private int age;@Email(message=&quot;邮箱格式错误&quot;)private String email;//空检查@Null       //验证对象是否为null@NotNull    //验证对象是否不为null, 无法查检长度为0的字符串@NotBlank   //检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty   //检查约束元素是否不为NULL或者是EMPTY，用于集合    //Booelan检查@AssertTrue     //验证 Boolean 对象是否为 true  @AssertFalse    //验证 Boolean 对象是否为 false      //长度检查@Size(min=, max=) //验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min=, max=) //string is between min and max included.//日期检查@Past       //验证 Date 和 Calendar 对象是否在当前时间之前  @Future     //验证 Date 和 Calendar 对象是否在当前时间之后  //除此以外，我们还可以自定义一些数据校验规则@Pattern    //验证 String 对象是否符合正则表达式的规则\n\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：\n优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件，互补配置。\n6 Web开发初步解决问题：\n导入静态资源\n首页\n模板引擎thymeleaf\n装配扩展SpringMVC\n则删改查\n拦截器\n国际化\n6.1 静态资源处理6.1.1 webjarsSpringBoot中，SpringMVC的web配置都在配置类WebMvcAutoConfiguration 里，其中有一个方法：addResourceHandlers。 （添加资源处理）\n@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    if (!this.resourceProperties.isAddMappings()) &#123;        // 已禁用默认资源处理        logger.debug(&quot;Default resource handling disabled&quot;);        return;    &#125;    // 缓存控制    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();    // webjars 配置    // 所有的 /webjars/** ，都需要去classpath:/META-INF/resources/webjars/找对应的资源    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    &#125;    // 静态资源配置    String staticPathPattern = this.mvcProperties.getStaticPathPattern();    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    &#125;&#125;\n\nWebjars本质就是以jar包的方式引入我们的静态资源 ， 使用Webjars，可以去https://www.webjars.org 搜索。\n&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;/groupId&gt;    &lt;artifactId&gt;jquery&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;\n\n只要是静态资源，SpringBoot就会去对应的路径寻找资源，这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js\n6.1.2 本地导入staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties。\n// 进入方法public String[] getStaticLocations() &#123;    return this.staticLocations;&#125;// 找到对应的值private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;// 找到路径private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;     &quot;classpath:/META-INF/resources/&quot;,  &quot;classpath:/resources/&quot;,     &quot;classpath:/static/&quot;,     &quot;classpath:/public/&quot; &#125;;\n\nResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。\n也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置。\n spring.resources.static-locations=classpath:/coding/,classpath:/zhg/\n\n6.2 首页处理@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,                                                           FormattingConversionService mvcConversionService,                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页        this.mvcProperties.getStaticPathPattern());    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));    return welcomePageHandlerMapping;&#125;// 点进去private Optional&lt;Resource&gt; getWelcomePage() &#123;    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());    // ::是java8 中新引入的运算符    // Class::function的时候function是属于Class的，应该是静态方法。    // this::function的funtion是属于这个对象的。    // 简而言之，就是一种语法糖而已，是一种简写    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;// 欢迎页就是一个location下的的 index.html 而已private Resource getIndexHtml(String location) &#123;    return this.resourceLoader.getResource(location + &quot;index.html&quot;);&#125;\n\n欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。\n与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。\n需要关闭默认图标并清除浏览器缓存！\n#关闭默认图标spring.mvc.favicon.enabled=false\n\n7 模板引擎Thymeleaf官方文档：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html\n&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-thymeleaf --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;\n\nThymeleaf的自动配置类：ThymeleafProperties\n@ConfigurationProperties(    prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123;    private static final Charset DEFAULT_ENCODING;    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; //默认前缀    public static final String DEFAULT_SUFFIX = &quot;.html&quot;; //默认后缀    private boolean checkTemplate = true;    private boolean checkTemplateLocation = true;    private String prefix = &quot;classpath:/templates/&quot;; //页面存放路径    private String suffix = &quot;.html&quot;;    private String mode = &quot;HTML&quot;;    private Charset encoding;&#125;\n\nThymeleaf语法基础可以使用任意th:attr替换html中的原生属性\n\n表达式\n\nSimple expressions:\nVariable Expressions: $&#123;...&#125;\nSelection Variable Expressions: *&#123;...&#125;\nMessage Expressions: #&#123;...&#125;\nLink URL Expressions: @&#123;...&#125;\nFragment Expressions: ~&#123;...&#125;\n\n\nLiterals\nText literals: &#39;one text&#39;, &#39;Another one!&#39;,…\nNumber literals: 0, 34, 3.0, 12.3,…\nBoolean literals: true, false\nNull literal: null\nLiteral tokens: one, sometext, main,…\n\n\nText operations:\nString concatenation: +\nLiteral substitutions: |The name is $&#123;name&#125;|\n\n\nArithmetic operations:\nBinary operators: +, -, *, /, %\nMinus sign (unary operator): -\n\n\nBoolean operations:\nBinary operators: and, or\nBoolean negation (unary operator): !, not\n\n\nComparisons and equality:\nComparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)\nEquality operators: ==, != (eq, ne)\n\n\nConditional operators:\nIf-then: (if) ? (then)\nIf-then-else: (if) ? (then) : (else)\nDefault: (value) ?: (defaultvalue)\n\n\nSpecial tokens:\nNo-Operation: _\n\n\n\nAll these features can be combined and nested:\n&#x27;User is of type &#x27; + ($&#123;user.isAdmin()&#125; ? &#x27;Administrator&#x27; : ($&#123;user.type&#125; ?: &#x27;Unknown&#x27;))\n\n测试\nController\n@RequestMapping(&quot;/t2&quot;)public String test2(Map&lt;String,Object&gt; map)&#123;    //存入数据    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);    map.put(&quot;users&quot;, Arrays.asList(&quot;u1&quot;,&quot;u2&quot;));    //classpath:/templates/test.html    return &quot;test&quot;;&#125;\n\ntest.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;狂神说&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--不转义--&gt;&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--遍历数据--&gt;&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;&lt;h4&gt;    &lt;!--行内写法：官网#12--&gt;    &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;\n\n8 SpringMVC扩展文档地址：https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-developing-web-applications.html\n8.1 自定义视图解析器WebMvcAutoConfiguration类中找到ContentNegotiatingViewResolver方法。\n@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);    return resolver;&#125;// 点进ContentNegotiatingViewResolver类，发现该类实现了ViewResolver接口（实现了ViewResolve接口的类可以看作视图解析器）@Nullable // 注解说明：@Nullable 即参数可为nullpublic View resolveViewName(String viewName, Locale locale) throws Exception &#123;    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());    if (requestedMediaTypes != null) &#123;        // 获取候选的视图对象        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);        // 选择一个最适合的视图对象，然后把这个对象返回        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);        if (bestView != null) &#123;            return bestView;        &#125;    &#125;    // .....&#125;\n\n结论：从beanFactory工具中获取容器中的所有视图解析器，ViewRescolver.class组合所有的视图解析器，在容器中去找最合适的视图解析器并返回。\n自定义视图解析器\npublic class MyMvcConfig implements WebMvcConfigurer&#123;    @Bean //放到bean中    public ViewResolver myViewResolver()&#123;        return new MyViewResolver();    &#125;    //静态内部类实现ViewResolver接口    private static class MyViewResolver implements ViewResolver&#123;        @Override        public View resolveViewName(String s, Locale locale) throws Exception &#123;            return null;        &#125;    &#125;&#125;\n\n8.2 格式化转换器WebMvcAutoConfiguration类中找到mvcConversionService方法。\n@Beanpublic FormattingConversionService mvcConversionService() &#123;    Format format = this.mvcProperties.getFormat();    WebConversionService conversionService = new WebConversionService((new DateTimeFormatters()).dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime()));    this.addFormatters(conversionService);    return conversionService;&#125;\n\n发现mvcProperties，配置格式化（spring.mvc.format.date格式化日期）\n8.3 修改默认配置SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；如果有些组件可以存在多个，就将用户配置的和默认的组合起来！\n扩展使用SpringMVC需要编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解（@EnableWebMvc注解导入了类DelegatingWebMvcConfiguration）。\n//因为类型要求为WebMvcConfigurer，所以我们实现其接口//可以使用自定义类扩展MVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        // 浏览器发送/test ， 就会跳转到test页面；        registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;);    &#125;&#125;\n\n8.4 全面接管SpringMVC全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！只需在我们的配置类中要加一个@EnableWebMvc。如果我们全面接管了SpringMVC了，SpringBoot给我们配置的静态资源映射一定会无效。\n自动配置就失效原因分析\n// @EnableWebMvc注解导入了类DelegatingWebMvcConfiguration@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125;// 它继承了一个父类 WebMvcConfigurationSupportpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;  // ......&#125;// 而Webmvc自动配置类上有注解@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,    ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;    &#125;\n\n9 页面国际化\n先在IDEA设置File Encoding中统一设置properties的编码为UTF-8；\n\n编写配置文件；\n\nresources资源文件下新建一个i18n目录，存放国际化配置文件；\n\n先建立login.properties文件，再建立login_zh_CN.properties文件（发现IDEA自动识别了国际化操作，合并文件夹）；\n\n可以合并文件夹中新建一个文件，按照提示可以快捷输入地区（en_US）；\n\n编写三个配置文件。\n可以通过配置文件下方的Resource Bundle进行可视化配置。\nlogin.properties\nlogin.btn=登录login.password=密码login.remember=记住我login.tip=请登录login.username=用户名\n\nlogin_en_US.properties\nlogin.btn=Sign inlogin.password=Passwordlogin.remember=Remember melogin.tip=Please sign inlogin.username=Username\n\nlogin_zh_CN.properties\nlogin.btn=登录login.password=密码login.remember=记住我login.tip=请登录login.username=用户名\n\n\n\n配置messages的路径：spring.messages.basename=i18n.login；\n\n配置页面（Thymeleaf）国际化值（Thymeleaf的文档，找到message取值操作为：#{…}）；\n\n配置国际化解析。\n\n前端页面的跳转连接；\n&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;\n\n写一个自定义的处理的组件类LocaleResolver，可以在链接上携带区域信息;\nimport org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;//可以在链接上携带区域信息public class MyLocaleResolver implements LocaleResolver &#123;    //解析请求    @Override    public Locale resolveLocale(HttpServletRequest request) &#123;        String language = request.getParameter(&quot;l&quot;);        Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的        //如果请求链接不为空        if (!StringUtils.isEmpty(language))&#123;            //分割请求参数            String[] split = language.split(&quot;_&quot;);            //国家，地区            locale = new Locale(split[0],split[1]);        &#125;        return locale;    &#125;    @Override    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;    &#125;&#125;\n\n为了让我们的区域化信息能够生效，在自定义的MvcConofig下添加bean；\n@Beanpublic LocaleResolver localeResolver()&#123;    return new MyLocaleResolver();&#125;\n\n\n\n\n\n10 整合JDBC对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot底层都是采用Spring Data的方式进行统一处理各种数据库，Spring Data也是Spring中与Spring Boot、Spring Cloud等齐名的知名项目。\nSping Data官网：https://spring.io/projects/spring-data\n\n新建项目，引入相应模块（Spring Web，JDBC API，MySQL Driver）；\n\n编写yaml配置文件连接数据库；\nspring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver\n\n配置完，就可以直接去使用了，因为SpringBoot已经默认进行了自动配置。\n@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;    //DI注入数据源    @Autowired    DataSource dataSource;    @Test    public void contextLoads() throws SQLException &#123;        //看一下默认数据源        System.out.println(dataSource.getClass());        //获得连接        Connection connection =   dataSource.getConnection();        System.out.println(connection);        //关闭连接        connection.close();    &#125;&#125;\n\nSpring Boot 2.2.5 默认使用HikariDataSource 数据源，HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀。\n\n编写一个Controller，注入jdbcTemplate，编写测试方法进行访问测试。\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;/jdbc&quot;)public class JdbcController &#123;    /**     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接     */    @Autowired    JdbcTemplate jdbcTemplate;    //查询employee表中所有数据    //List 中的1个 Map 对应数据库的 1行数据    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值    @GetMapping(&quot;/list&quot;)    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;        String sql = &quot;select * from employee&quot;;        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);        return maps;    &#125;        //新增一个用户    @GetMapping(&quot;/add&quot;)    public String addUser()&#123;        //插入语句，注意时间问题        String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +                &quot; values (&#x27;狂神说&#x27;,&#x27;24736743@qq.com&#x27;,1,101,&#x27;&quot;+ new Date().toLocaleString() +&quot;&#x27;)&quot;;        jdbcTemplate.update(sql);        //查询        return &quot;addOk&quot;;    &#125;    //修改用户信息    @GetMapping(&quot;/update/&#123;id&#125;&quot;)    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;        //插入语句        String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id;        //数据        Object[] objects = new Object[2];        objects[0] = &quot;秦疆&quot;;        objects[1] = &quot;24736743@sina.com&quot;;        jdbcTemplate.update(sql,objects);        //查询        return &quot;updateOk&quot;;    &#125;    //删除用户    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;        //插入语句        String sql = &quot;delete from employee where id=?&quot;;        jdbcTemplate.update(sql,id);        //查询        return &quot;deleteOk&quot;;    &#125;    &#125;\n\n即使不使用第三方第数据库操作框架，如 MyBatis等，Spring本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。\nJdbcTemplate主要提供以下几类方法：\n\nexecute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\nupdate方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；\nquery方法及queryForXXX方法：用于执行查询相关语句；\ncall方法：用于执行存储过程、函数相关语句。\n\n\n\n11 整合DruidDruid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。\nGithub地址：https://github.com/alibaba/druid/\ncom.alibaba.druid.pool.DruidDataSource 基本配置参数\n\n\n\n配置\n缺省值\n说明\n\n\n\nname\n\n配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。  如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this)\n\n\njdbcUrl\n\n连接数据库的url，不同数据库不一样。例如：  mysql : jdbc:mysql://10.20.153.104:3306/druid2  oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto\n\n\nusername\n\n连接数据库的用户名\n\n\npassword\n\n连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\n\n\ndriverClassName\n根据url自动识别\n这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)\n\n\ninitialSize\n0\n初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时\n\n\nmaxActive\n8\n最大连接池数量\n\n\nmaxIdle\n8\n已经不再使用，配置了也没效果\n\n\nminIdle\n\n最小连接池数量\n\n\nmaxWait\n\n获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\n\n\npoolPreparedStatements\nfalse\n是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。\n\n\nmaxOpenPreparedStatements\n-1\n要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100\n\n\nvalidationQuery\n\n用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。\n\n\ntestOnBorrow\ntrue\n申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n\n\ntestOnReturn\nfalse\n归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\n\n\ntestWhileIdle\nfalse\n建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n\n\ntimeBetweenEvictionRunsMillis\n\n有两个含义：  1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n\n\nnumTestsPerEvictionRun\n\n不再使用，一个DruidDataSource只支持一个EvictionRun\n\n\nminEvictableIdleTimeMillis\n\n\n\n\nconnectionInitSqls\n\n物理连接初始化的时候执行的sql\n\n\nexceptionSorter\n根据dbType自动识别\n当数据库抛出一些不可恢复的异常时，抛弃连接\n\n\nfilters\n\n属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：  监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall\n\n\nproxyFilters\n\n类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系\n\n\n配置Druid数据源\n添加Druid数据源Maven依赖；\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;\n\n在yaml配置文件中切换数据源并设置数据源连接初始化大小、最大连接数、等待时间、最小连接数等；\nspring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource #自定义数据源    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n导入Log4j的Maven依赖；\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\n为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中。\nimport com.alibaba.druid.pool.DruidDataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class DruidConfig &#123;    /*       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中     */    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    @Bean    public DataSource druidDataSource() &#123;        return new DruidDataSource();    &#125;&#125;\n\n\n\n测试数据源连接。\n@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;    //DI注入数据源    @Autowired    DataSource dataSource;    @Test    public void contextLoads() throws SQLException &#123;        //看一下默认数据源        System.out.println(dataSource.getClass());        //获得连接        Connection connection =   dataSource.getConnection();        System.out.println(connection);        DruidDataSource druidDataSource = (DruidDataSource) dataSource;        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());        //关闭连接        connection.close();    &#125;&#125;\n\n配置Druid数据源监控Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看。\n\n设置 Druid 的后台管理页面（登录账号、密码……），配置后台管理。\n//配置 Druid 监控管理后台的Servlet；//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式@Beanpublic ServletRegistrationBean statViewServlet() &#123;    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet     // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号    initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码    //后台允许谁可以访问    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问    initParams.put(&quot;allow&quot;, &quot;&quot;);    //deny：Druid 后台拒绝谁访问    //initParams.put(&quot;deny&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问    //设置初始化参数    bean.setInitParameters(initParams);    return bean;&#125;\n\n配置 Druid web 监控 filter 过滤器。\n//配置 Druid 监控 之  web 监控的 filter//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计@Beanpublic FilterRegistrationBean webStatFilter() &#123;    FilterRegistrationBean bean = new FilterRegistrationBean();    bean.setFilter(new WebStatFilter());    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;);    bean.setInitParameters(initParams);    //&quot;/*&quot; 表示过滤所有请求    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));    return bean;&#125;\n\n\n\n12 整合Mybatis官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\n\n导入Mybatis所需的Maven依赖（maven配置资源过滤）；\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;...&lt;resources&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;        &lt;filtering&gt;true&lt;/filtering&gt;    &lt;/resource&gt;&lt;/resources&gt;\n\n配置数据库连接信息；\nspring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n整合Mybatis\nmybatis.type-aliases-package=com.zhg.pojomybatis.mapper-locations=classpath:mybatis/mapper/*.xml\n\n创建实体类；\nDepartement.java\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class Department &#123;    private Integer id;    private String departmentName;&#125;\n\n创建mapper目录以及对应的 Mapper接口；\nDepartmentMapper.java\n//@Mapper : 表示本类是一个 MyBatis 的 Mapper@Mapper@Repositorypublic interface DepartmentMapper &#123;    // 获取所有部门信息    List&lt;Department&gt; getDepartments();    // 通过id获得部门    Department getDepartment(Integer id);&#125;\n\n编写Mapper映射文件；\nDepartmentMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.DepartmentMapper&quot;&gt;    &lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt;       select * from department;    &lt;/select&gt;    &lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt;       select * from department where id = #&#123;id&#125;;    &lt;/select&gt;&lt;/mapper&gt;\n\n编写Controller进行测试。\nDepartmentController.java\n@RestControllerpublic class DepartmentController &#123;        @Autowired    DepartmentMapper departmentMapper;        // 查询全部部门    @GetMapping(&quot;/getDepartments&quot;)    public List&lt;Department&gt; getDepartments()&#123;        return departmentMapper.getDepartments();    &#125;    // 查询全部部门    @GetMapping(&quot;/getDepartment/&#123;id&#125;&quot;)    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id)&#123;        return departmentMapper.getDepartment(id);    &#125;    &#125;\n\n\n\n13 SpringSecurity两个框架：Shiro、SpringSecurity\n\n功能权限\n访问权限\n菜单权限\n…拦截器，过滤器：大量冗余\n\n思想：AOP\nSpring Security是一个功能强大、高度可定制的身份验证和访问控制框架，它也是SpringBoot底层安全模块默认的技术选型，专注于向Java应用程序提供身份验证和授权。\nSpringSecurity的两个主要目标是”认证“和”授权“（访问控制）。\n\nWebSecurityConfigurationAdapter：自定义Security策略\nAuthenticationManagerBuilder：自定义认证策略\n@EnableWebSecurity：开启WebSecurity模式\n\n官网：https://spring.io/projects/spring-security\n文档：https://docs.spring.io/spring-security/site/docs/5.2.0.RELEASE/reference/htmlsingle/\n使用 Spring Security 增加认证和授权的功能，实现访问控制。\n1 引入 Spring Security 模块\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2 编写 Spring Security 配置类\npackage com.zhg.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter&#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        // 定制请求的授权规则        // 首页所有人可以访问        http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()                .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)                .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)                .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);                // 开启自动配置的登录功能                // /login 请求来到登录页                // /login?error 重定向到这里表示登录失败                http.formLogin();    &#125;    //定义认证规则    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        //在内存中定义，也可以在jdbc中去拿....        //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。        //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密        //spring security 官方推荐的是使用bcrypt加密方式。        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;zhg&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);    &#125;&#125;\n\n13.1 注销1 开启自动配置的注销的功能；\n//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;   //....   //开启自动配置的注销的功能      // /logout 注销请求   http.logout();&#125;\n\n2 index.html 导航栏中增加注销按钮；\n&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销&lt;/a&gt;\n\n3 可以通过logoutSuccessUrl指定注销成功跳转的网页。\n// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页http.logout().logoutSuccessUrl(&quot;/&quot;);\n\n注：为防止csrf跨站请求伪造，可能会出现注销404，可以将请求改为post表单提交，或者在spring security中关闭csrf功能。\nhttp.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求http.logout().logoutSuccessUrl(&quot;/&quot;);\n\n13.2 权限控制结合thymeleaf中的sec:authorize=&quot;isAuthenticated()&quot;判断是否认证登录来显示不同的页面。\n1 导入Maven依赖；\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.thymeleaf.extras&#x2F;thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;&#x2F;artifactId&gt;   &lt;version&gt;3.0.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;\n\n2 修改前端页面；\n2.1 导入命名空间\n xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;\n\n2.2 修改导航栏，增加认证判断\n &lt;!--登录注销--&gt;&lt;div class=&quot;right menu&quot;&gt;   &lt;!--如果未登录--&gt;   &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录       &lt;/a&gt;   &lt;/div&gt;   &lt;!--如果已登录--&gt;   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;       &lt;a class=&quot;item&quot;&gt;           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;          用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;          角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;       &lt;/a&gt;   &lt;/div&gt;   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销       &lt;/a&gt;   &lt;/div&gt;&lt;/div&gt;\n\n2.3 修改主页，实现角色功能块\n&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt;   &lt;div class=&quot;ui raised segment&quot;&gt;       &lt;div class=&quot;ui&quot;&gt;           &lt;div class=&quot;content&quot;&gt;               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;               &lt;hr&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt;   &lt;div class=&quot;ui raised segment&quot;&gt;       &lt;div class=&quot;ui&quot;&gt;           &lt;div class=&quot;content&quot;&gt;               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;               &lt;hr&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt;   &lt;div class=&quot;ui raised segment&quot;&gt;       &lt;div class=&quot;ui&quot;&gt;           &lt;div class=&quot;content&quot;&gt;               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;               &lt;hr&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;&lt;/div&gt;\n\n13.3 记住我1 开启记住我功能；\n//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;//...   //记住我   http.rememberMe();&#125;\n\n2 浏览器中保存用户信息的cookie，默认保留14天；\n3 点击注销的时自动删除了这个 cookie；\n结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie。\n13.4 定制登录页1 通过loginpage指定登录页面 ；\nhttp.formLogin().loginPage(&quot;/toLogin&quot;);\n\n2 login.html 配置提交请求及方式，方式必须为post；\n&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;   &lt;div class=&quot;field&quot;&gt;       &lt;label&gt;Username&lt;/label&gt;       &lt;div class=&quot;ui left icon input&quot;&gt;           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;div class=&quot;field&quot;&gt;       &lt;label&gt;Password&lt;/label&gt;       &lt;div class=&quot;ui left icon input&quot;&gt;           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;&lt;/form&gt;\n\n3 配置接收登录的用户名和密码的参数；\nhttp.formLogin()  .usernameParameter(&quot;username&quot;)  .passwordParameter(&quot;password&quot;)  .loginPage(&quot;/toLogin&quot;)  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求\n\n4 登录页增加记住我的多选框；\n&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我\n\n5 后端验证处理。\n//定制记住我的参数！http.rememberMe().rememberMeParameter(&quot;remember&quot;);\n\n完整配置代码package com.zhg.config;importorg.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;importorg.springframework.security.config.annotation.web.configuration.EnableWebSecurity;importorg.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;   //定制请求的授权规则   @Override   protected void configure(HttpSecurity http) throws Exception &#123;       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！           // /login 请求来到登录页           // /login?error 重定向到这里表示登录失败       http.formLogin()          .usernameParameter(&quot;username&quot;)          .passwordParameter(&quot;password&quot;)          .loginPage(&quot;/toLogin&quot;)          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求       //开启自动配置的注销的功能           // /logout 注销请求           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求       http.logout().logoutSuccessUrl(&quot;/&quot;);       //记住我       http.rememberMe().rememberMeParameter(&quot;remember&quot;);  &#125;   //定义认证规则   @Override   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;       //在内存中定义，也可以在jdbc中去拿....       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密       //spring security 官方推荐的是使用bcrypt加密方式。       auth.inMemoryAuthentication().passwordEncoder(newBCryptPasswordEncoder())              .withUser(&quot;kuangshen&quot;).password(newBCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)              .and()              .withUser(&quot;root&quot;).password(newBCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)              .and()              .withUser(&quot;guest&quot;).password(newBCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);  &#125;&#125;\n\n14 ShiroApache Shiro是一个Java的安全（权限）框架，JavaSE和JavaEE环境中都可以使用，可以完成认证、授权、加密、会话管理、Web集成、缓存等。\n下载地址：http://shiro.apache.org/\n14.1 Shiro功能\n\nAuthentication：身份认证、登录，验证用户身份； \n\nAuthorization：授权，即权限验证，验证用户权限，即判断用户能否进行相应权限的操作；\n\nSession Manager：会话管理，存储会话中用户登录的所有信息；会话可以是普通的JavaSE环境，也可以是Web环境；\n\nCryptography：加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储； \n\nWeb Support：Web支持，可以非常容易的集成到Web环境； \n\nCaching：缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，可以提高效率； \n\nConcurrency：Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去 ；\n\nTesting：提供测试支持； \n\nRun As：允许一个用户假装为另一个用户（如果允许）的身份进行访问； \n\nRemember Me：记住我，不用重复登录。\n\n\n14.2 Shiro架构\nsubject： 应用代码直接交互的对象是Subject，是Shiro的对外API的核心， Subject代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，与Subject的所有交互都会委托给SecurityManager；\nSecurityManager：安全管理器，即所有与安全有关的操作都会与SercurityManager交互，并且它管理着所有的Subject，可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于 SpringMVC的DispatcherServlet的角色； \nRealm：Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager 要验证用户身份，那么它需要从Realm 获取相应的用户进行比较，来确定用户的身份是否合法；也需要从 Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把Realm看成 DataSource；\n14.3 整合Shiro\n导入Shiro和Spring整合的依赖；\n&lt;dependency&gt;\t&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\t&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\t&lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;\n\n编写Shiro配置类；\npackage com.zhg.config;import org.springframework.context.annotation.Configuration;//声明为配置类@Configurationpublic class ShiroConfig &#123;\t    //创建 ShiroFilterFactoryBean\t    //创建 DefaultWebSecurityManager\t    //创建 realm 对象&#125;\n\n创建自定义realm类；\npackage com.zhg.config;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;//自定义Realmpublic class UserRealm extends AuthorizingRealm &#123;\t//执行授权逻辑\t@Override\tprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;\t\tSystem.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);\t\treturn null;\t&#125;    //执行认证逻辑\t@Override\tprotected AuthenticationInfodoGetAuthenticationInfo(AuthenticationToken token) throwsAuthenticationException &#123;\t\tSystem.out.println(&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;);\t\treturn null;\t&#125;&#125;\n\n将realm类注册到Bean中；\npackage com.zhg.config;import org.springframework.context.annotation.Configuration;//声明为配置类@Configurationpublic class ShiroConfig &#123;\t    //创建 ShiroFilterFactoryBean\t    //创建 DefaultWebSecurityManager\t    //创建 realm 对象    @Bean\tpublic UserRealm userRealm()&#123;\t\treturn new UserRealm();\t&#125;&#125;\n\n创建DefaultWebSecurityManager；\n//创建 DefaultWebSecurityManager@Bean(name = &quot;securityManager&quot;)public DefaultWebSecurityManagergetDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm)&#123;\tDefaultWebSecurityManager securityManager = newDefaultWebSecurityManager();\t//关联Realm\tsecurityManager.setRealm(userRealm);\treturn securityManager;&#125;\n\n创建ShiroFilterFactoryBean。\n//创建 ShiroFilterFactoryBean@Beanpublic ShiroFilterFactoryBeangetShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;)DefaultWebSecurityManager securityManager)&#123;\tShiroFilterFactoryBean shiroFilterFactoryBean = newShiroFilterFactoryBean();\t//设置安全管理器\tshiroFilterFactoryBean.setSecurityManager(securityManager);\treturn shiroFilterFactoryBean;&#125;\n\n\n\n14.4 登录认证\n整合数据库，导入Mybatis相关依赖，配置Mybatis并编写UserService，实现queryUserByName（查询用户信息）；\n\n编写登录的Controller和登录页面；\nUserController\n//登录操作@RequestMapping(&quot;/login&quot;)public String login(String username,String password,Model model)&#123;\t//使用shiro，编写认证操作\t    //1. 获取Subject\tSubject subject = SecurityUtils.getSubject();\t//2. 封装用户的数据\tUsernamePasswordToken token = new UsernamePasswordToken(username,password);\t//3. 执行登录的方法，只要没有异常就代表登录成功！\ttry &#123;\t\tsubject.login(token); //登录成功！返回首页\t\treturn &quot;index&quot;;\t&#125; catch (UnknownAccountException e) &#123; //用户名不存在\t\tmodel.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;);\t\treturn &quot;login&quot;;\t&#125; catch (IncorrectCredentialsException e) &#123; //密码错误\t\tmodel.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;);\t\treturn &quot;login&quot;;\t&#125;&#125;\n\n在 UserRealm 中编写用户认证的判断逻辑。\n//自定义Realmpublic class UserRealm extends AuthorizingRealm &#123;\t@Autowired\tUserService userService;    \t//执行授权逻辑\t@Override\tprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;\t\tSystem.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);\t\treturn null;\t&#125;    \t//执行认证逻辑\t@Override\tprotected AuthenticationInfodoGetAuthenticationInfo(AuthenticationToken token) throwsAuthenticationException &#123;\t\tSystem.out.println(&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;);        UsernamePasswordToken userToken = (UsernamePasswordToken)token;\t\t//真实连接数据库\t\tUser user =userService.queryUserByName(userToken.getUsername());        if (user==null)&#123;\t\t\t//用户名不存在\t\t\treturn null; //shiro底层就会抛出 UnknownAccountException\t\t&#125;\t\treturn new SimpleAuthenticationInfo(&quot;&quot;, user.getPwd(), &quot;&quot;);\t&#125;&#125;\n\n\n\n14.5 拦截和授权页面拦截\n\n添加Shiro的内置过滤器。\n@Beanpublic ShiroFilterFactoryBeangetShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;)DefaultWebSecurityManager securityManager)&#123;\tShiroFilterFactoryBean shiroFilterFactoryBean = newShiroFilterFactoryBean();\t//设置安全管理器\tshiroFilterFactoryBean.setSecurityManager(securityManager);    /*        添加Shiro内置过滤器，常用的有如下过滤器：        anon： 无需认证就可以访问        authc： 必须认证才可以访问        user： 如果使用了记住我功能就可以直接访问        perms: 拥有某个资源权限才可以访问        role： 拥有某个角色权限才可以访问    */    Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String, String&gt;();    //filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);\t//filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);    //授权过滤器\t//filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);\tfilterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);\t//修改到要跳转的login页面；\tshiroFilterFactoryBean.setLoginUrl(&quot;/toLogin&quot;);    return shiroFilterFactoryBean;&#125;\n\n\n\nShiro授权\n\n数据库用户表增加用户权限字段并修改实体类；\n\n将用户放在Principle中；\nreturn new SimpleAuthenticationInfo(user, user.getPwd(), &quot;&quot;);\n\n获取用户权限并授权；\n//执行授权逻辑@Overrideprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;    System.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);    //给资源进行授权    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();    //添加资源的授权字符串    //info.addStringPermission(&quot;user:add&quot;);    Subject subject = SecurityUtils.getSubject(); //获得当前对象    User currentUser = (User) subject.getPrincipal(); //拿到User对象    info.addStringPermission(currentUser.getPerms()); //设置权限    return info;&#125;\n\n请求权限拦截。\n//授权过滤器filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;);\n\n\n\n15 Swagger产生的问题：前后端集成中，前端或者后端无法做到“及时协商，尽早解决”。\n解决方案：首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险。\n\nSwagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。\n\n作用：\n\n接口的文档在线自动生成。\n功能测试。\n\nSpringBoot集成Swagger\n添加Maven依赖\n&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;\n\nSwagger配置类\n@Configuration //配置类@EnableSwagger2// 开启Swagger2的自动配置public class SwaggerConfig &#123;      @Bean //配置docket以配置Swagger具体参数    public Docket docket() &#123;       return new Docket(DocumentationType.SWAGGER_2)          .apiInfo(apiInfo())           //通过enable()方法配置是否启用swagger          .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口          .apis(RequestHandlerSelectors.basePackage(&quot;com.zhg.swagger.controller&quot;))           // 配置如何通过path过滤,即这里只扫描请求以/zhg开头的接口          .paths(PathSelectors.ant(&quot;/zhg/**&quot;))           /*           PathSelectors的可选项还有           any() // 任何请求都扫描           none() // 任何请求都不扫描           regex(final String pathRegex) // 通过正则表达式控制           ant(final String antPattern) // 通过ant()控制           */          .build();          //可以创建多个Docket对象，通过.groupName(&quot;groupX&quot;)进行分组    &#125;    //配置文档信息    private ApiInfo apiInfo() &#123;       Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);       return new ApiInfo(               &quot;Swagger学习&quot;, // 标题               &quot;学习演示如何配置Swagger&quot;, // 描述               &quot;v1.0&quot;, // 版本               &quot;http://terms.service.url/组织链接&quot;, // 组织链接               contact, // 联系人信息               &quot;Apach 2.0 许可&quot;, // 许可               &quot;许可链接&quot;, // 许可连接               new ArrayList&lt;&gt;()// 扩展      );    &#125;&#125;\n\n常用注解\n@Api：用在类上，说明该类的作用。@ApiOperation：注解来给API增加方法说明。@ApiImplicitParams : 用在方法上包含一组参数说明。@ApiImplicitParam：用来注解来给方法入参增加说明。参数：   ·paramType：指定参数放在哪个地方      ··header：请求参数放置于Request Header，使用@RequestHeader获取      ··query：请求参数放置于请求地址，使用@RequestParam获取      ··path：（用于restful接口）--&gt;请求参数的获取：@PathVariable      ··body：（不常用）      ··form（不常用）   ·name：参数名   ·dataType：参数类型   ·required：参数是否必须传(true | false)   ·value：说明参数的意思   ·defaultValue：参数的默认值@ApiResponses：用于表示一组响应@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息      ——code：数字，例如400      ——message：信息，例如&quot;请求参数异常!&quot;      ——response：抛出异常的类   @ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）@ApiModelProperty：描述一个model的属性\n\n16 任务16.1 异步任务创建AsyncService类，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况。\n@Servicepublic class AsyncService &#123;   @Async //告诉Spring这是一个异步方法   public void hello()&#123;       try &#123;           Thread.sleep(3000);      &#125; catch (InterruptedException e) &#123;           e.printStackTrace();      &#125;       System.out.println(&quot;业务进行中....&quot;);  &#125;&#125;\n\nAsyncController类\n@RestControllerpublic class AsyncController &#123;   @Autowired   AsyncService asyncService;   @GetMapping(&quot;/hello&quot;)   public String hello()&#123;       asyncService.hello();       return &quot;success&quot;;  &#125;&#125;\n\nSpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能.\n@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class SpringbootTaskApplication &#123;   public static void main(String[] args) &#123;       SpringApplication.run(SpringbootTaskApplication.class, args);  &#125;&#125;\n\n16.2 定时任务Spring为我们提供了异步执行任务调度的方式，提供了两个接口。\n\nTaskExecutor接口\nTaskScheduler接口\n\n两个注解：\n\n@EnableScheduling\n@Scheduled\n\ncron表达式\n\n创建ScheduledService\n@Servicepublic class ScheduledService &#123;      //秒   分   时     日   月   周几   //0 * * * * MON-FRI   //注意cron表达式的用法；   @Scheduled(cron = &quot;0 * * * * 0-7&quot;)   public void hello()&#123;       System.out.println(&quot;hello.....&quot;);  &#125;&#125;\n\n主程序\n@EnableAsync //开启异步注解功能@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class SpringbootTaskApplication &#123;   public static void main(String[] args) &#123;       SpringApplication.run(SpringbootTaskApplication.class, args);  &#125;&#125;\n\n常用表达式\n0 0 12 * * ? 每天12点触发0 15 10 ? * * 每天10点15分触发0 15 10 * * ? 每天10点15分触发0 15 10 * * ? * 每天10点15分触发0 15 10 * * ? 2005 2005年每天10点15分触发0 * 14 * * ? 每天下午的 2点到2点59分每分触发0 0&#x2F;5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发)0 0&#x2F;5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发)以及每天下午的 18点到18点59分(整点开始，每隔5分触发)0 0-5 14 * * ? 每天下午的 2点到2点05分每分触发0 10,44 14 ? 3 WED 3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或 两次以上的情况）0 59 2 ? * FRI 每周5凌晨2点59分触发；0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发0 15 10 15 * ? 每月15号上午10点15分触发0 15 10 L * ? 每月最后一天的10点15分触发0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发0 15 10 ? * 6#3 每月的第三周的星期五开始触发0 0 12 1&#x2F;5 * ? 每月的第一个中午开始每隔5天触发一次0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)\n\n16.3 邮件任务邮件发送需要引入spring-boot-start-mail，自动装配JavaMailSender，需要配置application.yml。\n添加Maven依赖\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;\n\n相关配置\nspring.mail.username=24736743@qq.comspring.mail.password=你的qq授权码spring.mail.host=smtp.qq.com# qq需要配置sslspring.mail.properties.mail.smtp.ssl.enable=true\n\nQQ邮箱账户需要开启pop3和smtp服务\n测试\n@AutowiredJavaMailSenderImpl mailSender;@Testpublic void contextLoads() &#123;   //邮件设置1：一个简单的邮件   SimpleMailMessage message = new SimpleMailMessage();   message.setSubject(&quot;通知-明天来狂神这听课&quot;);   message.setText(&quot;今晚7:30开会&quot;);   message.setTo(&quot;XXX@qq.com&quot;);   message.setFrom(&quot;XXX@qq.com&quot;);   mailSender.send(message);&#125;@Testpublic void contextLoads2() throws MessagingException &#123;   //邮件设置2：一个复杂的邮件   MimeMessage mimeMessage = mailSender.createMimeMessage();   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);   helper.setSubject(&quot;通知-明天来狂神这听课&quot;);   helper.setText(&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true);   //发送附件   helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;));   helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));   helper.setTo(&quot;XXX@qq.com&quot;);   helper.setFrom(&quot;XXX@qq.com&quot;);   mailSender.send(mimeMessage);&#125;\n\n17 整合RedisSpring Data：Spring 的一个子项目。用于简化数据库访问，支持NoSQL（MongoDB，Neo4j，Redis，Hbase）和关系数据库存储（JDBC，JPA）。其主要目标是使数据库的访问变得方便快捷。\n说明：在SpringBoot2.x之后，原来使用的Jedis被替换为了lettuce。\nJedis：底层采用的是直连，多个线程操作的话，是不安全的，如果要避免不安全的，使用Jedis Pool连接池，更像BIO模式。\nLettuce：采用Netty，实例可以再用多个线程中进行共享，不存在线程不安全的情况。可以减少线程数据了，更像NIO模式。\n在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。\n1、 JedisPoolConfig (这个是配置连接池)\n2、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在Spring Data Redis方案中提供了以下四种工厂模型：\n\nJredisConnectionFactory\nJedisConnectionFactory\nLettuceConnectionFactory\nSrpConnectionFactory\n\n3、 RedisTemplate 基本操作\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\nyaml配置\nspring:    redis:        host: 127.0.0.1        port: 6379        password: 123456        jedis:            pool:                max-active: 8                max-wait: -1ms                max-idle: 500                min-idle: 0        lettuce:        \tshutdown-timeout: 0ms\n\n测试\n@SpringBootTestclass SpringbootRedisApplicationTests &#123;    @Autowired    private RedisTemplate&lt;String,String&gt; redisTemplate;    @Test    void contextLoads() &#123;        redisTemplate.opsForValue().set(&quot;myKey&quot;,&quot;myValue&quot;);        System.out.println(redisTemplate.opsForValue().get(&quot;myKey&quot;));    &#125;&#125;\n\n封装工具类1、新建一个SpringBoot项目 \n2、导入redis的启动器\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n3、配置redis，可以查看 RedisProperties 分析\n# Redis服务器地址spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379\n\n4、分析 RedisAutoConfiguration 自动配置类\n@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class,JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123;    @Bean    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)    public RedisTemplate&lt;Object, Object&gt;    redisTemplate(RedisConnectionFactory redisConnectionFactory)    throws UnknownHostException &#123;        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        return template;    &#125;    @Bean    @ConditionalOnMissingBean    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory    redisConnectionFactory)    throws UnknownHostException &#123;        StringRedisTemplate template = new StringRedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        return template;    &#125;&#125;\n\n通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个 StringRedisTemplate。 \n但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我 们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。 \n并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。 \n看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了， 这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置 RedisTemplate。\n5、重新配置一个RedisTemplate\npackage com.kuang.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;importorg.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123;    @Bean    @SuppressWarnings(&quot;all&quot;)    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory    factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String,        Object&gt;();        template.setConnectionFactory(factory);        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new        Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        StringRedisSerializer stringRedisSerializer = new        StringRedisSerializer();        // key采用String的序列化方式        template.setKeySerializer(stringRedisSerializer);        // hash的key也采用String的序列化方式        template.setHashKeySerializer(stringRedisSerializer);        // value序列化方式采用jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        // hash的value序列化方式采用jackson        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;\n\n6、封装一个Redis工具类RedisUtils\npackage com.kuang.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Componentpublic final class RedisUtil &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    // =============================common============================    /**    * 指定缓存失效时间    * @param key 键    * @param time 时间(秒)    */    public boolean expire(String key, long time) &#123;        try &#123;            if (time &gt; 0) &#123;        redisTemplate.expire(key, time, TimeUnit.SECONDS);        &#125;        return true;        &#125; catch (Exception e) &#123;        e.printStackTrace();        return false;        &#125;    &#125;    /**    * 根据key 获取过期时间    * @param key 键 不能为null    * @return 时间(秒) 返回0代表为永久有效    */    public long getExpire(String key) &#123;    \treturn redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    /**    * 判断key是否存在    * @param key 键    * @return true 存在 false不存在    */    public boolean hasKey(String key) &#123;        try &#123;        return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;        e.printStackTrace();        return false;    \t&#125;    &#125;    /**    * 删除缓存    * @param key 可以传一个值 或多个    */    @SuppressWarnings(&quot;unchecked&quot;)    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length &gt; 0) &#123;            if (key.length == 1) &#123;            redisTemplate.delete(key[0]);            &#125; else &#123;            redisTemplate.delete(CollectionUtils.arrayToList(key));            &#125;        &#125;    &#125;    // ============================String=============================    /**    * 普通缓存获取    * @param key 键    * @return 值    */    public Object get(String key) &#123;    \treturn key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    /**    * 普通缓存放入    * @param key 键    * @param value 值    * @return true成功 false失败    */    public boolean set(String key, Object value) &#123;        try &#123;        \tredisTemplate.opsForValue().set(key, value);        \treturn true;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 普通缓存放入并设置时间    * @param key 键    * @param value 值    * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期    * @return true成功 false 失败    */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time,                TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;        \treturn true;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 递增    * @param key 键    * @param delta 要增加几(大于0)    */    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;        \tthrow new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    /**    * 递减    * @param key 键    * @param delta 要减少几(小于0)    */    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;        \tthrow new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // ================================Map=================================    /**    * HashGet    * @param key 键 不能为null    * @param item 项 不能为null    */    public Object hget(String key, String item) &#123;    \treturn redisTemplate.opsForHash().get(key, item);    &#125;    /**    * 获取hashKey对应的所有键值    * @param key 键    * @return 对应的多个键值    */    public Map&lt;Object, Object&gt; hmget(String key) &#123;    \treturn redisTemplate.opsForHash().entries(key);    &#125;    /**    * HashSet    * @param key 键    * @param map 对应多个键值    */    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**    * HashSet 并设置时间    * @param key 键    * @param map 对应多个键值    * @param time 时间(秒)    * @return true成功 false失败    */    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;            \texpire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;       \t\te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 向一张hash表中放入数据,如果不存在将创建    *    * @param key 键    * @param item 项    * @param value 值    * @return true 成功 false失败    */    public boolean hset(String key, String item, Object value) &#123;        try &#123;        \tredisTemplate.opsForHash().put(key, item, value);        \treturn true;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 向一张hash表中放入数据,如果不存在将创建    *    * @param key 键    * @param item 项    * @param value 值    * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间    * @return true 成功 false失败    */    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;        \tredisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;            \texpire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**    * 删除hash表中的值    *    * @param key 键 不能为null    * @param item 项 可以使多个 不能为null    */    public void hdel(String key, Object... item) &#123;    \tredisTemplate.opsForHash().delete(key, item);    &#125;    /**    * 判断hash表中是否有该项的值    *    * @param key 键 不能为null    * @param item 项 不能为null    * @return true 存在 false不存在    */    public boolean hHasKey(String key, String item) &#123;    \treturn redisTemplate.opsForHash().hasKey(key, item);    &#125;    /**    * hash递增 如果不存在,就会创建一个 并把新增后的值返回    *    * @param key 键    * @param item 项    * @param by 要增加几(大于0)    */    public double hincr(String key, String item, double by) &#123;    \treturn redisTemplate.opsForHash().increment(key, item, by);    &#125;    /**    * hash递减    *    * @param key 键    * @param item 项    * @param by 要减少记(小于0)    */    public double hdecr(String key, String item, double by) &#123;    \treturn redisTemplate.opsForHash().increment(key, item, -by);    &#125;    // ============================set=============================    /**    * 根据key获取Set中的所有值    * @param key 键    */    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;        \treturn redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn null;        &#125;    &#125;    /**    * 根据value从一个set中查询,是否存在    *    * @param key 键    * @param value 值    * @return true 存在 false不存在    */    public boolean sHasKey(String key, Object value) &#123;        try &#123;        \treturn redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 将数据放入set缓存    *    * @param key 键    * @param values 值 可以是多个    * @return 成功个数    */    public long sSet(String key, Object... values) &#123;        try &#123;        \treturn redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn 0;        &#125;    &#125;    /**    * 将set数据放入缓存    *    * @param key 键    * @param time 时间(秒)    * @param values 值 可以是多个    * @return 成功个数    */    public long sSetAndTime(String key, long time, Object... values) &#123;        try &#123;        \tLong count = redisTemplate.opsForSet().add(key, values);        \tif (time &gt; 0)        \texpire(key, time);        \treturn count;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn 0;        &#125;    &#125;    /**    * 获取set缓存的长度    *    * @param key 键    */    public long sGetSetSize(String key) &#123;        try &#123;        \treturn redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn 0;        &#125;    &#125;    /**    * 移除值为value的    *    * @param key 键    * @param values 值 可以是多个    * @return 移除的个数    */    public long setRemove(String key, Object... values) &#123;        try &#123;        \tLong count = redisTemplate.opsForSet().remove(key, values);        \treturn count;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn 0;        &#125;    &#125;    // ===============================list=================================    /**    * 获取list缓存的内容    *    * @param key 键    * @param start 开始    * @param end 结束 0 到 -1代表所有值    */    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;        try &#123;        \treturn redisTemplate.opsForList().range(key, start, end);        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn null;        &#125;    &#125;    /**    * 获取list缓存的长度    *    * @param key 键    */    public long lGetListSize(String key) &#123;    \ttry &#123;    \t\treturn redisTemplate.opsForList().size(key);    \t&#125; catch (Exception e) &#123;    \t\te.printStackTrace();    \t\treturn 0;    \t&#125;    &#125;    /**    * 通过索引 获取list中的值    *    * @param key 键    * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0    时，-1，表尾，-2倒数第二个元素，依次类推    */    public Object lGetIndex(String key, long index) &#123;        try &#123;        \treturn redisTemplate.opsForList().index(key, index);        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn null;        &#125;    &#125;    /**    * 将list放入缓存    *    * @param key 键    * @param value 值    */    public boolean lSet(String key, Object value) &#123;        try &#123;        \tredisTemplate.opsForList().rightPush(key, value);        \treturn true;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 将list放入缓存    * @param key 键    * @param value 值    * @param time 时间(秒)    */    public boolean lSet(String key, Object value, long time) &#123;        try &#123;        \tredisTemplate.opsForList().rightPush(key, value);        \tif (time &gt; 0)        \t\texpire(key, time);        \treturn true;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 将list放入缓存    *    * @param key 键    * @param value 值    * @return    */    public boolean lSet(String key, List&lt;Object&gt; value) &#123;        try &#123;        \tredisTemplate.opsForList().rightPushAll(key, value);        \treturn true;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn false;        &#125;    &#125;    /**    * 将list放入缓存    *    * @param key 键    * @param value 值    * @param time 时间(秒)    * @return    */    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;        try &#123;        \tredisTemplate.opsForList().rightPushAll(key, value);            if (time &gt; 0)            \texpire(key, time);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**    * 根据索引修改list中的某条数据    *    * @param key 键    * @param index 索引    * @param value 值    * @return    */    public boolean lUpdateIndex(String key, long index, Object value) &#123;        try &#123;            redisTemplate.opsForList().set(key, index, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**    * 移除N个值为value    *    * @param key 键    * @param count 移除多少个    * @param value 值    * @return 移除的个数    */    public long lRemove(String key, long count, Object value) &#123;        try &#123;            Long remove = redisTemplate.opsForList().remove(key, count,            value);            return remove;        &#125; catch (Exception e) &#123;        \te.printStackTrace();        \treturn 0;        &#125;    &#125;&#125;\n\n18 分布式系统\n分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。\n\n18.1 应用架构\n\n单一应用架构\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点：\n\n性能扩展比较难\n协同开发问题\n不利于升级维护\n\n\n垂直应用架构\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n缺点：公用模块无法重复利用，开发性的浪费\n\n分布式服务架构\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n\n流式计算架构\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的**资源调度和治理中心(SOA)[ Service Oriented Architecture]**是关键。\n\n\n18.2 RPC\nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b\n基本原理\n\n步骤解析：\n\nRPC两个核心模块：通讯，序列化。\n18.3 Dubbo\nApache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\n\ndubbo官网 http://dubbo.apache.org/zh-cn/index.html\n基本概念\n\n服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n调用关系说明\nl 服务容器负责启动，加载，运行服务提供者。\nl 服务提供者在启动时，向注册中心注册自己提供的服务。\nl 服务消费者在启动时，向注册中心订阅自己所需的服务。\nl 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\nl 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\nl 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n环境搭建\nDubbo官方文档，推荐使用Zookeeper注册中心\nWindows下安装Zookeeper\n\n下载zookeeper 最新版并解压；\n\n运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；\n\n修改zoo.cfg配置文件（将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可），修改完成后再次启动zookeeper；\n注意几个重要位置：\ndataDir&#x3D;.&#x2F;   临时数据存储的目录（可写相对路径）clientPort&#x3D;2181   zookeeper的端口号\n\n使用zkCli.cmd测试（ls /：列出zookeeper根下保存的所有节点）。\n[zk: 127.0.0.1:2181(CONNECTED) 4] ls &#x2F;[zookeeper]create –e &#x2F;zhg 123：创建一个kuangshen节点，值为123get &#x2F;zhg：获取&#x2F;kuangshen节点的值[zk: 127.0.0.1:2181(CONNECTED) 4] ls &#x2F;[zhg,zookeeper]\n\n\n\ndubbo-admindubbo本身并不是一个服务软件，它其实就是一个jar包，能够帮助java程序连接到zookeeper，并利用zookeeper消费、提供服务。\n但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。\n安装步骤：\n\n下载dubbo-admin\n地址 ：https://github.com/apache/dubbo-admin/tree/master\n\n解压进入目录\n修改dubbo-admin\\src\\main\\resources\\application.properties，指定zookeeper地址。\nserver.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181\n\n项目目录下打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n执行jar包\n执行dubbo-admin\\target\\dubbo-admin-0.0.1-SNAPSHOT.jar\njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar\n\n【注意：zookeeper的服务一定要打开！】\n执行完毕后访问 http://localhost:7001/ ，输入默认的登录账户和密码：root-root；\n\n\nSpringBoot+Dubbo+Zookeeper框架搭建\n\n启动zookeeper ！\n\nIDEA创建一个空项目；\n\n创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可\n\n项目创建完毕，我们写一个服务，比如卖票的服务；\n接口\npackage com.kuang.provider.service;public interface TicketService &#123;   public String getTicket();&#125;\n\n实现\npackage com.kuang.provider.service;public class TicketServiceImpl implements TicketService &#123;   @Override   public String getTicket() &#123;       return &quot;《狂神说Java》&quot;;  &#125;&#125;\n\n创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可\n\n项目创建完毕，我们写一个服务，比如用户的服务；\nUserService\npackage com.kuang.consumer.service;public class UserService &#123;   //我们需要去拿去注册中心的服务&#125;\n\n\n\n服务提供者\n\n导入依赖；\n&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;   &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;\n\n【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；\n&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;   &lt;version&gt;3.4.14&lt;/version&gt;   &lt;!--排除这个slf4j-log4j12--&gt;   &lt;exclusions&gt;       &lt;exclusion&gt;           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;       &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;\n\n在springboot配置文件中配置dubbo相关属性；\n#当前应用名字dubbo.application.name=provider-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181#扫描指定包下服务dubbo.scan.base-packages=com.kuang.provider.service\n\n在service的实现类中配置服务注解，发布服务！注意导包问题。\nimport org.apache.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Service //将服务发布出去@Component //放在容器中public class TicketServiceImpl implements TicketService &#123;   @Override   public String getTicket() &#123;       return &quot;《狂神说Java》&quot;;  &#125;&#125;\n\n\n\n逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！\n服务消费者\n\n导入依赖；\n&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;   &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;   &lt;version&gt;3.4.14&lt;/version&gt;   &lt;!--排除这个slf4j-log4j12--&gt;   &lt;exclusions&gt;       &lt;exclusion&gt;           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;       &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;\n\n配置参数；\n#当前应用名字dubbo.application.name=consumer-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181\n\n本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接复制服务的接口，路径必须保证正确，即和服务提供者相同；\n\n完善消费者的服务类；\npackage com.kuang.consumer.service;import com.kuang.provider.service.TicketService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Service;@Service //注入到容器中public class UserService &#123;   @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名   TicketService ticketService;   public void bugTicket()&#123;       String ticket = ticketService.getTicket();       System.out.println(&quot;在注册中心买到&quot;+ticket);  &#125;&#125;\n\n测试类编写。\n@RunWith(SpringRunner.class)@SpringBootTestpublic class ConsumerServerApplicationTests &#123;   @Autowired   UserService userService;   @Test   public void contextLoads() &#123;       userService.bugTicket();  &#125;&#125;\n\n\n\n\n","tags":["Java","SpringBoot"]},{"title":"JVM探究","url":"/2021/04/24/JVM%E6%8E%A2%E7%A9%B6/","content":"\n面试常见问题：\nJVM的理解？Java8虚拟机变化更新？\nOOM？栈溢出？怎么分析？\nJVM常用调优参数？\n内存快照如何抓取？怎么分析Dump文件？\n类加载器的认识？\n\n1  JVM的位置   \n2 JVM的体系结构   \n3 类加载器   作用：加载Class文件\n   new 对象 （引用：栈 值：堆） \n   getClass class类\n   getClassLoader 类加载器\n\nBootstrapClassLoader（启动类加载器）\nc++编写，加载java核心库 java.*,构造ExtClassLoader和AppClassLoader。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作\n\nExtClassLoader （标准扩展类加载器）\njava编写，加载扩展库，如classpath中的jre ，javax.*或者 java.ext.dir 指定位置中的类，开发者可以直接使用标准扩展类加载器。\n\nAppClassLoader（系统类加载器）\njava编写，加载程序所在的目录，如user.dir所在的位置的class\n\nCustomClassLoader（用户自定义类加载器）\njava编写,用户自定义的类加载器,可加载指定路径的class文件\n\n\n4 双亲委派机制   当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。\n   \n   作用：\n\n防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。\n保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。\n\n5 沙箱安全机制   沙箱是指一个限制程序运行的环境。\n   沙箱机制就是将JAVA代码限定在JVM特定的运行环境中 ，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。\n   沙箱主要限制系统资源（CPU,内存,文件系统,网络）访问，不同级别的沙箱对这些资源访问的限制也可以不一样。\n   所有的java程序运行都可以指定沙箱，可以定制安全策略。\n   组成沙箱的基本组件：\n\n字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。\n\n类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用\n\n它防止恶意代码去干涉善意的代码；\n它守护了被信任的类库边界；\n它将代码归入保护域，确定了代码可以进行哪些操作。\n\n  虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。\n  类装载器采用的机制是双亲委派模式。\n\n从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；\n由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。\n\n\n存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。\n\n安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。\n\n安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：\n\n安全提供者\n消息摘要\n数字签名\n加密\n鉴别\n\n\n\n6 Native带了native关键字的方法会进入本地方法栈调用本地接口（JNI，底层C语言库），不受Java语法规则约束。\nJNI作用：扩展Java的使用，融合不同语言。\n7 PC寄存器程序计数器（Program Counter Register）：每个线程都有一个程序计数器，是指向方法区中的方法字节码（指令代码）的指针，使执行引擎读取下一条指令。\n8 方法区方法区被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。\n静态变量、常量、类信息（构造方法、接口定义）。运行时常量池存在方法区中；但是实例变量存在堆内存中，和方法区无关。\nstatic final Class 常量池 → 方法区\n9 栈栈内存，主管程序的运行，生命周期和线程同步；\n线程结束，栈内存也是释放，对于栈不存在垃圾回收问题。\n栈存储8大基本类型、对象引用和实例方法。\n运行原理：栈帧 \n10 三种JVM\nSun公司的HotSpot 是目前使用范围最广的Java虚拟机。\n\nBEA公司的JRockit（原来的 Bea JRockit）电脑软件，系列产品是一个全面的Java运行时解决方案组合。\n\nIBM公司的J9 VM 是一个高性能的企业级 Java 虚拟机。\n\n\n11 堆一个JVM只有一个堆，可以调整大小。\n堆中存放类、方法、常量、保存所有引用类型的真实对象。\n堆内存可以分为三个区域：\n\n新生代（Eden，Survive From，Survive To）\nMinor GC\n\n老年代（Old）\nFull GC\n\n永久代（Perm）：常驻内存，存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境或者类信息。该区域不存在垃圾回收，关闭JVM就会释放这个空间的内存。\nOOM可能原因：加载了大量的第三方jar包、Tomcat部署了太多的应用、大量动态生成的反射类，不断的被加载。\n\nJDK1.6之前：永久代，常量池是在方法区\nJDK1.7：永久代慢慢退化，去永久代，常量池在堆中\nJDK 1.8之后：无永久代，常量池在元空间\n\n\n\n12 堆内存调优默认情况下，JVM分配的总内存是电脑内存的1/4，而初始化内存是1/64。可以通过-Xms1024m -Xmx1024m -XX:PrintGCDetails进行堆内存调优。\n内存参数\n-Xms1024m （堆初始化内存）     X-Memory Startup\n-Xmx1024m （堆的最大内存）     X-Memory Maximum, 注意: 堆内存大小=年轻代(1/3)+老年代(2/3)\n-Xmn256m （堆-年轻代大小）     X-Memory New, 注意: 老年代大小=Xmx-年轻代, 年轻代占比\n-Xss256k （棧-最大深度大小）     X-Stack Size\n-XX:MetaspaceSize=?m （元空间默认大小） , 注意: 元空间默认大小取决于系统内存,实测64bit-16G电脑, 默认30M\n-XX:MaxMetaspaceSize=?m （元空间最大大小） , 注意: 只要不设置上限,只要电脑内存足够就会动态增加\n-XX:SurvivorRatio=? （默认值:8, 即新生代分区比例默认 8:2, 即 Eden:S1:S2=8:1:1, S1约定于S2)\n-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器） \n-XX:+PrintGCDetails （打印详细的GC日志）\n注意:jdk1.8已经移除了-XX:PermSize 和  -XX:MaxPermGen，取而代之的是 Metaspace\n元空间在堆中逻辑上存在，物理上不存在。\nOOM：\n\n尝试扩大堆内存看结果\n\n分析内存（专业工具）\n\n\nOOM故障排查：\n\n能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler\nDebug，一行行分析代码！\n\nMAT，Jprofiler作用：\n\n分析Dump文件，快速分析内存泄露；\n获得堆中的数据；\n获得大的对象\n\n13 GC（常用算法）Minor GC\nFull GC\n判断对象是否可以回收：引用计数法（循环引用）、可达性分析（根搜索算法）。\n-XX:MaxTenuringThreshold设定新生代进入老年代的年龄阈值。\n垃圾回收算法标记—清除算法标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。\n复制算法复制算法是将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。\n复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。\n标记—整理算法标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。\n分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。\n一般把 Java 堆分为新生代和老年代。在新生代中，大多数对象的生命周期都很短，因此选用复制算法。在老年代中，对象存活率高，因此选用标记—清除算法或标记—整理算法。\n14 JMMJMM（Java Memory Model）定义了Java 虚拟机（JVM）在计算机内存（RAM）中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\nvolatile → 共享对象可见性\nJava内存模型定义了以下八种操作来完成：\n\nlock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。\nunlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\nread（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\nload（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\nuse（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\nassign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\nstore（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。\nwrite（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。\n\nJava内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：\n\n如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。\n不允许read和load、store和write操作之一单独出现\n不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。\n不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。\n一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。\n一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现\n如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值\n如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。\n对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。\n\n","tags":["Java","JVM"]},{"title":"分页功能的实现","url":"/2021/05/08/%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"​        当要显示的数据量较大时，可以通过分页提升用户的体验，点击上一页/下一页时，需要传入第几页以及一页显示的数据量，例如&quot;$&#123;ctx&#125;/student/showCourse?page=$&#123;i&#125;&quot;，底层是通过MySQL的limit语句实现的。\n1 原始定义分页POJO\n/** * 分页信息POJO */public class PagingVO &#123;    /**     * 当前页码,默认为1     */    private int curentPageNo = 1;    /**     * 底下显示页数     */    private int pageCount = GlobalConstant.DEFAULT_PAGECOUNT;    /**     * 总页数     */    private int totalCount;    /**     * 页面容量     */    private int pageSize = GlobalConstant.DEFAULT_PAGESIZE;    /**     * 上一页     */    private int upPageNo;    /**     * 下一页     */    private int nextPageNo;    /**     * 要前往的页码，默认为0     */    private int toPageNo = 0;    public void setToPageNo(Integer toPageNo) &#123;        //新一页        this.toPageNo = (toPageNo-1) * pageSize ;        //设置跳转后当前的页码        setCurentPageNo(toPageNo);    &#125;    public int getPageCount() &#123;        return pageCount;    &#125;    public void setPageCount(int pageCount) &#123;        this.pageCount = pageCount;    &#125;    public Integer getTopageNo() &#123;        return toPageNo;    &#125;    public int getCurentPageNo() &#123;        return curentPageNo;    &#125;    /**     * 设置当前页码     * @param curentPageNo 页码数     */    public void setCurentPageNo(int curentPageNo) &#123;        if (curentPageNo != 1) &#123;            this.upPageNo = curentPageNo - 1;        &#125;        this.nextPageNo = curentPageNo + 1;        this.curentPageNo = curentPageNo;    &#125;    public int getTotalCount() &#123;        return totalCount;    &#125;    public void setTotalCount(int totalCount) &#123;        if (totalCount%pageSize &gt; 0) &#123;            this.totalCount = (totalCount/pageSize)+1;        &#125; else &#123;            this.totalCount = totalCount/pageSize;        &#125;    &#125;    public int getPageSize() &#123;        return pageSize;    &#125;    public void setPageSize(int pageSize) &#123;        this.pageSize = pageSize;    &#125;    public int getUpPageNo() &#123;        return upPageNo;    &#125;    public void setUpPageNo(int upPageNo) &#123;        this.upPageNo = upPageNo;    &#125;    public int getNextPageNo() &#123;        return nextPageNo;    &#125;    public void setNextPageNo(int nextPageNo) &#123;        this.nextPageNo = nextPageNo;    &#125;&#125;\n\nstudent/showCourse接口\n@RequestMapping(value = &quot;/showCourse&quot;)    public String stuCourseShow(Model model, Integer page) throws Exception &#123;        List&lt;Course&gt; list = null;        //页码对象        PagingVO pagingVO = new PagingVO();        //设置总页数        pagingVO.setTotalCount(courseService.getCountCourse());        if (page == null || page == 0) &#123;            pagingVO.setToPageNo(1);            list = courseService.findByPaging(1);        &#125; else &#123;            pagingVO.setToPageNo(page);            list = courseService.findByPaging(page);        &#125;        List&lt;CourseCustom&gt; lists = getCourseCustomList(list);        model.addAttribute(&quot;courseList&quot;, lists);        model.addAttribute(&quot;pagingVO&quot;, pagingVO);        return &quot;student/showCourse&quot;;    &#125;\n\nfindByPaging\n&lt;select id=&quot;findByPaging&quot; parameterType=&quot;PagingVO&quot; resultMap=&quot;BaseResultMap&quot;&gt;    select    &lt;include refid=&quot;Base_Column_List&quot; /&gt;    from course    limit #&#123;toPageNo&#125;, #&#123;pageSize&#125;&lt;/select&gt;\n\n2 插件MyBatis 分页插件 PageHelper（需要配置拦截器）\n文档地址：https://pagehelper.github.io/docs/howtouse/\n3 拦截器原理\n\nMybatis拦截器常常会被用来进行分页处理。JDBC对数据库进行操作就必须产生一个对应的Statement对象，Mybatis在执行Sql语句前也会产生一个包含Sql语句的Statement对象，而且对应的Sql语句是在Statement之前产生的，所以我们就可以在它成Statement之前对用来生成Statement的Sql语句下手。在Mybatis中Statement语句是通过RoutingStatementHandler对象的prepare方法生成的。所以利用拦截器实现Mybatis分页的一个思路就是拦截StatementHandler接口的prepare方法，然后在拦截器方法中把Sql语句改成对应的分页查询Sql语句，之后再调用StatementHandler对象的prepare方法，即调用invocation.proceed()。更改Sql语句这个看起来很简单，而事实上来说的话就没那么直观，因为包括sql等其他属性在内的多个属性都没有对应的方法可以直接取到，它们对外部都是封闭的，是对象的私有属性，所以这里就需要引入反射机制来获取或者更改对象的私有属性的值了。对于分页而言，在拦截器里面我们常常还需要做的一个操作就是统计满足当前条件的记录一共有多少，这是通过获取到了原始的Sql语句后，把它改为对应的统计语句再利用Mybatis封装好的参数和设置参数的功能把Sql语句中的参数进行替换，之后再执行查询记录数的Sql语句进行总记录数的统计。\n\nPage\npublic class Page &#123;    private int total;//总的行数    private int size;//每页的大小    private int index;//页码  从1开始    public Page(int size, int index) &#123;        this.size = size;        this.index = index;    &#125;    public int getTotal() &#123;        return total;    &#125;    public void setTotal(int total) &#123;        this.total = total;    &#125;    public int getSize() &#123;        return size;    &#125;    public void setSize(int size) &#123;        this.size = size;    &#125;    public int getIndex() &#123;        return index;    &#125;    public void setIndex(int index) &#123;        this.index = index;    &#125;    public int getOffset()&#123;        return size*(index-1);//offset 0 limit 50&lt;size&gt;    &#125;    @Override    public String toString() &#123;        return &quot;Page&#123;&quot; +                &quot;total=&quot; + total +                &quot;, size=&quot; + size +                &quot;, index=&quot; + index +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nPageIntercepter\npackage icu.xblogs.report.plugin;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.plugin.*;import org.apache.ibatis.reflection.SystemMetaObject;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Map;import java.util.Properties;/** * 使用分页插件步骤 * 1. 本项目的分页查询的逻辑会在mapper类中单独写出 * 2. 分页的实体工具类有三个参数，index用于记录分页的开始 size用于记录每页多少条记录 * 3. 在mapper接口的方法中，有Page参数的都是分页方法，在mapper中无需再写分页的sql逻辑，插件已经自动的完成 * 4. 如果有多个参数，在非page参数前加上@param */@Intercepts(@Signature(type = StatementHandler.class,        method = &quot;prepare&quot;, args = &#123;Connection.class,        Integer.class&#125;))public class PageInterceptor implements Interceptor &#123;    @Override    public Object intercept(Invocation invocation) throws Throwable &#123;        //1. 检测当前是否满足分页条件        // 带上分页参数,获取被拦截的对象StatementHandler，不能去拦截exector,因为需要拦截参数传递        StatementHandler target = (StatementHandler) invocation.getTarget();        // SQL包 sql、参数、参数映射，        // 如果参数为单一的参数且没有配置@param注解，且参数值不是复杂的类型，会被判定为arg，如果是复杂的类型会为类型值，        // 参数为多个 类型则会被判定为一个map 键的规则如上，        // sql为直接可以执行的sql        BoundSql boundSql = target.getBoundSql();        Object parameterObject = boundSql.getParameterObject();        Page page = null;        //如果参数只有一个Page的类型的时候，直接拿到这个page        if (parameterObject instanceof Page) &#123;            page = (Page) parameterObject;        &#125; else if (parameterObject instanceof Map) &#123;            //这个流式的编程没看懂，估计是拿到map中Page的类容            page = (Page) ((Map) parameterObject).values().stream().filter(v -&gt; v instanceof Page).findFirst().orElse(null);        &#125;        //如果不是分页  直接放行        if (page == null) &#123;            return invocation.proceed();        &#125;        // 2.设置总行数        // select count(0) from (sql);        page.setTotal(selectCount(invocation));        // 3.修改原有SQL        // select * from users offset 0,limit 50        //重新的设置boundsql中的可执行sql的值        String newSql= String.format(&quot;%s limit %s offset %s&quot;, boundSql.getSql(),page.getSize(),page.getOffset());        //使用MetaObject工具类重新的构建sql        SystemMetaObject.forObject(boundSql).setValue(&quot;sql&quot;,newSql);        return invocation.proceed();    &#125;    private int selectCount(Invocation invocation) throws SQLException &#123;        int count = 0;        StatementHandler target = (StatementHandler) invocation.getTarget();        // SQL包 sql、参数、参数映射        //通过jdbc计算查询sql的总条数        String countSql = String.format(&quot;select count(*) from (%s) as _page&quot;, target.getBoundSql().getSql());        // JDBC        Connection connection = (Connection) invocation.getArgs()[0];        PreparedStatement preparedStatement = connection.prepareStatement(countSql);        target.getParameterHandler().setParameters(preparedStatement);        ResultSet resultSet = preparedStatement.executeQuery();        if (resultSet.next()) &#123;            count = resultSet.getInt(1);        &#125;        resultSet.close();        preparedStatement.close();        return count;    &#125;    //包装  动态代理 静态代理    @Override    public Object plugin(Object target) &#123;        return Plugin.wrap(target, this);    &#125;    @Override    public void setProperties(Properties properties) &#123;    &#125;&#125;\n\nController层\n@RequestMapping(value = &quot;/getAttendanceByMonth&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic PageAndList&lt;Map&lt;String, String&gt;&gt; getAttendanceByMonth(String month, int num)&#123;    Page page = new Page(10, num);    List&lt;Map&lt;String, String&gt;&gt; monthList = attendanceRecordService.getMonthList(month, page);    return new PageAndList&lt;&gt;(page, monthList);&#125;\n\n\n\n","tags":["Java","MySQL","项目"]},{"title":"二分答案","url":"/2021/05/09/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/","content":"应用前提：求解的答案是一个有确定范围的正整数，且与某个输入参数之间具有相关性。\n基本思想：在答案可能的范围内[L,R]二分查找答案，检查当前答案是否满足题目的条件要求，根据判断结果更新查找区间。\nLeetCode相关题目：\nLeetCode 410.分割数组的最大值题目描述：给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。\npublic class Solution &#123;    public int splitArray(int[] nums, int m) &#123;        int max = 0;        int sum = 0;        // 计算「子数组各自的和的最大值」的上下界        for (int num : nums) &#123;            max = Math.max(max, num);            sum += num;        &#125;        // 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，        // 使得它对应的「子数组的分割数」恰好等于 m        int left = max;        int right = sum;        while (left &lt; right) &#123;            int mid = left + (right - left) / 2;            int splits = split(nums, mid);            if (splits &gt; m) &#123;                // 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大                // 下一轮搜索的区间是 [mid + 1, right]                left = mid + 1;            &#125; else &#123;                // 下一轮搜索的区间是上一轮的反面区间 [left, mid]                right = mid;            &#125;        &#125;        return left;    &#125;    /***     *     * @param nums 原始数组     * @param maxIntervalSum 子数组各自的和的最大值     * @return 满足不超过「子数组各自的和的最大值」的分割数     */    private int split(int[] nums, int maxIntervalSum) &#123;        // 至少是一个分割        int splits = 1;        // 当前区间的和        int curIntervalSum = 0;        for (int num : nums) &#123;            // 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶            if (curIntervalSum + num &gt; maxIntervalSum) &#123;                curIntervalSum = 0;                splits++;            &#125;            curIntervalSum += num;        &#125;        return splits;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/\nLeetCode1011. 在 D 天内送达包裹的能力\n题目描述：传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。\nclass Solution &#123;    public int shipWithinDays(int[] weights, int D) &#123;        // 确定二分查找左右边界        int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();        while (left &lt; right) &#123;            int mid = (left + right) / 2;            // need 为需要运送的天数            // cur 为当前这一天已经运送的包裹重量之和            int need = 1, cur = 0;            for (int weight : weights) &#123;                if (cur + weight &gt; mid) &#123;                    ++need;                    cur = 0;                &#125;                cur += weight;            &#125;            if (need &lt;= D) &#123;                right = mid;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        return left;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/solution/zai-d-tian-nei-song-da-bao-guo-de-neng-l-ntml/\nLeetCode1482. 制作 m 束花所需的最少天数\n题目描述：给你一个整数数组 bloomDay，以及两个整数 m 和 k 。\n现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\nclass Solution &#123;    public int minDays(int[] bloomDay, int m, int k) &#123;        if (m &gt; bloomDay.length / k) &#123;            return -1;        &#125;        int low = Integer.MAX_VALUE, high = 0;        int length = bloomDay.length;        for (int i = 0; i &lt; length; i++) &#123;            low = Math.min(low, bloomDay[i]);            high = Math.max(high, bloomDay[i]);        &#125;        while (low &lt; high) &#123;            int days = (high - low) / 2 + low;            if (canMake(bloomDay, days, m, k)) &#123;                high = days;            &#125; else &#123;                low = days + 1;            &#125;        &#125;        return low;    &#125;    public boolean canMake(int[] bloomDay, int days, int m, int k) &#123;        int bouquets = 0;        int flowers = 0;        int length = bloomDay.length;        for (int i = 0; i &lt; length &amp;&amp; bouquets &lt; m; i++) &#123;            if (bloomDay[i] &lt;= days) &#123;                flowers++;                if (flowers == k) &#123;                    bouquets++;                    flowers = 0;                &#125;            &#125; else &#123;                flowers = 0;            &#125;        &#125;        return bouquets &gt;= m;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/solution/zhi-zuo-m-shu-hua-suo-xu-de-zui-shao-tia-mxci/\nLeetCode1723. 完成所有工作的最短时间\n题目描述：给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。\n请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。\nclass Solution &#123;    public int minimumTimeRequired(int[] jobs, int k) &#123;        Arrays.sort(jobs);        int low = 0, high = jobs.length - 1;        while (low &lt; high) &#123;            int temp = jobs[low];            jobs[low] = jobs[high];            jobs[high] = temp;            low++;            high--;        &#125;        int l = jobs[0], r = Arrays.stream(jobs).sum();        while (l &lt; r) &#123;            int mid = (l + r) &gt;&gt; 1;            if (check(jobs, k, mid)) &#123;                r = mid;            &#125; else &#123;                l = mid + 1;            &#125;        &#125;        return l;    &#125;    public boolean check(int[] jobs, int k, int limit) &#123;        int[] workloads = new int[k];        return backtrack(jobs, workloads, 0, limit);    &#125;    public boolean backtrack(int[] jobs, int[] workloads, int i, int limit) &#123;        if (i &gt;= jobs.length) &#123;            return true;        &#125;        int cur = jobs[i];        for (int j = 0; j &lt; workloads.length; ++j) &#123;            if (workloads[j] + cur &lt;= limit) &#123;                workloads[j] += cur;                if (backtrack(jobs, workloads, i + 1, limit)) &#123;                    return true;                &#125;                workloads[j] -= cur;            &#125;            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作            // 或者当前工作恰能使该工人的工作量达到了上限            // 这两种情况下我们无需尝试继续分配工作            if (workloads[j] == 0 || workloads[j] + cur == limit) &#123;                break;            &#125;        &#125;        return false;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/wan-cheng-suo-you-gong-zuo-de-zui-duan-s-hrhu/\n总结：\n\n留意题目中出现的关键字「非负整数」、分割「连续」，以后遇到「查找一个有范围的整数」，「最大值最小化」之类的问题，要想到可以尝试使用「二分」；\n在代码层面上，这些问题的特点都是：在二分查找的判别函数里，需要遍历数组一次。\n\n","tags":["算法","LeetCode","Java","JavaSE","二分查找"]},{"title":"Jmeter接口测试入门","url":"/2021/05/22/Jmeter%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/","content":"\nJmeter是一款使用Java开发的，开源免费的测试工具，主要用来做接口测试和性能测试。\n\n1 Jmeter常用组件测试计划（测试起点、测试容器）\n\n线程组（线程数、ramp-up加载时间、循环次数）\n取样器（发送请求最小单元，GET，POST）\n逻辑控制器（接口业务逻辑）\n前置处理器（发送请求前的一些设置及脚本）\n后置处理器（发送请求后的一些设置及脚本）\n断言（验证测试结果）\n定时器（定时，用于性能测试）\n配置元件（对请求做一些配置，默认值、环境、Cookie关联）\n监听器（收集测试结果，查看结果树）\n监听器（收集测试结果）\n\n\n\n测试计划→线程组→配置元件→前置处理器→定时器→取样器→后置处理器→断言→监听器\n2 关联接口后置处理器→XX提取\n2.1 JSON提取JSON路径表达式：$.access_token（.表示绝对路径）\n2.2 正则表达式提取正则表达式：”access_token”:”(.+?)”\n函数助手：_Random\n解决乱码：后置→BeanShell→Script中添加prev.setDataEncoding(&quot;utf-8&quot;)\n监听器→聚合报告\n3 其他功能\n加密接口\n签名接口\nCSV数据驱动\n前后置处理器脚本\n接口流程\n多种协议接口\nJenkins+Ant持续集成\n\n","tags":["Java","测试","Jmeter","接口测试"]},{"title":"Java接口自动化测试入门","url":"/2021/06/09/Java%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/","content":"1 基本概念涉及技术\nHttpClient：模拟客户端发送请求\nMock：虚拟化平台，模拟测试\nMyBatis：持久层框架\nTestNG：集成测试的框架\nJenkins：持续集成工具\nSpringBoot：开发框架，接口开发\nGit：项目代码版本管理工具\n\n为什么要做接口测试：\n\n接口测试更容易实现自动化持续集成；\n相对于UI测试更加稳定；\n更容易定位bug，提高测试效率，减少回归测试的人力与时间成本 。\n\n测试流程\n需求阶段→研发阶段→测试阶段→项目上线\n\n项目上线后-添加监控：\n接口存活监控：1、端口号是否活着；2、即便端口活着，监控程序（程序假死），隔10s，检测接口，是否正确返回。\n测试报告（展现工作价值）：经过几轮测试，耗费多少时间，执行了哪些测试（功能、性能、自动化），发现哪些问题；\n接口测试范围\n1.功能测试：等价类划分法、边解值分析法、错误推论法、因果推论法、判定表驱动法、正交试验发、功能图发、场景法\n2.异常测试：2.1数据异常：null，””，数据类型异常2.2环境异常： a.负载均衡架构，b冷热备份:一般是热备份\n3.性能测试（狭义）：负载测试、压力测试或强度测试、并发测试、稳定性测试或可靠性测试\n接口用例设计原则\n用例设计能映射成一张表，能更好的加载。 建议将表头的字段写成英文的，方便映射到代码，以便以后做自动化测试的时候进行读取 \n接口测试用例的设计：（以登录为例）\n1，id ：如1,2,3 \n2，目标url：如http://www.imooc.com/login/ \n3，username \n4，pwd \n5，程序状态码（类似预期结果）：如1表示成功 \n6，返回内容：如success \n7，实际结果：xxx \n8，执行状态：如1成功，2失败\n\n环境异常测试\n现在nginx下有三个tomcat,分配tomact的原则是根据userid来区分，当余数为0，分发到1上，以此类推，现在如果用户1把tomcat2弄挂了，此时用户4来访问，正常情况下是要访问到tomcat3。后续tomact重启好了，用户7应该可以正常访问tomcat2而不是3 \n方法：通过日志来确认\n\n自动化框架\n显示层：结合TestNG，使用ExtentReport生成测试报告\n控制层：采用httpclient框架进行自动化case的编写，进行逻辑验证，并结合TestNg和mybatis验证预期结果和实际结果是否一致\n持久层：测试用例存储，结合mybatis操作数据库（数据驱动）\n2 Git2.1 安装及配置安装Git客户端\n\nlinux：yum install -y git \n\nwindows：https://git-scm.com/downloads \n\nmac：brew install git \n\n\n检查安装是否成功： git –version\n配置sshkey（每次提代码都不要输入用户名和密码）\n\n生成key：ssh-keygen -t rsa -C “邮箱地址”（建议重命名生成公钥和私钥,防止配置多个ssh出现重名覆盖的问题）\ncd ~/.ssh （用户目录下的.ssh文件夹）\n复制id_rsa.pub的公钥内容到github （github→settings→SSH and GPG keys→new SSH key）\n\n配置多个sshkey \n\ncd ~/.ssh(用户目录下的.ssh文件夹） \n\nvim config \n\n添加Host/HostName/[User/PreferredAuthentications]/IdentityFile \n~/.ssh/config\n# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~&#x2F;.ssh&#x2F;gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~&#x2F;.ssh&#x2F;id_rsa\n\n\n\n2.2 基本操作\n#配置账号和邮箱git config --global user.name “your_username” #设置用户名git config --global user.email “your_registered_Email” #设置邮箱地址#新建本地仓库 #git init#在Github上新建一个仓库，复制仓库地址#git remote add origin 地址#git push -u origin master#克隆GitHub项目创库代码git clone 地址#查看仓库里本地文件的状态git status#将文件添加到暂存区，追踪文件git add 文件名 #git add -A或 . 把目录下的所有文件添加到暂存区，多个文件用空格隔开#将文件提交到本地仓库git commit -m  &quot;备注信息&quot; #本地仓库↔远程仓库#将本地仓库的文件推送到远程仓库git push#将远程仓库的文件拉取到本地仓库git pull \n\n2.3 分支操作#查看分支git branch #查看本地分支 git branch -a #查看本地以及远程分支 #创建/切换（本地）分支git checkout -b #分支名 在本地创建分支，并切换到该分支 git checkout 分支名 #切换分支 git push --set-upstream origin branch1 #将分支推送到远程#删除本地分支git branch -d 分支名 #不能在要删除的分支内删除本地分支，应该切换到其他分支再进行删除#删除远程分支git branch -r -d origin/分支名 git push origin :分支名#合并（本地）分支git merge 分支名git push #推送到远程仓库\n\n当合并冲突时，会提示 “ &lt;&lt;&lt;&lt;&lt;&lt; HEAD 冲突内容 &gt;&gt;&gt;&gt;&gt;&gt;分支名 ”，可以按照该提示修改文件，然后重新推送即可。\n\n3 TestNG\nTestNG是Java中的一个测试框架，是一个目前很流行实用的单元测试框架，有完善的用例管理模块，配合Maven能够很方便管理依赖第三方插件。使用TestNG可以做功能、接口、单元、集成的自动化测试，最常见的是结合selenium做功能自动化测试，它使用Java注释去写测试方法。\n\n测试人员一般用TestNG来写自动化测试，开发人员一般用Junit写单元测试，TestNG适合测试人员使用的原因：\n\n比Junit涵盖功能更全面的测试框架；\nJunit更适合隔离性比较强的单元测试；\nTestNG更适合复杂的集成测试。\n\n编写一个测试的过程包含以下步骤：\n\n编写测试的业务逻辑并在代码中插入TestNG annotation；\n将测试信息添加到testng.xml文件或build.xml中；\n运行TestNG。\n\nMaven依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.testng&lt;/groupId&gt;    &lt;artifactId&gt;testng&lt;/artifactId&gt;    &lt;version&gt;6.10&lt;/version&gt;&lt;/dependency&gt;\n\n3.1 常用注解@BeforeSuite 在该套件的所有测试都运行在注释的方法之前，仅运行一次。应用场景：suite可以包含多个class，类应该属于某个测试套件之下。\n@BeforeClass 在调用当前类的第一个测试方法之前运行，注释方法仅运行一次。应用场景：类运行前注册对象，静态方法，变量赋值等。\n@BeforeTest 注释的方法将在属于**&lt;test&gt;标签内的类的所有测试方法**运行之前运行。\n​    @Test 将类或方法标记为测试的一部分。\n​    @BeforeMethod 注释方法将在每个测试方法之前运行。 \n​        @AfterMethod 注释方法将在每个测试方法之后运行。\n@AfterTest 注释的方法将在属于&lt;test&gt;标签内的类的所有测试方法运行之后运行。\n@AfterClass 在调用当前类的第一个测试方法之后运行，注释方法仅运行一次。\n@AfterSuite 在该套件的所有测试都运行在注释方法之后，仅运行一次。\n\n监听器\n @Listeners 定义测试类上的监听器。  \nTestNG 的监听器能够定制额外的功能以满足我们的需要，尤其是关于测试方法运行的行为、报表以及通知功能。\nTestNG 提供的几种监听器：\n\nIAnnotationTransformer\nIAnnotationTransformer2\nIHookable\nIInvokedMethodListener\nIMethodInterceptor\nIReporter\nISuiteListener\nITestListener\n\n尽管名字叫监听器，但事实上它们只是一些预定义的 Java 接口。用户创建这些接口的实现类，并把它们加入到 TestNG 中，TestNG 便会在测试运行的不同时刻调用这些类中的接口方法。\n@Test忽略测试：@Test(enabled = false)\n分组测试（方法 / 类）\n创建方法： @Test(groups=“group1”) @Test(groups=“group2”) …\n@BeforeGroups 配置方法将在组列表之前运行。 此方法保证在调用属于这些组中的任何一个的第一个测试方法之前不久运行。  \n@AfterGroups 此配置方法将在组列表之后运行。该方法保证在调用属于任何这些组的最后一个测试方法之后不久运行。  \nxml配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;suite name=&quot;grouponclass&quot;&gt;     &lt;test name=&quot;testgroup&quot;&gt;         &lt;groups&gt;             &lt;run&gt;                 &lt;include name=&quot;stu&quot;/&gt;             &lt;/run&gt;         &lt;/groups&gt;        &lt;classes&gt;            &lt;class name=&quot;com...&quot;/&gt;        &lt;/classes&gt;    &lt;/test&gt;&lt;/suite&gt;\n\n异常测试：期望结果为一个异常的测试\n@Test(expectedExceptions = RuntimeException.class) //期望得到的结果是异常public void runTimeExcpeiontSuccess()&#123;\tSystem.out.println(&quot;这是一个异常成功的测试&quot;);\tthrow new RuntimeException();//抛出一个异常&#125;\n\n依赖测试\n例如：test2方法依赖test1方法 （先执行test1）\n应用标签：@Test（dependsOnMethods={“test1”}） \n如果test1执行失败了，则test2方法则被忽略。\n\n参数化测试\n@Parameters 描述如何将参数传递给@Test方法。  \n@Test @Parameters(&#123;&quot;a&quot;,&quot;b&quot;&#125;) public void paramtertest1(String name,int age)&#123; System.out.println(&quot;name=&quot;+name +&quot; age=&quot;+age);&#125; \n\nxml中相关配置 \n&lt;test&gt;     &lt;parameter name=&quot;a&quot; value=&quot;123&quot;/&gt; &lt;!--其中name的值与@Parameters中的名字对应--&gt;     &lt;parameter name=&quot;b&quot; value=&quot;3&quot;/&gt;     &lt;classes&gt; ... &lt;/classes&gt; &lt;/test&gt;\n\n @Factory 将一个方法标记为工厂，返回TestNG将被用作测试类的对象。 该方法必须返回Object []。\n @DataProvider 标记一种方法来提供测试方法的数据。 注释方法必须返回一个Object [] []，其中每个Object []可以被分配给测试方法的参数列表。 要从该DataProvider接收数据的@Test方法需要使用与此注释名称相等的dataProvider名称。\n@Test(dataProvider = &quot;data&quot;)public void testDataProvider(String name,int age)&#123; System.out.println(&quot;name=&quot; +name+&quot; ;age=&quot;+age); &#125; @DataProvider(name = &quot;data&quot;) public Object[][] dataProvider()&#123; Object[][] objects=new Object[][]&#123;&#123;&quot;zhangsan&quot;,10&#125;,&#123;&quot;lisi&quot;,20&#125; &#125;;return objects;&#125;\n\nData根据不同的方法，传递不同的值\n@DataProvider(name = &quot;dataProviderWithDiffMethod&quot;) public Object[][] dataProvider(Method method)&#123; Object[][] o=null; if (method.getName().equals(&quot;test2&quot;))&#123; o=new Object[][]&#123; &#123;&quot;test2&quot;,10&#125; &#125;; &#125;  else &#123; o=new Object[][]&#123; &#123;&quot;test3&quot;,20&#125; &#125;;&#125;  return o;&#125;\n\n多线程测试\n注解实现\n//10个线程 //@Test(invocationCount = 10) threadPoolSize是线程池数量，用于各不关联的用例，提高效率 @Test(invocationCount = 10,threadPoolSize =5 ) public void thread()&#123;     System.out.println(1);     System.out.printf(&quot;Thread ID:%s%n&quot;,Thread.currentThread().getId());//把当前的线程id打印出来 &#125;\n\nxml配置实现\nparallel=tests,methods, classes,instances（并发级别）\n\n超时测试\n适用于等一段时间就不想等，直接跳到下一个case的情况。\npublic class TimeOutTest &#123;     // 期望在3s得到结果，结果2s就成功了，所以测试结果是通过     @Test(timeOut = 3000)     public void testSuccess() throws InterruptedException     &#123; Thread.sleep(2000); &#125;&#125;\n\n3.2 测试报告ExtentReport\nMaven依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.vimalselvam&lt;/groupId&gt;    &lt;artifactId&gt;testng-extentsreport&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.relevantcodes&lt;/groupId&gt;    &lt;artifactId&gt;extentreports&lt;/artifactId&gt;    &lt;version&gt;2.41.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aventstack&lt;/groupId&gt;    &lt;artifactId&gt;extentreports&lt;/artifactId&gt;    &lt;version&gt;3.0.6&lt;/version&gt;&lt;/dependency&gt;\n\n基本配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;suite name=&quot;testng reprot&quot;&gt;    &lt;test name=&quot;testng&quot;&gt;        &lt;classes&gt;            &lt;class name=&quot;com.imooc.extent.AssertDemo&quot;/&gt;            &lt;methods&gt;                &lt;include name=&quot;test1&quot;/&gt;                &lt;include name=&quot;test2&quot;/&gt;                &lt;include name=&quot;test3&quot;/&gt;                &lt;include name=&quot;log&quot;/&gt;            &lt;/methods&gt;        &lt;/classes&gt;    &lt;/test&gt;    &lt;listeners&gt;        &lt;listener class-name=&quot;com.vimalselvam.testng.listener.ExtentTestNgFormatter&quot;&gt;&lt;/listener&gt;    &lt;/listeners&gt;&lt;/suite&gt;\n\n自定义监听类ExtentTestNGIReporterListener\nimport com.aventstack.extentreports.ExtentReports;import com.aventstack.extentreports.ExtentTest;import com.aventstack.extentreports.ResourceCDN;import com.aventstack.extentreports.Status;import com.aventstack.extentreports.model.TestAttribute;import com.aventstack.extentreports.reporter.ExtentHtmlReporter;import com.aventstack.extentreports.reporter.configuration.ChartLocation;import com.aventstack.extentreports.reporter.configuration.Theme;import org.testng.*;import org.testng.xml.XmlSuite; import java.io.File;import java.util.*; public class ExtentTestNGIReporterListener implements IReporter &#123;    static Date date = new Date();    static String form = String.format(&quot;%tF&quot;, date);    static String hour = String.format(&quot;%tH&quot;, date);    static String minute = String.format(&quot;%tM&quot;, date);    static String second = String.format(&quot;%tS&quot;, date);    //生成的路径以及文件名    private static final String OUTPUT_FOLDER = &quot;test-output/&quot;;    private static final String FILE_NAME = &quot;index&quot;+form+hour+minute+second+&quot;.html&quot;;    private ExtentReports extent;     public void generateReport(List&lt;XmlSuite&gt; xmlSuites, List&lt;ISuite&gt; suites, String outputDirectory) &#123;        init();        boolean createSuiteNode = false;        if(suites.size()&gt;1)&#123;            createSuiteNode=true;        &#125;        for (ISuite suite : suites) &#123;            Map&lt;String, ISuiteResult&gt; result = suite.getResults();            //如果suite里面没有任何用例，直接跳过，不在报告里生成            if(result.size()==0)&#123;                continue;            &#125;            //统计suite下的成功、失败、跳过的总用例数            int suiteFailSize=0;            int suitePassSize=0;            int suiteSkipSize=0;            ExtentTest suiteTest=null;            //存在多个suite的情况下，在报告中将同一个suite的测试结果归为一类，创建一级节点。            if(createSuiteNode)&#123;                suiteTest = extent.createTest(suite.getName()).assignCategory(suite.getName());            &#125;            boolean createSuiteResultNode = false;            if(result.size()&gt;1)&#123;                createSuiteResultNode=true;            &#125;            for (ISuiteResult r : result.values()) &#123;                ExtentTest resultNode;                ITestContext context = r.getTestContext();                if(createSuiteResultNode)&#123;                    //没有创建suite的情况下，将在SuiteResult的创建为一级节点，否则创建为suite的一个子节点。                    if( null == suiteTest)&#123;                        resultNode = extent.createTest(r.getTestContext().getName());                    &#125;else&#123;                        resultNode = suiteTest.createNode(r.getTestContext().getName());                    &#125;                &#125;else&#123;                    resultNode = suiteTest;                &#125;                if(resultNode != null)&#123;                    resultNode.getModel().setName(suite.getName()+&quot; : &quot;+r.getTestContext().getName());                    if(resultNode.getModel().hasCategory())&#123;                        resultNode.assignCategory(r.getTestContext().getName());                    &#125;else&#123;                        resultNode.assignCategory(suite.getName(),r.getTestContext().getName());                    &#125;                    resultNode.getModel().setStartTime(r.getTestContext().getStartDate());                    resultNode.getModel().setEndTime(r.getTestContext().getEndDate());                    //统计SuiteResult下的数据                    int passSize = r.getTestContext().getPassedTests().size();                    int failSize = r.getTestContext().getFailedTests().size();                    int skipSize = r.getTestContext().getSkippedTests().size();                    suitePassSize += passSize;                    suiteFailSize += failSize;                    suiteSkipSize += skipSize;                    if(failSize&gt;0)&#123;                        resultNode.getModel().setStatus(Status.FAIL);                    &#125;                    resultNode.getModel().setDescription(String.format(&quot;Pass: %s ; Fail: %s ; Skip: %s ;&quot;,passSize,failSize,skipSize));                &#125;                buildTestNodes(resultNode,context.getFailedTests(), Status.FAIL);                buildTestNodes(resultNode,context.getSkippedTests(), Status.SKIP);                buildTestNodes(resultNode,context.getPassedTests(), Status.PASS);            &#125;            if(suiteTest!= null)&#123;                suiteTest.getModel().setDescription(String.format(&quot;Pass: %s ; Fail: %s ; Skip: %s ;&quot;,suitePassSize,suiteFailSize,suiteSkipSize));                if(suiteFailSize&gt;0)&#123;                    suiteTest.getModel().setStatus(Status.FAIL);                &#125;            &#125;         &#125;        extent.flush();    &#125;     private void init() &#123;        //文件夹不存在的话进行创建        File reportDir= new File(OUTPUT_FOLDER);        if(!reportDir.exists()&amp;&amp; !reportDir .isDirectory())&#123;            reportDir.mkdir();        &#125;        ExtentHtmlReporter htmlReporter = new ExtentHtmlReporter(OUTPUT_FOLDER + FILE_NAME);        //设置静态文件的DNS        //解决cdn.rawgit.com访问不了的情况        htmlReporter.config().setResourceCDN(ResourceCDN.EXTENTREPORTS);        htmlReporter.config().setDocumentTitle(&quot;自动化测试报告&quot;);        htmlReporter.config().setReportName(&quot;自动化测试报告&quot;);          htmlReporter.config().setChartVisibilityOnOpen(true);        htmlReporter.config().setTestViewChartLocation(ChartLocation.TOP);        htmlReporter.config().setTheme(Theme.STANDARD);        htmlReporter.config().setCSS(&quot;.node.level-1  ul&#123; display:none;&#125; .node.level-1.active ul&#123;display:block;&#125;&quot;);        extent = new ExtentReports();        extent.attachReporter(htmlReporter);        extent.setReportUsesManualConfiguration(true);    &#125;     private void buildTestNodes(ExtentTest extenttest, IResultMap tests, Status status) &#123;        //存在父节点时，获取父节点的标签        String[] categories=new String[0];        if(extenttest != null )&#123;            List&lt;TestAttribute&gt; categoryList = extenttest.getModel().getCategoryContext().getAll();            categories = new String[categoryList.size()];            for(int index=0;index&lt;categoryList.size();index++)&#123;                categories[index] = categoryList.get(index).getName();            &#125;        &#125;         ExtentTest test;         if (tests.size() &gt; 0) &#123;            //调整用例排序，按时间排序            Set&lt;ITestResult&gt; treeSet = new TreeSet&lt;ITestResult&gt;(new Comparator&lt;ITestResult&gt;() &#123;                public int compare(ITestResult o1, ITestResult o2) &#123;                    return o1.getStartMillis()&lt;o2.getStartMillis()?-1:1;                &#125;            &#125;);            treeSet.addAll(tests.getAllResults());            for (ITestResult result : treeSet) &#123;                Object[] parameters = result.getParameters();                String name=&quot;&quot;;                //如果有参数，则使用参数的toString组合代替报告中的name                for(Object param:parameters)&#123;                    name+=param.toString();                &#125;                if(name.length()&gt;0)&#123;                    if(name.length()&gt;50)&#123;                        name= name.substring(0,49)+&quot;...&quot;;                    &#125;                &#125;else&#123;                    name = result.getMethod().getMethodName();                &#125;                if(extenttest==null)&#123;                    test = extent.createTest(name);                &#125;else&#123;                    //作为子节点进行创建时，设置同父节点的标签一致，便于报告检索。                    test = extenttest.createNode(name).assignCategory(categories);                &#125;                for (String group : result.getMethod().getGroups())                    test.assignCategory(group);                 List&lt;String&gt; outputList = Reporter.getOutput(result);                for(String output:outputList)&#123;                    //将用例的log输出报告中                    test.debug(output);                &#125;                if (result.getThrowable() != null) &#123;                    test.log(status, result.getThrowable());                &#125;                else &#123;                    test.log(status, &quot;Test &quot; + status.toString().toLowerCase() + &quot;ed&quot;);                &#125;                 test.getModel().setStartTime(getTime(result.getStartMillis()));                test.getModel().setEndTime(getTime(result.getEndMillis()));            &#125;        &#125;    &#125;     private Date getTime(long millis) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTimeInMillis(millis);        return calendar.getTime();    &#125;&#125;\n\n4 Mock基本功能：可以模拟https，http协议，运用get/post等方法模拟请求，还可以供前端开发使用。比如前端写完代码后，后端的接口没写好，这个时候就能用mock功能了，这个也是个重要产出。\n使用场景：把测试代码写完，正需要调试，但是开发还未提测，就可以mock进行调试\nmoco框架jar包下载地址：https://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/0.11.0/moco-runner-0.11.0-standalone.jar\n基本使用\n\n命令行中启动moco命令：java -jar ./moco-runner-0.11.0-standalone.jar http -p 端口号 -c json配置文件\n\njson配置文件\n[  &#123;    &quot;description&quot;:&quot;这是我们的第一个mock例子&quot;,    &quot;request&quot;:&#123;      &quot;uri&quot;:&quot;/demo&quot;,      &quot;method&quot;:&quot;get&quot;,      &quot;queries&quot;:&#123;        &quot;name&quot;:&quot;zhg&quot;,        &quot;age&quot;:&quot;18&quot;      &#125;    &#125;,    &quot;response&quot;:&#123;      &quot;headers&quot;:&#123;        &quot;Content-Type&quot;:&quot;text/html;charset=gbk&quot;      &#125;,      &quot;text&quot;:&quot;第一个moco框架demo&quot;    &#125;  &#125;]\n\n访问URL地址：localhost:端口号/demo\n\n\npost请求无法直接通过浏览器打开，需要用到接口测试工具，如Jmeter。\n[    &#123;        &quot;description&quot;:&quot;模拟一个带参数的post请求&quot;,        &quot;request&quot;:&#123;            &quot;uri&quot;:&quot;/postwithparam&quot;,            &quot;method&quot;:&quot;post&quot;,            &quot;forms&quot;:&#123;                &quot;name&quot;:&quot;zhg&quot;,                &quot;age&quot;:&quot;18&quot;            &#125;    \t&#125;,        &quot;response&quot;:&#123;        \t&quot;text&quot;:&quot;我是一个带参的post请求啦&quot;        &#125;    &#125;]\n\n在get请求中添加参数：queries在post请求中添加参数：forms\n带Cookie信息的请求\n[    &#123;        &quot;description&quot;:&quot;这是一个带cookies的get请求&quot;,        &quot;request&quot;:&#123;            &quot;uri&quot;:&quot;/get/with/cookies&quot;,            &quot;method&quot;:&quot;get&quot;,            &quot;cookies&quot;:&#123;                &quot;Login&quot;:&quot;true&quot;            &#125;        &#125;,        &quot;response&quot;:&#123;            &quot;text&quot;:&quot;我是一个带cookies的get请求&quot;        &#125;    &#125;,    &#123;        &quot;description&quot;:&quot;这是一个带cookies的post请求&quot;,        &quot;request&quot;:&#123;            &quot;uri&quot;:&quot;/post/with/cookies&quot;,            &quot;method&quot;:&quot;post&quot;,            &quot;cookies&quot;:&#123;                &quot;login&quot;:&quot;true&quot;            &#125;,            &quot;json&quot;:&#123;                &quot;name&quot;:&quot;zhg&quot;,                &quot;age&quot;:&quot;18&quot;            &#125;\t\t&#125;,        &quot;response&quot;:&#123;            &quot;status&quot;:&quot;200&quot;,            &quot;json&quot;:&#123;            \t&quot;name&quot;:&quot;zhg&quot;,            \t&quot;status&quot;:&quot;1&quot;            &#125;        &#125;    &#125;]\n\nJmeter访问带cookies的请求：线程组→配置元件→http cookie 管理器。\n\n带请求头的请求\n[    &#123;        &quot;description&quot;: &quot;这是一个带有headers的post请求&quot;,        &quot;request&quot;: &#123;            &quot;uri&quot;: &quot;/post/with/headers&quot;,            &quot;method&quot;: &quot;post&quot;,            &quot;headers&quot;: &#123;            \t&quot;Content-Type&quot;: &quot;application/json&quot;            &#125;,            &quot;json&quot;: &#123;            \t&quot;name&quot;: &quot;kola&quot;,            \t&quot;age&quot;: &quot;18&quot;            &#125;        &#125;,        &quot;response&quot;: &#123;            &quot;json&quot;: &#123;                &quot;name&quot;: &quot;kola&quot;,                &quot;status&quot;: &quot;1&quot;            &#125;        &#125;    &#125;]\n\n\n重定向\n[    &#123;        &quot;description&quot;: &quot;重定向到百度&quot;,        &quot;request&quot;: &#123;        \t&quot;uri&quot;: &quot;/redirect&quot;        &#125;,        &quot;redirectTo&quot;: &quot;http://www.baidu.com&quot;    &#125;,        &#123;        &quot;description&quot;: &quot;重定向到自己的网页&quot;,        &quot;request&quot;: &#123;        \t&quot;uri&quot;: &quot;/redirect/topath&quot;    \t&#125;,    \t&quot;redirectTo&quot;: &quot;/redirect/new&quot;    &#125;,    &#123;        &quot;description&quot;: &quot;我是被重定向的内容&quot;,        &quot;request&quot;: &#123;        \t&quot;uri&quot;: &quot;/redirect/new&quot;        &#125;,        &quot;response&quot;: &#123;        \t&quot;text&quot;: &quot;congratulations！&quot;        &#125;    &#125;]\n\n5 HttpClientHttpClient 模拟客服端发送的请求\nMaven依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;    &lt;version&gt;4.5.13&lt;/version&gt;&lt;/dependency&gt;\n\nDemo\npublic class MyHttpClient_Get &#123;    @Test    public void getTest() throws IOException &#123;        // 用来存放结果        String result;        // 创建get方法        HttpGet get = new HttpGet(&quot;http://www.baidu.com&quot;);        // 执行get方法        HttpClient httpClient = new DefaultHttpClient();        HttpResponse response = httpClient.execute(get);        // 获取整个响应的全部内容，并把它转化为字符串(为了防止乱码，加上编码格式utf-8        result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);        System.out.println(result);    &#125;&#125;\n\nMock配置\n[    &#123;        &quot;description&quot;:&quot;这是个会返回cookies信息的get请求&quot;,        &quot;request&quot;:&#123;            &quot;uri&quot;:&quot;/getCookies&quot;,            &quot;method&quot;:&quot;get&quot;        &#125;,        &quot;response&quot;:&#123;            &quot;cookies&quot;:&#123;                &quot;login&quot;: &quot;true&quot;,                &quot;status&quot;:&quot;10000&quot;            &#125;,            &quot;text&quot;:&quot;恭喜你成功啦&quot;        &#125;    &#125;,    &#123;        &quot;description&quot;:&quot;这是个带cookies信息的get请求&quot;,        &quot;request&quot;:&#123;            &quot;uri&quot;:&quot;/get/with/cookies&quot;,            &quot;method&quot;:&quot;get&quot;,            &quot;cookies&quot;:&#123;                &quot;login&quot;: &quot;true&quot;            &#125;        &#125;,        &quot;response&quot;:&#123;                        &quot;text&quot;:&quot;恭喜你成功啦&quot;        &#125;    &#125;]\n\n在resources文件夹下新建一配置文件 xxx.properties（ xxx.properties都是以Kev=values的形式写的）如：test.url=http://localhost:8000\n获取配置文件中的值，并模拟客户端发送Http请求\nGet请求\npackage com.course.httpclient.cookies;import org.apache.http.HttpResponse;import org.apache.http.client.CookieStore;import org.apache.http.client.methods.HttpGet;import org.apache.http.cookie.Cookie;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import org.testng.annotations.BeforeTest;import org.testng.annotations.Test;import java.io.IOException;import java.util.List;import java.util.Locale;import java.util.ResourceBundle;public class MyCookiesForGet &#123;    private String url;    private ResourceBundle bundle;    //用来存储cookies信息的变量    private CookieStore store;    @BeforeTest    public void beforeTest()&#123;        bundle = ResourceBundle.getBundle(&quot;application&quot;, Locale.CHINA);        url = bundle.getString(&quot;test.url&quot;);    &#125;    @Test    public void testGetCookies() throws IOException &#123;        String result;//       从配置文件中 拼接测试的url        String uri = bundle.getString(&quot;getCookies.uri&quot;);        String testUrl = this.url+uri;//        测试逻辑代码书写        HttpGet get = new HttpGet(testUrl);        DefaultHttpClient client = new DefaultHttpClient();        HttpResponse response = client.execute(get);        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(result);        //获取cookies信息        this.store = client.getCookieStore();        List&lt;Cookie&gt; cookieList = store.getCookies();        for (Cookie cookie : cookieList)&#123;            String name = cookie.getName();            String value = cookie.getValue();            System.out.println(&quot;cookie name = &quot; + name            + &quot;;  cookie value = &quot; + value);        &#125;    &#125;    @Test(dependsOnMethods = &#123;&quot;testGetCookies&quot;&#125;)    public void testGetWithCookies() throws IOException &#123;        String uri = bundle.getString(&quot;test.get.with.cookies&quot;);        String testUrl = this.url+uri;        HttpGet get = new HttpGet(testUrl);        DefaultHttpClient client = new DefaultHttpClient();        //设置cookies信息        client.setCookieStore(this.store);        HttpResponse response = client.execute(get);        //获取响应的状态码        int statusCode = response.getStatusLine().getStatusCode();        System.out.println(&quot;statusCode = &quot; + statusCode);        if(statusCode == 200)&#123;            String result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);            System.out.println(result);        &#125;    &#125;&#125;\n\nPost请求\npackage com.course.httpclient.cookies;import org.apache.http.HttpResponse;import org.apache.http.client.CookieStore;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.cookie.Cookie;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import org.json.JSONObject;import org.testng.Assert;import org.testng.annotations.BeforeTest;import org.testng.annotations.Test;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.List;import java.util.Locale;import java.util.ResourceBundle;public class MyCookiesForPost &#123;    private String url;    private ResourceBundle bundle;    //用来存储cookies信息的变量    private CookieStore store;    @BeforeTest    public void beforeTest()&#123;        bundle = ResourceBundle.getBundle(&quot;application&quot;, Locale.CHINA);        url = bundle.getString(&quot;test.url&quot;);    &#125;    @Test    public void testGetCookies() throws IOException &#123;        String result;//       从配置文件中 拼接测试的url        String uri = bundle.getString(&quot;getCookies.uri&quot;);        String testUrl = this.url+uri;//        测试逻辑代码书写        HttpGet get = new HttpGet(testUrl);        DefaultHttpClient client = new DefaultHttpClient();        HttpResponse response = client.execute(get);        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(result);        //获取cookies信息        this.store = client.getCookieStore();        List&lt;Cookie&gt; cookieList = store.getCookies();        for (Cookie cookie : cookieList)&#123;            String name = cookie.getName();            String value = cookie.getValue();            System.out.println(&quot;cookie name = &quot; + name                    + &quot;;  cookie value = &quot; + value);        &#125;    &#125;    @Test(dependsOnMethods = &#123;&quot;testGetCookies&quot;&#125;)    public void testPostMethod() throws IOException &#123;        String uri = bundle.getString(&quot;test.post.with.cookies&quot;);        //拼接最终的测试地址        String testUrl = this.url + uri;        //声明一个Client对象，用来进行方法的执行        DefaultHttpClient client = new DefaultHttpClient();        //声明一个方法，这个方法就是post方法        HttpPost post = new HttpPost(testUrl);        //添加参数        JSONObject param = new JSONObject();        param.put(&quot;name&quot;,&quot;huhansan&quot;);        param.put(&quot;age&quot;,&quot;18&quot;);        //设置请求头信息 设置header        post.setHeader(&quot;content-type&quot;,&quot;application/json&quot;);        //将参数信息添加到方法中        StringEntity entity = new StringEntity(param.toString(),&quot;utf-8&quot;);        post.setEntity(entity);        //声明一个对象来进行响应结果的存储        String result;        //设置cookies信息        client.setCookieStore(this.store);        //执行post方法        HttpResponse response = client.execute(post);        //获取响应结果        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(result);        //处理结果，就是判断返回结果是否符合预期        //将返回的响应结果字符串转化成为json对象        JSONObject resultJson = new JSONObject(result);        //获取到结果值        String success = (String) resultJson.get(&quot;huhansan&quot;);        String status = (String) resultJson.get(&quot;status&quot;);        //具体的判断返回结果的值        Assert.assertEquals(&quot;success&quot;,success);        Assert.assertEquals(&quot;1&quot;,status);    &#125;&#125;\n\n6 SpringBoot项目实战6.1 SwaggerSwaggerUI可以自动生成接口文档，不需要频繁更新接口文档，保证接口文档与代码的一致，同时也方便了测试人员的接口测试工作。\nMaven依赖\n&lt;properties&gt;    &lt;swagger.version&gt;2.6.1&lt;/swagger.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    ...    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;        &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;        &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    ...&lt;/dependencies&gt;\n\nSwaggerConfig\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket api()&#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .pathMapping(&quot;/&quot;)                .select()                .paths(PathSelectors.regex(&quot;/.*&quot;))                .build();    &#125;\t//基本信息，页面展示    private ApiInfo apiInfo() &#123;        return  new ApiInfoBuilder().title(&quot;我的接口文档&quot;)                .contact(new Contact(&quot;zhg&quot;,&quot;&quot;,&quot;zhomgun@foxmail.com&quot;))                .description(&quot;这是我的swaggerui生成的接口文档&quot;)                .version(&quot;1.0.0.0&quot;)                .build();    &#125;&#125;\n\n\n\nController层\n@RestController//Api注解，描述信息 可通过tag进行分类@Api(value = &quot;/&quot;,description = &quot;这是我全部的get方法&quot;)public class MyGetMethod &#123;    @RequestMapping(value = &quot;/getCookies&quot;,method = RequestMethod.GET)    //方法描述    @ApiOperation(value = &quot;通过这个方法可以获取到Cookies&quot;,httpMethod = &quot;GET&quot;)    public String getCookies(HttpServletResponse response)&#123;        //HttpServerletRequest 装请求信息的类        //HttpServerletResponse  装响应信息的类        Cookie cookie = new Cookie(&quot;login&quot;,&quot;true&quot;);        response.addCookie(cookie);        return &quot;恭喜你获得cookies信息成功&quot;;    &#125;\t...&#125;\n\n以上配置完成之后，直接启动项目，访问地址：localhost:端口号/swagger-ui.html,页面如下。\n\n6.2 MyBatisMaven依赖\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.zhg&lt;/groupId&gt;    &lt;artifactId&gt;MyLogDemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;version&gt;1.5.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.16.14&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.38&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nSpringBoot中默认使用的Logback日志系统，所以SpringBoot已经集成了相关依赖，无需多余的依赖，只需在src/main/resources文件夹下，增加logback-spring.xml这个配置文件。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot;/&gt;    &lt;property name=&quot;FILE_LOG_PATTERN&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;80&#125; - %msg%n&quot;/&gt;    &lt;property name=&quot;LOG_PATH&quot; value=&quot;$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;&quot;/&gt;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;&lt;/fileNamePattern&gt;        &lt;/rollingPolicy&gt;        &lt;encoder charset=&quot;UTF-8&quot;&gt;            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;appender name=&quot;CRAWLER_LOG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;$&#123;LOG_PATH&#125;/event.log&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/event.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;            &lt;maxHistory&gt;30&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;            &lt;pattern&gt;%msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;logger name=&quot;com.business.intelligence.util.CrawlerLogger&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;CRAWLER_LOG&quot;/&gt;    &lt;/logger&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\napplication.yml\nserver:   port: 8888logging:    path: logs    file: mylog.logspring:   application:          name: report   datasource:       driver-class-name: com.mysql.jdbc.Driver       url: jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8       username: root       password: 1031mybatis:    type-aliases-package: com.course.model    mapper-locations:       - mapper/*\n\nModel（User）\npackage com.course.model;import lombok.Data;@Datapublic class User &#123;    private int id;    private String name;    private String sex;    private int age;&#125;\n\nmapper\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.course&quot;&gt;    &lt;select id=&quot;getUserCount&quot; resultType=&quot;Integer&quot;&gt;        select count(*) from user;    &lt;/select&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.course.model.User&quot;&gt;        insert into user(id,name,age,sex)        values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;sex&#125;)    &lt;/insert&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.course.model.User&quot;&gt;        update user set name=#&#123;name&#125;,age=#&#123;age&#125;        where id=#&#123;id&#125;    &lt;/update&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;&lt;/mapper&gt;\n\nController\npackage com.course.controller;import com.course.model.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import lombok.extern.log4j.Log4j;import org.mybatis.spring.SqlSessionTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;@Log4j@RestController@Api(value = &quot;v1&quot;,description = &quot;这是我的第一个版本的demo&quot;)@RequestMapping(&quot;v1&quot;)public class Demo &#123;    //首先获取一个执行sql语句的对象    @Autowired    private SqlSessionTemplate template;    @RequestMapping(value = &quot;/getUserCount&quot;,method = RequestMethod.GET)    @ApiOperation(value = &quot;可以获取到用户数&quot;,httpMethod = &quot;GET&quot;)    public int getUserCount()&#123;       return template.selectOne(&quot;getUserCount&quot;);    &#125;    @RequestMapping(value = &quot;/addUser&quot;,method = RequestMethod.POST)    public int addUser(@RequestBody User user)&#123;        int result = template.insert(&quot;addUser&quot;,user);        return result;    &#125;    @RequestMapping(value = &quot;/updateUser&quot;,method = RequestMethod.POST)    public int updateUser(@RequestBody User user)&#123;       return  template.update(&quot;updateUser&quot;,user);    &#125;    @RequestMapping(value = &quot;/deleteUser&quot;,method = RequestMethod.GET)    public int delUser(@RequestParam int id)&#123;        return template.delete(&quot;deleteUser&quot;,id);    &#125;&#125;\n\nApplication（启动类）\npackage com.course;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.scheduling.annotation.EnableScheduling;import javax.annotation.PreDestroy;@EnableScheduling@SpringBootApplicationpublic class Application &#123;    private  static ConfigurableApplicationContext context;    public static void main(String[] args) &#123;        Application.context = SpringApplication.run(Application.class,args);    &#125;    @PreDestroy    public void close()&#123;        Application.context.close();    &#125;&#125;\n\n6.3 用例管理测试用例表结构设计\nuser表包含一些基础信息，用户名，密码等。\n\n设计测试用例，并创建测试用例表，对应不同接口的操作。\n\n\n\n查询和更新的测试用例表，expected里都是查询mapper的id。\n基础配置：maven、spring、mybatis、mapper、testng(ExtentTestNGIReporterListener)\nmapper\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 命名空间mapper,如果有多个mapper文件，这个必须唯一 --&gt;&lt;mapper namespace=&quot;com.tester.model&quot;&gt;    &lt;!--获取登陆接口case--&gt;    &lt;select id=&quot;loginCase&quot; parameterType=&quot;Integer&quot;  resultType=&quot;com.tester.model.LoginCase&quot;&gt;        select * from loginCase        where id = #&#123;id&#125;;    &lt;/select&gt;    &lt;!--添加用户接口case--&gt;    &lt;select id=&quot;addUserCase&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.tester.model.AddUserCase&quot;&gt;        select * from addUserCase where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;!--获取用户信息case--&gt;    &lt;select id=&quot;getUserInfoCase&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.tester.model.GetUserInfoCase&quot;&gt;        &lt;!-- SQL语句 --&gt;        select * from getUserInfoCase where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;!--获取用户列表case--&gt;    &lt;select id=&quot;getUserListCase&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.tester.model.GetUserListCase&quot;&gt;        &lt;!-- SQL语句 --&gt;        select * from getUserListCase where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;!--更新/删除用户信息case--&gt;    &lt;select id=&quot;updateUserInfoCase&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.tester.model.UpdateUserInfoCase&quot;&gt;        select * from updateUserInfoCase where id = #&#123;id&#125;;    &lt;/select&gt;    &lt;!--添加用户接口--&gt;    &lt;select id=&quot;addUser&quot; parameterType=&quot;com.tester.model.AddUserCase&quot; resultType=&quot;com.tester.model.User&quot;&gt;        select * from user where        userName=#&#123;userName&#125;        and password=#&#123;password&#125;        and sex=#&#123;sex&#125;        and age=#&#123;age&#125;        and permission=#&#123;permission&#125;        and isDelete=#&#123;isDelete&#125;;    &lt;/select&gt;    &lt;!--获取用户信息--&gt;    &lt;select id=&quot;getUserInfo&quot; parameterType=&quot;com.tester.model.GetUserInfoCase&quot; resultType=&quot;com.tester.model.User&quot;&gt;        &lt;!-- SQL语句 --&gt;        select * from user where        id=#&#123;userId&#125;;    &lt;/select&gt;    &lt;!--获取用户列表--&gt;    &lt;select id=&quot;getUserList&quot; parameterType=&quot;com.tester.model.GetUserListCase&quot; resultType=&quot;com.tester.model.User&quot;&gt;        &lt;!-- SQL语句 --&gt;        select * from user        &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;and&quot;&gt;            &lt;if test=&quot;null != userName and &#x27;&#x27; !=userName&quot;&gt;                AND userName=#&#123;userName&#125;            &lt;/if&gt;            &lt;if test=&quot;null != sex and &#x27;&#x27; !=sex&quot;&gt;                AND sex=#&#123;sex&#125;            &lt;/if&gt;            &lt;if test=&quot;null != age and &#x27;&#x27; !=age&quot;&gt;                AND age=#&#123;age&#125;            &lt;/if&gt;        &lt;/trim&gt;        ;    &lt;/select&gt;    &lt;!--获取更新后的数据--&gt;    &lt;select id=&quot;getUpdateUserInfo&quot; parameterType=&quot;com.tester.model.UpdateUserInfoCase&quot; resultType=&quot;com.tester.model.User&quot;&gt;        select * from user        &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;and&quot;&gt;            &lt;if test=&quot;null != userName and &#x27;&#x27; !=userName&quot;&gt;                AND userName=#&#123;userName&#125;            &lt;/if&gt;            &lt;if test=&quot;null != sex and &#x27;&#x27; !=sex&quot;&gt;                AND sex=#&#123;sex&#125;            &lt;/if&gt;            &lt;if test=&quot;null != age and &#x27;&#x27; !=age&quot;&gt;                AND age=#&#123;age&#125;            &lt;/if&gt;            &lt;if test=&quot;null != permission and &#x27;&#x27; !=permission&quot;&gt;                AND permission=#&#123;permission&#125;            &lt;/if&gt;            &lt;if test=&quot;null != isDelete and &#x27;&#x27; !=isDelete&quot;&gt;                AND isDelete=#&#123;isDelete&#125;            &lt;/if&gt;        &lt;/trim&gt;       And id = #&#123;userId&#125;;    &lt;/select&gt;&lt;/mapper&gt;\n\n&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;and&quot;&gt;、&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;用于去除sql语句中多余的and关键字，逗号，或者给sql语句前拼接 “where“、“set“以及“values(“ 等前缀，或者添加“)“等后缀，可用于选择性插入、更新、删除或者条件查询等操作。\napplication.properties（存储接口URL常量）→ConfigFile.java→TestConfig.java（存储接口URL，用CookieStore存储Cookie信息，声明客户端DefaultHttpClient，都为静态变量）\nConfigFile.java\npackage com.tester.utils;import com.tester.model.InterfaceName;import java.util.Locale;import java.util.ResourceBundle;public class ConfigFile &#123;   private static ResourceBundle bundle= ResourceBundle.getBundle(&quot;application&quot;, Locale.CHINA);// InterfaceName是定义的枚举类，表示测试的接口    public static String getUrl(InterfaceName name)&#123;        String address = bundle.getString(&quot;test.url&quot;);        String uri = &quot;&quot;;        String testUrl;        if(name == InterfaceName.GETUSERLIST)&#123;            uri = bundle.getString(&quot;getUserList.uri&quot;);        &#125;        if(name == InterfaceName.LOGIN)&#123;            uri = bundle.getString(&quot;login.uri&quot;);        &#125;        if(name == InterfaceName.UPDATEUSERINFO)&#123;            uri = bundle.getString(&quot;updateUserInfo.uri&quot;);        &#125;        if(name == InterfaceName.GETUSERINFO)&#123;            uri = bundle.getString(&quot;getUserInfo.uri&quot;);        &#125;        if(name == InterfaceName.ADDUSERINFO)&#123;            uri = bundle.getString(&quot;addUser.uri&quot;);        &#125;        testUrl = address + uri;        return testUrl;    &#125;&#125;\n\nDatabaseUtil.java（mysql数据源配置文件→SqlSessionFactory→SqlSession）\nModel层（包括查询对象及相关测试用例）\n6.4 数据校验maven依赖：swagger-ui（SwaggerConfig）、fastjson\nController层（开发接口）→Cases\nCases**（测试用例，将接口执行结果与本地测试用例预期结果相比较）\nLoginTest.java（BeforeTest初始化）\npackage com.tester.cases;import com.tester.model.InterfaceName;import com.tester.config.TestConfig;import com.tester.model.LoginCase;import com.tester.utils.ConfigFile;import com.tester.utils.DatabaseUtil;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import org.apache.ibatis.session.SqlSession;import org.json.JSONObject;import org.testng.Assert;import org.testng.annotations.BeforeTest;import org.testng.annotations.Test;import java.io.IOException;public class LoginTest &#123;    @BeforeTest(groups = &quot;loginTrue&quot;,description = &quot;测试准备工作,获取HttpClient对象&quot;)    public void beforeTest()&#123;        TestConfig.defaultHttpClient = new DefaultHttpClient();        TestConfig.getUserInfoUrl = ConfigFile.getUrl(InterfaceName.GETUSERINFO);        TestConfig.getUserListUrl = ConfigFile.getUrl(InterfaceName.GETUSERLIST);        TestConfig.loginUrl = ConfigFile.getUrl(InterfaceName.LOGIN);        TestConfig.updateUserInfoUrl = ConfigFile.getUrl(InterfaceName.UPDATEUSERINFO);        TestConfig.addUserUrl = ConfigFile.getUrl(InterfaceName.ADDUSERINFO);    &#125;    @Test(groups = &quot;loginTrue&quot;,description = &quot;用户成功登陆接口&quot;)    public void loginTrue() throws IOException &#123;        SqlSession session = DatabaseUtil.getSqlSession();        LoginCase loginCase = session.selectOne(&quot;loginCase&quot;,1);        System.out.println(loginCase.toString());        System.out.println(TestConfig.loginUrl);        //下边的代码为写完接口的测试代码        String result = getResult(loginCase);        //处理结果，就是判断返回结果是否符合预期        Assert.assertEquals(loginCase.getExpected(),result);    &#125;    @Test(description = &quot;用户登陆失败接口&quot;)    public void loginFalse() throws IOException &#123;        SqlSession session = DatabaseUtil.getSqlSession();        LoginCase loginCase = session.selectOne(&quot;loginCase&quot;,2);        System.out.println(loginCase.toString());        System.out.println(TestConfig.loginUrl);        //下边的代码为写完接口的测试代码        String result = getResult(loginCase);        //处理结果，就是判断返回结果是否符合预期        Assert.assertEquals(loginCase.getExpected(),result);    &#125;    private String getResult(LoginCase loginCase) throws IOException &#123;        //下边的代码为写完接口的测试代码        HttpPost post = new HttpPost(TestConfig.loginUrl);        JSONObject param = new JSONObject();        param.put(&quot;userName&quot;,loginCase.getUserName());        param.put(&quot;password&quot;,loginCase.getPassword());        //设置请求头信息 设置header        post.setHeader(&quot;content-type&quot;,&quot;application/json&quot;);        //将参数信息添加到方法中        StringEntity entity = new StringEntity(param.toString(),&quot;utf-8&quot;);        post.setEntity(entity);        //声明一个对象来进行响应结果的存储        String result;        //执行post方法        HttpResponse response = TestConfig.defaultHttpClient.execute(post);        //获取响应结果        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(result);        TestConfig.store = TestConfig.defaultHttpClient.getCookieStore();        return result;    &#125;&#125;\n\nAddUserTest.java\npackage com.tester.cases;import com.tester.config.TestConfig;import com.tester.model.AddUserCase;import com.tester.model.User;import com.tester.utils.DatabaseUtil;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.util.EntityUtils;import org.apache.ibatis.session.SqlSession;import org.json.JSONObject;import org.testng.Assert;import org.testng.annotations.Test;import java.io.IOException;public class AddUserTest &#123;    @Test(dependsOnGroups = &quot;loginTrue&quot;,description = &quot;添加用户接口接口&quot;)    public void addUser() throws IOException, InterruptedException &#123;        SqlSession session = DatabaseUtil.getSqlSession();        AddUserCase addUserCase = session.selectOne(&quot;addUserCase&quot;,1);        System.out.println(addUserCase.toString());        System.out.println(TestConfig.addUserUrl);        //下边的代码为写完接口的测试代码        String result = getResult(addUserCase);        /**         * 可以先讲         */        //查询用户看是否添加成功        Thread.sleep(2000);        User user = session.selectOne(&quot;addUser&quot;,addUserCase);        System.out.println(user.toString());        //处理结果，就是判断返回结果是否符合预期        Assert.assertEquals(addUserCase.getExpected(),result);    &#125;    private String getResult(AddUserCase addUserCase) throws IOException &#123;        //下边的代码为写完接口的测试代码        HttpPost post = new HttpPost(TestConfig.addUserUrl);        JSONObject param = new JSONObject();        param.put(&quot;userName&quot;,addUserCase.getUserName());        param.put(&quot;password&quot;,addUserCase.getPassword());        param.put(&quot;sex&quot;,addUserCase.getSex());        param.put(&quot;age&quot;,addUserCase.getAge());        param.put(&quot;permission&quot;,addUserCase.getPermission());        param.put(&quot;isDelete&quot;,addUserCase.getIsDelete());        //设置请求头信息 设置header        post.setHeader(&quot;content-type&quot;,&quot;application/json&quot;);        //将参数信息添加到方法中        StringEntity entity = new StringEntity(param.toString(),&quot;utf-8&quot;);        post.setEntity(entity);        //设置cookies        TestConfig.defaultHttpClient.setCookieStore(TestConfig.store);        //声明一个对象来进行响应结果的存储        String result;        //执行post方法        HttpResponse response = TestConfig.defaultHttpClient.execute(post);        //获取响应结果        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(result);        return result;    &#125;&#125;\n\nGetUserInfoTest.java\npackage com.tester.cases;import com.tester.config.TestConfig;import com.tester.model.GetUserInfoCase;import com.tester.model.GetUserListCase;import com.tester.model.User;import com.tester.utils.DatabaseUtil;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.util.EntityUtils;import org.apache.ibatis.session.SqlSession;import org.json.JSONArray;import org.json.JSONObject;import org.testng.Assert;import org.testng.annotations.Test;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class GetUserInfoTest &#123;    @Test(dependsOnGroups=&quot;loginTrue&quot;,description = &quot;获取userId为1的用户信息&quot;)    public void getUserInfo() throws IOException, InterruptedException &#123;        SqlSession session = DatabaseUtil.getSqlSession();        GetUserInfoCase getUserInfoCase = session.selectOne(&quot;getUserInfoCase&quot;,1);        System.out.println(getUserInfoCase.toString());        System.out.println(TestConfig.getUserInfoUrl);        //下边为写完接口的代码        JSONArray resultJson = getJsonResult(getUserInfoCase);        /**         * 下边三行可以先讲         */        Thread.sleep(2000);        User user = session.selectOne(getUserInfoCase.getExpected(),getUserInfoCase);        System.out.println(&quot;自己查库获取用户信息:&quot;+user.toString());        List userList = new ArrayList();        userList.add(user);        JSONArray jsonArray = new JSONArray(userList);        System.out.println(&quot;获取用户信息:&quot;+jsonArray.toString());        System.out.println(&quot;调用接口获取用户信息:&quot;+resultJson.toString());        Assert.assertEquals(jsonArray,resultJson);    &#125;    private JSONArray getJsonResult(GetUserInfoCase getUserInfoCase) throws IOException &#123;        HttpPost post = new HttpPost(TestConfig.getUserInfoUrl);        JSONObject param = new JSONObject();        param.put(&quot;id&quot;,getUserInfoCase.getUserId());        //设置请求头信息 设置header        post.setHeader(&quot;content-type&quot;,&quot;application/json&quot;);        //将参数信息添加到方法中        StringEntity entity = new StringEntity(param.toString(),&quot;utf-8&quot;);        post.setEntity(entity);        //设置cookies        TestConfig.defaultHttpClient.setCookieStore(TestConfig.store);        //声明一个对象来进行响应结果的存储        String result;        //执行post方法        HttpResponse response = TestConfig.defaultHttpClient.execute(post);        //获取响应结果        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(&quot;调用接口result:&quot;+result);        List resultList = Arrays.asList(result);        JSONArray array = new JSONArray(resultList);        System.out.println(array.toString());        return array;    &#125;&#125;\n\nUpdateUserInfoTest.java\npackage com.tester.cases;import com.tester.config.TestConfig;import com.tester.model.UpdateUserInfoCase;import com.tester.model.User;import com.tester.utils.DatabaseUtil;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.util.EntityUtils;import org.apache.ibatis.session.SqlSession;import org.json.JSONObject;import org.testng.Assert;import org.testng.annotations.Test;import java.io.IOException;import java.io.UnsupportedEncodingException;public class UpdateUserInfoTest &#123;    @Test(dependsOnGroups = &quot;loginTrue&quot;,description = &quot;更改用户信息&quot;)    public void updateUserInfo() throws IOException, InterruptedException &#123;        SqlSession session = DatabaseUtil.getSqlSession();        UpdateUserInfoCase updateUserInfoCase = session.selectOne(&quot;updateUserInfoCase&quot;,1);        System.out.println(updateUserInfoCase.toString());        System.out.println(TestConfig.updateUserInfoUrl);        //下边为写完接口的代码        int result = getResult(updateUserInfoCase);        /**         * 下边这两行跟着测试的课讲         */        //获取更新后的结果        Thread.sleep(2000);        User user = session.selectOne(updateUserInfoCase.getExpected(),updateUserInfoCase);        System.out.println(user.toString());        Assert.assertNotNull(user);        Assert.assertNotNull(result);    &#125;    @Test(dependsOnGroups = &quot;loginTrue&quot;,description = &quot;删除用户&quot;)    public void deleteUser() throws IOException, InterruptedException &#123;        SqlSession session = DatabaseUtil.getSqlSession();        UpdateUserInfoCase updateUserInfoCase = session.selectOne(&quot;updateUserInfoCase&quot;,2);        System.out.println(updateUserInfoCase.toString());        System.out.println(TestConfig.updateUserInfoUrl);        //下边为写完接口的代码        int result = getResult(updateUserInfoCase);        /**         * 下边这两行跟着测试的课讲         */        Thread.sleep(2000);        User user = session.selectOne(updateUserInfoCase.getExpected(),updateUserInfoCase);        System.out.println(user.toString());        Assert.assertNotNull(user);        Assert.assertNotNull(result);    &#125;    private int getResult(UpdateUserInfoCase updateUserInfoCase) throws IOException &#123;        HttpPost post = new HttpPost(TestConfig.updateUserInfoUrl);        JSONObject param = new JSONObject();        param.put(&quot;id&quot;,updateUserInfoCase.getUserId());        param.put(&quot;userName&quot;,updateUserInfoCase.getUserName());        param.put(&quot;sex&quot;,updateUserInfoCase.getSex());        param.put(&quot;age&quot;,updateUserInfoCase.getAge());        param.put(&quot;permission&quot;,updateUserInfoCase.getPermission());        param.put(&quot;isDelete&quot;,updateUserInfoCase.getIsDelete());        //设置请求头信息 设置header        post.setHeader(&quot;content-type&quot;,&quot;application/json&quot;);        //将参数信息添加到方法中        StringEntity entity = new StringEntity(param.toString(),&quot;utf-8&quot;);        post.setEntity(entity);        //设置cookies        TestConfig.defaultHttpClient.setCookieStore(TestConfig.store);        //声明一个对象来进行响应结果的存储        String result;        //执行post方法        HttpResponse response = TestConfig.defaultHttpClient.execute(post);        //获取响应结果        result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;);        System.out.println(result);        return Integer.parseInt(result);    &#125;&#125;\n\n7 持续集成7.1 Maven打包使用Maven构建的项目均可以直接使用maven build完成项目的编译测试打包，无需额外配置；Maven是通过pom.xml来执行任务的，其中的build标签描述了如何来编译及打包项目，而具体的编译和打包工作是通过build中配置的 plugin 来完成。当然plugin配置不是必须的，默认情况下，Maven 会绑定以下几个插件来完成基本操作。\n测试代码打包：\n\n在pom文件中添加配置\n测试文件\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;            &lt;version&gt;2.7.1&lt;/version&gt;            &lt;configuration&gt;                &lt;suiteXmlFiles&gt;                    ./src/main/resources/testng.xml                &lt;/suiteXmlFiles&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\nSpringboot项目打包指定java编译版本和执行mainClass\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;source&gt;1.8&lt;/source&gt;                &lt;target&gt;1.8&lt;/target&gt;                &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;compilerArguments&gt;                    &lt;extdirs&gt;$&#123;project&#125;/lib&lt;/extdirs&gt;                &lt;/compilerArguments&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;                &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;mainClass&gt;com.xxx.XxxApplication&lt;/mainClass&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;goals&gt;                        &lt;goal&gt;repackage&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n执行命令（cd 模块名 →mvn clean package ）\n\n\n7.2 Jenkins集成环境搭建\n安装配置步骤：\n\n在linux环境中，下载好maven和jdk，然后配置好环境变量；\n\n使用wget  http://mirrors.jenkins.io/war-stable/latest/jenkins.war命令下载Jenkins；\n\n使用 java -jar jenkins.war -httpPort=8081启动Jenkins （避免端口号冲突）；\n\n\n\n任务配置\n新建任务→源码管理（Git）→增加Jenkins（仓库地址，Git用户名密码）→\n构建（Execute shell）\ndeploy\nsource /etc/profilepid=$(ps x | grep &quot;启动的jar包&quot; | grep -v grep | awk &#x27;&#123;print $1&#125;&#x27;)if [ -n &quot;$pid&quot; ]; thenkill -9 $pidficd 开发项目目录mvn clean packagecd targetBUILD_ID=dontKillMenohup -java -jar jar包\n\ntest\nsource /etc/profilecd 测试项目目录mvn clean package\n\n→构建后操作（Build other projects：deploy→test）\n工作目录：~/.jenkins/workspace/\n测试报告\n构建test（在线报告系统搭建）\nsource /etc/profilecd 测试项目目录mvn clean packageresult=$(curl -s Jenkins地址/job/test/lastBuild/buildNumber --user 用户名:密码)#下载并配置tomcatmkdir /apache目录/webapps/ROOT/$result/cp /root/.jenkins/workspace/test/Chapter12/test-output/index.html /apache目录/webapps/ROOT/$result/#浏览器访问apache服务器/任务执行id号/index.html\n\n8 总结项目推进方式\n\n需求阶段：产品需求确认、接口协议/规范制定，接口参数确认\n开发阶段：Mock平台开发（集成提前）、测试用例设计、测试框架搭建与代码开发、持续集成环境搭建\n测试阶段\n\n上线回归\n\n接口自动化测试技术\n\n逻辑层、持久层、展示层\n逻辑控制层：TestNg、HTTPClient\n持久层：MyBatis/Mysql、logBack/Log4J/FileLog\n展示层：ExtentReport/HtmIReport\n\n\nGit代码管理\nJenkins持续集成\nMock平台\n\n接口自动化测试收益\n\n项目流程由串行变为并行\n测试工作由”重后期“变为”重前期“\n测试执行时间缩短若干倍\n测试数据可不断积累，降低漏测率\n测试报告可管理、可追溯、可查询\nMock平台可将集成环节提前，降低集成成本\n\n","tags":["Java","测试","接口测试","持续集成"]}]
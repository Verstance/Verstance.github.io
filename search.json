[{"title":"LeetCode 463.岛屿的长度","url":"/2020/10/30/LeetCode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E9%95%BF%E5%BA%A6/","content":"题目描述：\n给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n示例：\n输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]\n输出: 16\n解释: 它的周长是下面图片中的 16 个黄色的边：\n\n我的解法（迭代）：\nint[] dx = &#123;-1,1,0,0&#125;;int[] dy = &#123;0,0,-1,1&#125;;// 统计每块陆地四周有几块陆地，贡献的周长=4-四周的陆地块数int around1(int[][] grid,int x,int y)&#123;    int num = 0;    for(int i = 0; i &lt; 4; i++)&#123;        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &lt; 0 || xx &gt;= grid.length || yy &lt; 0 || yy &gt;= grid[0].length) continue;        if(grid[xx][yy] == 1) num++;    &#125;    return num;&#125;public int islandPerimeter(int[][] grid) &#123;    int sum = 0;    for(int i = 0; i &lt; grid.length; i++)&#123;        for(int j = 0; j &lt; grid[0].length; j++)&#123;            if(grid[i][j] == 1)&#123;                sum += 4 - around1(grid,i,j);            &#125;        &#125;    &#125;    return sum;&#125;\n\n\n\n用DFS求岛屿周长：\n思路：岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量。（每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1）\n\npublic int islandPerimeter(int[][] grid) &#123;    for (int r = 0; r &lt; grid.length; r++) &#123;        for (int c = 0; c &lt; grid[0].length; c++) &#123;            if (grid[r][c] == 1) &#123;                // 题目限制只有一个岛屿，计算一个即可                return dfs(grid, r, c);            &#125;        &#125;    &#125;    return 0;&#125;int dfs(int[][] grid, int r, int c) &#123;    if (!(0 &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length)) &#123;        return 1;    &#125;    if (grid[r][c] == 0) &#123;        return 1;    &#125;    if (grid[r][c] != 1) &#123;        return 0;    &#125;    grid[r][c] = 2; // 用2标记已遍历过的岛屿    return dfs(grid, r - 1, c)        + dfs(grid, r + 1, c)        + dfs(grid, r, c - 1)        + dfs(grid, r, c + 1);&#125;\n\n链接：https://leetcode-cn.com/problems/island-perimeter\n","tags":["算法","LeetCode","DFS"]},{"title":"Hello World","url":"/2020/10/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"JavaScript入门","url":"/2020/10/26/JavaScript%E5%85%A5%E9%97%A8/","content":"1 基础语法比较运算符===  //等于（类型不同，值一样，也会判断为true）=== //绝对等于（类型一样，值一样，结果才为true）\n\n这是一个JS的缺陷，坚持不要使用 == 比较\n须知：\n\nNaN===NaN返回false，NaN与所有数值都不相等，包括自己\n只能通过isNaN(NaN)来判断这个数是否是NaN\n\n尽量避免使用浮点数进行运算，存在精度问题\nMath.abs(1/3-(1-2/3))&lt;0.000000001\n\n严格检查模式全局变量 i = 1;\n局部变量 var i = 1; let i = 1;（ES6建议使用let）\n严格检查模式\n‘use strict’; 严格检查模式，预防JavaScript的随意性导致产生的一些问题\n字符串多行字符串：\n`XXX\nXXX`\n模板字符串\n`hello,${变量}`\nstr.length str[0] str.toUpperCase() str.toLowerCase()\nstr.subsring(X,Y)返回str[X,Y)\n数组var arr = [1,2,3,4,5,&#x27;hello&#x27;,null,true];new Array(1,2,3,4,5,&#x27;hello&#x27;,null,true);\n\n取数组下标，如果越界(arr[8]),就会提示undifined\n假如给数组的长度arr.length赋值，数组大小就会发生变化\nindexOf：通过元素获得下标索引\nslice()截取Array的一部分，类似字符串中的substring\narr.push(),arr.pop() // 尾部\narr.unshift(),shift() // 头部 \narr.sort()\narr.reverse()\narr.concat() // 不会改变原数组\narr.join(‘-‘) // 连接符 打印\narr.fill(X)\n对象\n每个属性之间使用逗号隔开，最后一个不需要添加\n\nvar person = &#123;    name:&quot;XXX&quot;,    age:18,    tags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;...&#x27;]&#125;\n\n对象赋值：person.name = “XXX”\n取对象的值：person.name\n使用一个不存在的对象属性，不会报错！undefined\n动态删除，添加对象的属性：delete person.name person.XXX=XXX\nJavaScript中所有键都是字符串，值是任意对象\n判断属性值是否在这个对象中！’XXX’ in XXX\n判断一个属性是否是这个对象自身拥有的 hasOwnProperty()\n流程控制arr.forEach(function (value)&#123;  // ES5.1\tconsole.log(value)&#125;)for(var i in arr)&#123;   // i为数组下标&#125;for(var e of arr)&#123;   // e为数组元素&#125;\n\nMap和SetES6的新特性\nvar map = new Map([[&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90]]);var name = map.get(&#x27;tom&#x27;);map.set(&#x27;admin&#x27;,123); // 新增map.delete(&#x27;XXX&#x27;);console.log(name);var set = new Set(1,1,1,3); // 去重set.add(x);set.delete(x);set.has(x);\n\niterater ES6新特性\n函数function abs(x)&#123;\t//定义方式一    //...&#125;var abs = function(x)&#123;\t//定义方式二    //...&#125;\n\n如果没有执行return，函数执行完也会返回结果：undefined\nJavaScript可以传任意参数，也可以不传参数\nvar abs = function(x)&#123;    //手动抛出异常    if(typeof x != &#x27;number&#x27;)&#123;        throw &#x27;Not a Number&#x27;;    &#125;    if(x &gt;= 0)&#123;        return x;    &#125;else&#123;        return -x;    &#125;&#125;\n\narguments参数表示函数传入的所有参数，是一个数组\nrest剩余参数，只能写在最后面，必须用…表示\nfunction aaa(a,b,...rest)&#123;    consloe(&quot;a-&gt;&quot;+a);    consloe(&quot;b-&gt;&quot;+b);    consloe(&quot;rest-&gt;&quot;+rest);&#125;\n\n全局对象 window所有全局变量都绑定在全局对象window上的\nwindow.x（全局变量）\nwindows.alert(window.x)\nvar old_alert = window.alert;//old_alert(x);window.alert = function()&#123;    &#125;;window.alert(123); //失效//恢复window.alert = old_alert;window.alert(456);\n\n全局变量→冲突\n//唯一全局变量var App = &#123;&#125;;//定义全局变量App.name = &#x27;XXX&#x27;;App.add = function (a,b) &#123;    return a + b;&#125;\n\n把自己代码全部放入自己定义的唯一命名空间中，降低全局命名冲突的问题（JQuery）\nES6建议使用let关键字去定义局部作用域的变量（解决局部作用域冲突的问题），使用const定义常量const PI = &#39;3.14&#39;\n方法var XXX = &#123;\tname:&#x27;xxx&#x27;,\tbirth:2020,\t//方法\tage:function()&#123;        var now = new Date().getFullYear();        return now - this.birth;    &#125;&#125;XXX.nameXXX.age()\n\napply在js中可以控制this指向，通过 apply() 方法，能够编写用于不同对象的方法。函数.apply(对象,参数列表)this指向apply的对象\n2 内部对象\n标准对象\n\nnumber, string, boolean, object\ntypeof NaN&quot;number&quot;typeof []&quot;object&quot;typeof undefined&quot;undefined&quot;\n\n2.1 Datevar now = new Date();now.getFullYear(); // 年now.getMonth(); //月（0-11）now.getDate(); //日now.getDay(); //星期几now.getHours(); //时now.getMinutes(); //分now.getSeconds(); //秒now.getTime(); //时间戳 1970.1.1 00:00 - msconsole.log(new Date(113224222)) //时间戳转为时间//转换为字符串now.toLocaleString()now.toGMTString()\n\n2.2 JSON\nJSON(JavaScript Object Notation, JS 对象表示法) 是一种轻量级的数据交换格式。\n\n特点：简洁，清晰的层次结构；易于人阅读和编写，同时也易于机器解析和生成，有效提升网络传输效率\n在JavaScript中一切皆对象，任何JS支持的类型都可以用JSON来表示\n格式：\n\n对象：{}\n数组：[]\n键值对：key:value\n\nJSON字符串和JS对象的转化\nvar user = &#123;    name: &quot;XXX&quot;,    age: 3,    sex: &#x27;男&#x27;&#125;//对象转化为JSON对象var jsonUser = JSON.stringify()//json字符串转化为对象,参数为json字符串var obj = JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;XXX&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;)\n\n2.3 Ajax\n原生的js写法 xhr异步请求\n\nJQuery封装好的方法 $(“#name”).ajax(“”)\n\naxios 请求\n\n\n3 面向对象编程原型：子类（对象）.__proto__ = 父类（原型对象）; //子类的原型是父类\n随意指向\nclass关键字是在ES6引入的\nclass Student&#123;    constructor(name)&#123;        this.name = name;    &#125;    hello()&#123;        alert(&#x27;hello&#x27;)    &#125;&#125;class pupil extends Student&#123;    constructor(name,grade)&#123;        super(name);        this.grade = grade;    &#125;    myGrade()&#123;        alert(&#x27;我是一名小学生&#x27;)    &#125;&#125;var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);xiaoming.hello();\n\n\n\n原型链：_proto_\\\n\n4 操作BOM对象（重点）\nBOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。\n\n浏览器：\n内核：IE， Chrome, Safari, FireFox\n三方：QQ，360\n4.1 windowwindow代表浏览器窗口\nwindow.alert(1)// 调整浏览器窗口大小window.innerHeightwindow.innerWidthwindow.outerHeightwindow.innerWidth\n\n4.2 navigatornavigator封装了浏览器的信息\nnavigator.appNamenavigator.appVersionnavigator.userAgentnavigator.platform\n\n一般不使用，因为会被人为修改，不建议用这些属性来判断浏览器版本\n4.3 screenscreen代表屏幕尺寸\nscreen.widthscreen.height\n\n4.4 location（重要）location代表当前页面的URL信息\nhost: &quot;www.bilibili.com&quot;hostname: &quot;www.bilibili.com&quot;href: &quot;https://www.bilibili.com/video/BV1JJ41177di?p=19&quot;protocol: &quot;https:&quot;reload: ƒ reload() // 刷新页面// 设置新的地址location.assign(&#x27;https://...&#x27;)\n\n4.5 documentdocument代表当前的页面（document.），HTML DOM文档树\n//获取具体的文档树节点&lt;dl id=&quot;app&quot;&gt;    &lt;dt&gt;Java&lt;/dt&gt;    &lt;dd&gt;JavaSE&lt;/dd&gt;&lt;/dl&gt;&lt;script&gt;\tvar dl = document.getElementById(&#x27;app&#x27;);&lt;/script&gt;\n\n获取cookie\ndocument.cookie&quot;finger=158939783; _uuid=C56A5201-E5AB-30A7-6A3D-33573CFAEC4B75115infoc; buvid3=2DE4F72B-D52C-4628-B6F6-D25A79D4DFBD155818infoc; sid=jsr4r70q; im_notify_type_775959=0; LIVE_BUVID=AUTO6215819975268326; LIVE_PLAYER_TYPE=2; DedeUserID=775959; DedeUserID__ckMd5=5a93072db131a757; bili_jct=e4c30825e9523f0d624509aa21012a7e; rpdid=|(J~RllJRmlY0J&#x27;ulm)RkRm)l; blackside_state=1; CURRENT_FNVAL=80; bp_t_offset_775959=434460479141307658; Hm_lvt_8a6e55dbd2870f0f5bc9194cddf32a02=1600696828; CURRENT_QUALITY=80; bp_video_offset_775959=438421933640865406; finger=158939783; PVID=3&quot;\n\n劫持cookie原理\nwww.taobao.com\n&lt;script src=&quot;aa.js&quot;&gt;&lt;/script&gt;&lt;!-- 恶意人员：获取你的cookie上传到他的服务器 --&gt;\n\n服务器可以设置：httpOnly（安全）\n4.6 historyhistory代表浏览器的历史记录（不建议使用）\nhistory.back()history.forward()\n\n5 操作DOM对象（重点）\n文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本,更新其内容、结构和www文档的风格(目前,HTML和XML文档是通过说明部分定义的)。\n\n浏览器网页就是一个DOM树形结构，要操作一个DOM节点，就必须先获得这个DOM节点\n5.1 获得DOM节点标签选择器：document.getElementsByTagName(&#39;h1&#39;)（返回数组）\nid选择器：documen.getElementById(&#39;id&#39;)\nclass选择器：document.getElementByClassName(&#39;class&#39;)（返回数组）\n获得子节点：Node.children\n5.2 更新DOM节点修改文本值：\nNode.innerText = &#39;xxx&#39;\nNode.innerHTML = &#39;xxx&#39;（超文本）\n设置样式：\nNode.style.color/fontSize/... = &#39;xxx&#39;（驼峰命名）\n5.3 删除DOM节点先获取父节点，再通过父节点删除自己\nNode.parentElement.removeChild(Node)（只能通过id选择器选择节点删除）\n注意：删除节点过程中，父节点的children是动态变化的\n5.4 插入DOM节点获得的DOM节点若为空节点，可以通过innerText增加元素\n追加节点：Node1.append(Node2)\n创建新节点：document.createElement(&#39;p&#39;)\n设置节点属性：Node = setAttribute(&#39;属性名&#39;,&#39;属性值&#39;)\n插入节点：Node.insertBefore(newItem,existingItem);\n6 操作表单（验证）表单的目的：提交信息\n获得要提交的信息\ninput_text.valueboy_radio.checked //boolean\n\nMD5加密密码\n表单绑定提交事件\nonsubmit= 绑定一个提交检测的函数，返回布尔值（return false：不提交表单）\n7 jQuery公式：$(selector).action()\n$(&#x27;#id&#x27;).click(function()&#123;    //...&#125;)//当网页元素加载完毕之后，响应事件$(document).ready(function()&#123;    //...&#125;)//↑简写,获取坐标$(function()&#123;    $(&#x27;#divMove&#x27;).mousemove(function(e)&#123;        $(&#x27;mouseMove&#x27;).text(&#x27;x:&#x27;+e.pageX+&#x27;y:&#x27;+e.pageY)    &#125;)&#125;)\n\n文档工具站：https://jquery.cuishifeng.cn/\n操作DOM：\n$(&#x27;#test-ul li[name=python]&#x27;).css(&#123;&quot;color&quot;,&quot;red&quot;&#125;)$(&#x27;#test-ul li[name=python]&#x27;).show()/hide()$(window).width\n\n\n\nLayUI 弹窗组件\nElementUI 样式好看\n","tags":["JavaScript","JQuery","前端"]},{"title":"网络编程入门","url":"/2020/10/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/","content":"1 概述计算机网络：地理位置不同 多台计算机 连接 通信 共享\n网络编程的目的：数据交换，通信\n如何实现多台主机之间的数据通信：\n\n准确定位网络上的一台主机以及该主机的某个资源（IP：Port）\n传输数据？\n\nJavaWeb：网页编程  B/S\n网络编程：TCP/IP      C/S\n2 网络通信的要素实现网络通信需要知道通信双方地址（ip、端口号）\n规则：网络通信协议\nTCP/IP参考模型：\n\n网络编程专门针对传输层（TCP/IP）\n3 IPip地址：InetAddress\n\n唯一定位一台网络上的计算机\n127.0.0.1：本机localhost\nip地址的分类：\nipv4/ipv6\nipv4：10.164.120.176    4个字节组成，0~255，42亿中30亿在北美，亚洲4亿，2011年就用尽\nipv6：fe80::a1a2:85b0:e7d9:58f1%7  128位，8个无符号整数  \n\n\n公网（互联网） 私网（局域网）\nABCD类地址\n192.168.xx.xx 专门给组织内部使用的\n\n\n\n\n域名→记忆IP问题！\n\n4 端口端口表示计算机上的一个程序的进程：\n\n不同进程有不同的端口号！（不能冲突）用来区分进程！\n\n范围：0~65535\n\nTCP，UDP：65535*2 单个协议下，端口号不能冲突\n\n端口分类\n\n公有端口 0~1023\n\nHTTP：80\nHTTPS：443\nFTP：21\nTelnet：23\n\n\n程序注册端口：1024~49151 分配给用户或者程序\n\nTomcat：8080\nMySQL：3306\nOracle：1521\n\n\n动态/私有端口：49152~65535\nnetstat -ano #查看所有端口netstat -ano|findstr &quot;端口号&quot; #查看指定的端口tasklist|findstr &quot;端口号&quot; #查看指定端口的进程\n\n\n\n\n\n5 通信协议协议：约定\n网络通信协议：速率，传输码率，代码结构，传输控制……\nTCP/IP协议簇\n重要：\n\nTCP：传输控制协议\nUDP：用户数据报协议\n\nTCP vs UDP\n打电话~TCP\n\n连接，稳定\n\n三次握手，四次挥手\n最少需要三次，保证稳定连接！A:你瞅啥？B:瞅你咋地？A:干一场！A:我要走了B:你真的要走了吗？B:你真的真的要走了吗？A:我真的真的要走了！\n\n\n\n客户端、服务端\n\n传输完成，释放连接，效率低\n\n\n发短信~UDP\n\n不连接，不稳定\n客户端、服务器：没有明确的界限\n不管有没有准备好，都可以发给你\n导弹\nDDoS：洪水攻击（饱和攻击）\n\n6 TCP聊天客户端\n\n通过Socket连接服务器\n发送消息\n\npackage tcp;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\tInetAddress serverIP = null;\t\tint port = 0;\t\tSocket socket = null;\t\tOutputStream os = null;\t\ttry &#123;\t\t\t//1.得知服务器地址\t\t\tserverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\tport = 9999;\t\t\t//2.创建一个socket连接\t\t\tsocket = new Socket(serverIP,port);\t\t\t//3.发送消息\t\t\tos = socket.getOutputStream();\t\t\tos.write(&quot;你好&quot;.getBytes());\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\tif(os!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;            if(socket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tsocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t&#125;&#125;\n\n服务器端\n\n建立服务端口\n通过accept等待用户连接\n接收用户消息\n\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tServerSocket serverSocket = null;\t\tSocket socket = null;\t\tInputStream is = null;\t\tByteArrayOutputStream baos = null;\t\t\t\ttry &#123;\t\t\t//1.有地址\t\t\tserverSocket = new ServerSocket(9999);\t\t\t//2.等待客户端连接\t\t\tsocket = serverSocket.accept();\t\t\t//3.读取客户端的消息\t\t\tis = socket.getInputStream();\t\t\t//管道流\t\t\tbaos = new ByteArrayOutputStream();\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tbaos.write(buffer,0,len);\t\t\t&#125;\t\t\tSystem.out.println(baos.toString());\t\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\t//关闭资源\t\t\tif(baos!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tbaos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(is!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(serverSocket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tserverSocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\n\n\n\n文件上传服务器端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import org.omg.CORBA_2_3.portable.OutputStream;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\t\ttry &#123;\t\t\t//1.创建服务\t\t\tServerSocket serverSocket = new ServerSocket(9999);\t\t\t//2.监听客户端连接\t\t\tSocket socket = serverSocket.accept();\t\t\t//3.读取输入流\t\t\tInputStream is = socket.getInputStream();\t\t\t//4.文件输出\t\t\tFileOutputStream fos = new FileOutputStream(new File(&quot;receive.jpg&quot;));\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tfos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tis.close();\t\t\tfos.close();\t\t\tsocket.close();\t\t\tserverSocket.close();\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\n客户端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\t//1.创建一个socket连接\t\t\tSocket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);\t\t\t//2.创建一个输出流\t\t\tOutputStream os = socket.getOutputStream();\t\t\t//3.读取文件\t\t\tFileInputStream fis = new FileInputStream(new File(&quot;dog.jpg&quot;));\t\t\t//4.写出文件\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=fis.read(buffer))!=-1)&#123;\t\t\t\tos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tfis.close();\t\t\tos.close();\t\t\tsocket.close();\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t\t&#125;&#125;\n\n服务端（Tomcat）\n客户端（浏览器）\n7 UDP发短信：不用连接，需要知道对方地址\n发送消息发送端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;//不需要连接服务器public class Client &#123;\tpublic static void main(String[] args) throws Exception &#123;\t//1.建立一个Socket\tDatagramSocket socket = new DatagramSocket();\t//2.建个包\t\tString msg = &quot;Hello!&quot;;\tInetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\tint port = 9090;\t//数据，数据的长度起始，发送给谁\tDatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);\t//3.发送包\tsocket.send(packet);\t//4.关闭流\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;//还是要等待客户端的连接！public class Server &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//开放端口\t\tDatagramSocket socket = new DatagramSocket(9090);\t\t//接收数据包\t\tbyte[] buffer = new byte[1024];\t\tDatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); //接收\t\tsocket.receive(packet);//阻塞接收\t\tSystem.out.println(packet.getAddress().getHostAddress());\t\tSystem.out.println(new String(packet.getData(),0,packet.getLength()));\t\t//关闭连接\t\tsocket.close();\t&#125;&#125;\n\n循环发送消息发送端\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class Sender &#123;\t/**\t * @param args\t * @throws Exception \t */\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(8888);\t\t//准备数据：控制台读取\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true)&#123;\t\t\t//2.建个包\t\t\t\tString data = reader.readLine();\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t//数据，数据的长度起始，发送给谁\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,6666));\t\t\t//3.发送包\t\t\tsocket.send(packet);\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t\t//4.关闭流\t\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receiver &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(6666);\t\t\t\twhile(true)&#123;\t\t\t//准备接收包裹\t\t\tbyte[] container = new byte[1024];\t\t\tDatagramPacket packet = new DatagramPacket(container,0,container.length);\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t//断开连接 bye\t\t\tbyte[] data = packet.getData();\t\t\tString receiveData = new String(data,0,data.length).trim();\t\t\tSystem.out.println(receiveData);\t\t\tif(receiveData.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n在线咨询：两个人既可以是发送端也可以是接收端（多线程）\n线程TalkSend\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class TalkSend implements Runnable&#123;\tDatagramSocket socket = null;\tBufferedReader reader = null;\t\tprivate int fromPort;\tprivate String toIP;\tprivate int toPort;\t\tpublic TalkSend(int fromPort, String toIP, int toPort) &#123;\t\tsuper();\t\tthis.fromPort = fromPort;\t\tthis.toIP = toIP;\t\tthis.toPort = toPort;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(fromPort);\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\twhile(true)&#123;\t\t\tString data;\t\t\ttry &#123;\t\t\t\tdata = reader.readLine();\t\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));\t\t\t\tsocket.send(packet);\t\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\tsocket.close();\t&#125;&#125;\n\n线程TalkReceive\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class TalkReceive implements Runnable&#123;\tDatagramSocket socket = null;\tprivate int port;\tprivate String msgFrom;\t\tpublic TalkReceive(int port,String msgFrom) &#123;\t\tsuper();\t\tthis.port = port;\t\tthis.msgFrom = msgFrom;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(port);\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\t\twhile(true)&#123;\t\t\ttry &#123;\t\t\t\t//准备接收包裹\t\t\t\tbyte[] container = new byte[1024];\t\t\t\tDatagramPacket packet = new DatagramPacket(container, 0,container.length);\t\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t\t//断开连接 bye\t\t\t\tbyte[] data = packet.getData();\t\t\t\tString receiveData = new String(data, 0, data.length).trim();\t\t\t\tSystem.out.println(msgFrom+&quot;：&quot;+receiveData);\t\t\t\tif (receiveData.equals(&quot;bye&quot;)) &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n老师TalkTeacher\npackage udp;public class TalkTeacher &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tnew Thread(new TalkSend(5555,&quot;localhost&quot;,8888)).start();\t\tnew Thread(new TalkReceive(9999,&quot;学生&quot;)).start();\t&#125;&#125;\n\n学生TalkStudent\npackage udp;public class TalkStudent &#123;\tpublic static void main(String[] args) &#123;\t\t//开启两个线程\t\tnew Thread(new TalkSend(7777,&quot;localhost&quot;,9999)).start();\t\tnew Thread(new TalkReceive(8888,&quot;老师&quot;)).start();\t&#125;&#125;\n\n8 URL统一资源定位符：定位互联网资源\n协议://ip地址：端口/项目名/资源\nurl下载网络资源\npackage url;import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLDown &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.下载地址\t\tURL url = new URL(&quot;http://127.0.0.1:8080/zhg/Confidential.txt&quot;);\t\t//2.连接这个资源HTTP\t\tHttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();\t\tInputStream inputStream = urlConnection.getInputStream();\t\tFileOutputStream fos = new FileOutputStream(&quot;cfile.txt&quot;);\t\tbyte[] buffer = new byte[1024];\t\tint len;\t\twhile((len=inputStream.read(buffer))!=-1)&#123;\t\t\tfos.write(buffer, 0, len); \t\t&#125;\t\tfos.close();\t\tinputStream.close();\t\turlConnection.disconnect();\t&#125;&#125;\n\n","tags":["Java","JavaSE","网络编程","TCP","UDP"]},{"title":"MySQL教程","url":"/2020/10/26/MySQL%E6%95%99%E7%A8%8B/","content":"数据库XX语言：DDL, DML, DQL, DCL\n1 数据库1.1 连接数据库命令行连接\nmysql -uroot -pupdate mysql.user set password = password(&#x27;XXX&#x27;) where user = &#x27;root&#x27; and Host = &#x27;localhost&#x27;; -- 修改用户密码flush privileges; -- 刷新权限-----------------------------------------------show tables;describe 表名; -- 显示表信息exit; -- 退出连接\n\n1.2 操作数据库create database [if not exists] 数据库名 -- 创建drop database [if exists] 数据库名 -- 删除use 数据库名 -- 使用/切换 如果数据库名是关键词，则加上``show databases; -- 查看\n\n\n\n数据类型：\n\n数值：\n\n\n整型：tinyint 1B,smallint 2B, int 4B, bigint 8B\n浮点型：float 4B, double 8B, decimal（字符串形式的浮点数，常用于金融计算）\n\n\n字符串\n\n\nchar 固定大小 0~255,\n\nvarchar 可变 0~65535\n\ntinytext 微型文本 2^8 - 1\n\ntext 文本串 2^16-1\n\n\n\n时间日期\n\n\ndate YYYY- MM- DD\ntime HH: mm: ss \ndatetime YYYY- MM - DD HH: mm: ss\ntimestamp 时间戳，1970.1.1到现在的毫秒数\nyear 年份表示\n\n\nNULL\n\n每个表都必须存在以下五个字段：\n\nid 主键\n`version`乐观锁\nis_delete 伪删除\ngmt_create 创建时间\ngmt_update 修改时间\n\n2 表2.1 创建表CREATE TABLE [IF NOT EXISTS] `student`&#123;\t`id` INT(4) [NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;],\t...\tPRIMARY KEY(`id`)&#125;[ENGINE=INNODB DEFAULT CHARSET=utf-8]\n\n查看创建语句\nSHOW CREATE DATABASE school -- 查看创建数据库语句SHOW CREATE TABLE student -- 查看创建表语句DESC student -- 显示表结构\n\n\n\n数据表的类型\nINNODB（默认）\nMYISAM（早年使用）\n\n\n\n\nMYISAM\nINNODB\n\n\n\n事务支持\n不支持\n支持\n\n\n数据行锁定\n不支持\n支持\n\n\n外键约束\n不支持\n支持\n\n\n全文索引\n支持\n不支持\n\n\n表空间大小\n较小\n较大，约为2倍\n\n\n常规使用的操作：\n\nMYISAM：节约空间，速度较快\nINNODB：安全性高，事务的处理，多表多用户操作\n\n所有的数据库文件都存在data目录下，本质还是文件的存储\nMySQL引擎在物理文件上的区别\n\nINNODB在数据库表中只有*.frm文件，以及上级目录下的ibdata1文件\nMYISAM对应文件\n*.frm - 表结构的定义文件\n*.MYD 数据文件（data）\n*.MYI 索引文件（index）\n\n\n\n2.2 修改删除表\n修改（alter）\n\nALTER TABLE teacher RENAME AS teacher1 -- 修改表名ALTER TABLE teacher1 ADD age INT(11) -- 增加字段-- 修改表的字段ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束ALTER TABLE teacher1 CHANGE age age1 VARCHAR(1) -- 重命名-- 删除表的字段ALTER TABLE teacher1 DROP age1\n\n\n\n\n删除\n\n-- 删除表DROP TABLE [IF EXISTS] teacher1\n\n3 MySQL数据管理3.1 外键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`);\n\n以上操作都是物理外键，数据库级别的外键，不建议使用，避免数据库过多造成困扰\n3.2 DML语言数据库意义：数据存储，数据管理\n添加：insert into 表名[(字段1,2,3...)]values(值1,2,3...)[,(),()...]\n修改：update 表名 set 字段1 = 值1[,字段2 = 值2...] where 条件\n删除：delete from 表名 where 条件\ntruncate 表名：完全清空一个数据库表，表的结构和索引约束不会变！\ntruncate 重新设置，自增列，计数器会归零，不会影响事务\nwhere子句\n=, &gt;, &lt;, &lt;=, &gt;= &lt;&gt;或者!=（不等于）, BETWEEN X AND Y （[X,Y]）\nAND, OR\n注意：没写条件则修改表的所有记录！\n4 DQL查询数据\nDQL:Data QueryLanguage 数据查询语言\n\nselect 字段 [as 别名] from 表 [as 别名]\n函数\nconcat(a,b)\n去重 distinct select distinct 字段 ...\n可以select的表达式：文本值，列，Null，函数，计算表达式，系统变量… \n4.1 模糊查询is null,like, in\n-- 查询姓刘的同学-- like结合 %代表0到任意个字符 _代表一个字符select `StudentNo`,`StudentName` from `student`where StudentName like &#x27;刘%&#x27;--查询1001,1002,1003号学员select `StudentNo`,`StudentName` from `student`where StudentNo in (1001,1002,1003)\n\n4.2 联表查询where 等值查询\njoin on 连接查询\n\n查表思路：\n\n分析需求：分析查询的字段来自哪些表\n确定使用哪种连接查询（7种）\n确定交叉点（判断的条件：student.studentNo = grade.studentNo）\n\n-- 查询缺考的学生select s.StudentNo,studentName,SubjectNo,StudentResultfrom student sleft join result ron s.studentNo = r.studentNowhere StudentResult is null\n\n自连接核心：一张表拆成两张一样的表\nselect a.`categoryName` as &#x27;父栏目&#x27;,b.`categoryName` as &#x27;子栏目&#x27;from `category` as a,`category` as bwhere a.`categoryid` = b.`pid`\n\n4.3 分页和排序limit &amp; order by\n排序：升序 ASC 降序 DESC\n-- 分页：起始值，页面大小limit start(0-),sizelimit 0,5 -- 第一页limit 5,5 -- 第二页...limit (N-1)*pageSize,pageSize --第N页\n\n4.4 嵌套查询select 字段 from 表\nwhere(子查询)\n-- 由里及外select StudentNo,StudentName from student where StudentNo in (    select StudentNo from result where StudentResult&gt;80    and SubjectNo = (        select SubjectNo from `subject` where `SubjectName` = &#x27;高等数学-2&#x27;    ))\n\n5 MySQL函数官网：https://dev.mysql.com/doc/refman/5.7/en/sql-function-reference.html\n5.1 常用函数-- 数学函数select abs(-8) -- 8select ceiling(9.4) -- 10select floor(9.4) -- 9select rand() -- 0~1select sign(-10/0/10) -- -1,0,1-- 字符串函数select char_length(&#x27;xxxxx&#x27;)select concat(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)select insert(&#x27;xxx&#x27;,pos,length,&#x27;yyy&#x27;)select lower(&#x27;XXX&#x27;)select upper(&#x27;xxx&#x27;)select instr(&#x27;xyz&#x27;,&#x27;x&#x27;) -- 返回子串第一次出现的索引select replace(&#x27;abc&#x27;,&#x27;b&#x27;,&#x27;d&#x27;)select substr(&#x27;abcdefg&#x27;,pos,length)select reverse(&#x27;cba&#x27;)-- 查询姓周的同学,替换成邹select replace(studentname,&#x27;周&#x27;&#x27;邹&#x27;） from studentwhere studentname like &#x27;周%&#x27;               -- 时间和日期函数（记住）select current_date()select curdate()select now() -- 当前时间select localtime()select sysdate()-- 系统select system_user()    select user()select version()\n\n5.2 聚合函数select count(字段) from 表 -- 忽略null值，有主键，count(字段)查询效率高select count(*) from 表select count(1) from 表select sum(`StudentResult`) as 总和 from resultselect avg(`StudentResult`) as 平均分 from resultselect max(`StudentResult`) as 最高分 from resultselect min(`StudentResult`) as 最低分 from result-- 分组：查询不同课程的平均分，最高分，最低分select SubjectName,avg(StudentResult) as 平均分,max(StudentResult) as 最高分,min(StudentResult) as 最低分from result rinner join `subject` subon r.`SubjectNo` = sub.`SubjectNo`group by r.SubjectNo -- 分组字段having 平均分&gt;80\n\n5.3 MD5加密不可逆\n破解原理：暴力破解，一个个试\nMD5(pwd)\n将用户传递进来的密码，进行MD5加密，然后比对加密后的值\n6 事务将一组SQL放在一个批次中执行\n原则：ACID（原子性，一致性，隔离性，持久性）\n原子性（Atomicity）\n要么都成功，要么都失败\n一致性（Consistency）\n事务前后的数据完整性要保证一致\n隔离性（Isolation）\n事物之间要相互隔离\n持久性（Durability）\n事务一旦提交则不可逆，被持久化到数据库中\n隔离导致的问题：脏读（读到另一事务未提交的数据）、不可重复读（多次读取结果不同）、幻读（读取别的事务插入的数据）\n-- mysql默认开启事务自动提交set autocommit = 0 -- 关闭set autocommit = 1 -- 开启（默认）-- 手动处理事务set autocommit = 0-- 事务开启start transactioninsert XXXinsert yyy-- 提交commit-- 回滚rollback-- 事务结束set autocommit = 1-- 了解savepoint 保存点名rollback to savepoint 保存点名release savepoint 保存点名\n\n7 索引\nMySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。\n\n7.1 索引的分类\n主键索引（primary key）\n唯一索引（unique key）\n常规索引（key/index）\n全文索引（fulltext）\n\n-- 索引的使用-- 1.在创建表的时候给字段增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息select index from 表名-- 增加一个全文索引alter table 数据库.表名 add fulltext index 索引名(字段名)-- explain分析sql执行的状况explain select * from student --非全文索引explain select * from student where match(studentName) against(&#x27;刘&#x27;)\n\n7.2 测试索引 插入100万条数据测试索引\n--  插入100万条数据delimiter $$ -- 写函数前必须写，标志create function mock_data()returns intbegin\tdeclare num int default 1000000;\tdeclare i int default 0;\twhile i&lt;num do\t\t-- 插入语句\t\tinsert into app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) values(concat(&#x27;用户&#x27;,i),&#x27;178343244@qq.com&#x27;,concat(&#x27;18&#x27;,floor(rand()*(999999999-100000000))+100000000),floor(rand()*2),uuid(),floor(rand()*100));\t\tset i = i+1;\tend while;\t\treturn i;end;select mock_data();-- 测试索引select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.0993 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询99万条数据-- 创建普通索引-- create index 索引名 on 表(字段)-- 索引名：id_表名_字段名create index id_app_user_name on app_user(`name`);select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.001 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询1条数据\n\n总结：索引在小数据量的时候用处不大，但在大数据的时候，区别十分明显\n7.3 索引原则\n索引不是越多越好\n不要对经常变动的数据加索引\n小数据量的表不需要加索引\n索引一般加在经常查询的字段上\n\n\n索引的数据结构\n\nHash类型的索引\nBtree：InnoDB默认\nhttp://blog.codinglabs.org/articles/theory-of-mysql-index.html\n8 权限管理和备份8.1 权限管理SQL命令操作：本质是对用户表mysql.user进行改动\n-- 创建用户create user xxx identified by &#x27;123456&#x27;-- 修改密码set password [for xxx] = password(&#x27;123456&#x27;)-- 重命名rename user xxx to yyy-- 用户授权 库.表grant all privileges on *.* to xxx -- all privileges 除授权权限-- 查询权限show grants for xxxshow grants for root@localhost-- 撤销权限revoke all privileges on *.* from xxx-- 删除用户drop user xxx\n\n8.2 MySQL备份目的：保证数据不丢失，数据转移\n方式：\n\n直接复制物理文件\n在Navicat这种可视化工具中手动导出\n使用命令行导出 mysqldump\n\nmysqldump -hlocalhost -uroot -p123456 school student &gt;D:/a.sql# 导入# 登录的情况下，切换到指定的数据库# source 备份文件source d:/a.sqlmysql -u用户名 -p密码 库名&lt; 备份文件\n\n9 规范数据库设计数据库设计：分析需求→概要设计（E-R图）\n三大范式：\n\n第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。\n1NF保证每一列不可再分\n\n第二范式（2NF）：满足1NF的前提下，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）\n2NF保证每张表只描述一件事物\n\n第三范式（3NF）：满足2NF的前提下，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\n3NF保证表中每一列数据都与主键直接相关\n\n\n规范性和性能的问题：\n关联查询的表不得超过三张\n\n考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要\n在规范性能的问题的时候，需要适当考虑规范性\n故意给某些表增加一些冗余的字段。（多表查询→单表查询）\n故意增加一些计算列（大数据量查询→小数据量查询）\n\n10 JDBCJava操作数据库\n程序通过数据库驱动操作数据库\n需要导入一个数据库驱动包：mysql-connector-java-X.X.XX.jar\npublic class JDBCFirstDemo &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        // 1. 加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 固定写法，自动加载DriverManager.registerDriver(new com.mysql.jdbc,Driver());        // 2. 用户信息和url        String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=true&quot;; // 协议(jdbc:mysql)://主机地址:端口号/数据库名?参数        String username = &quot;root&quot;;        String password = &quot;1031&quot;;        // 3. 连接成功，数据库对象Connection        Connection connection = DriverManager.getConnection(url,username,password);        // 4. Statement执行SQL对象        Statement statement = connection.createStatement();        String sql = &quot;select * from users&quot;;        ResultSet resultSet = statement.executeQuery(sql);        // 5.查看返回结果        while(resultSet.next())&#123;            System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));            System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));            System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));            System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));            System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));            System.out.println(&quot;=================&quot;);        &#125;        // 6. 释放连接，耗资源，用完关掉        resultSet.close();        statement.close();        connection.close();    &#125;&#125;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\nStatement &amp; ResultSet\nConnection connection = DriverManager.getConnection(url,username,password);Statement statement = connection.createStatement();String sql = &quot;select * from users&quot;;ResultSet resultSet = statement.executeQuery(sql); // 查询操作返回ResultSetstatement.execute(); // 执行任何SQLstatement.executeUpdate(); // 更新、插入，删除，返回一个受影响的行数// ResultSetresultSet.getObject(&quot;id&quot;) // 不知道返回类型resultSet.getString(&quot;id&quot;) // 知道返回类型// 遍历指针（光标）resultSet.next() // 移动到下一行resultSet.beforeFirst() // 移动到最前resultSet.afterLast() // 移动到最后resultSet.previous()  // 移动到前一行resultSet.absolute(row) //移动到指定行\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.2 SQL注入\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SQLInjection &#123;    public static void main(String[] args) &#123;        login(&quot;zhg&quot;,&quot;123456&quot;); // 正常登录        login(&quot;&#x27;or&#x27;1=1&quot;,&quot;&#x27;or&#x27;1=1&quot;); //SQL注入：用or拼接SQL语句...    &#125;    // 登录业务    public static void login(String username,String password)&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users where `NAME` =&#x27;&quot;+username+&quot;&#x27; and `PASSWORD` = &#x27;&quot;+password+&quot;&#x27;&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.3 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n10.4 数据库连接池数据库连接→执行→释放，非常浪费系统资源\n池化技术：准备一些预先的资源，过来就连接预先准备好的\n编写连接池，实现接口DataSource\n开源数据源实现\nDBCP\nC3P0\nDruid：阿里\n使用这些数据库连接池之后，我们在项目开发中不需要编写数据库的代码了！\nDBCP，需要jar包：commons-dbcp-1.4, commons-pool-1.6\nC3P0，需要jar包：c3p0-0.9.5.5, mcharge-commons-java-0.2.19\n无论使用什么数据源，本质还是一样的，DataSource接口不会变，方法就不会变\n","tags":["MySQL","JDBC"]},{"title":"注解和反射","url":"/2020/10/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","content":"1 注解简介注解（Annotation）是从JDK5.0开始引入的新技术\n作用：\n\n对程序作出解释（非必须，检查和约束）\n被其他程序读取（编译器）\n\n格式：@注解名（有的还可以添加参数值）\nAnnotation可以附加在package, class, method, field 等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问\n1.1 内置注解@Override：重写父类方法\n@Deprecated：不推荐使用\n@SuppressWarnings(“all”)：抑制警告\n1.2 元注解作用：注解其他注解，为其他annotation提供说明\nJava定义了4个标准的meta-annotation类型：@Target, @Retention, @Document, @Inherited\n\n@Target：描述注解的使用范围\n\n@Retention：描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）\n\n@Documented：说明该注解被包含在javadoc中\n\n@inherited：说明子类可以继承父类中的该注释\n\n\n1.3 自定义注解格式：public @ interface 注解名 {定义内容}\npublic class Test extends Object&#123;\t//注解可以显式赋值，如果没有默认值，则必须赋值\t@MyAnnotation(name = &quot;XXX&quot;,schools = &#123;&quot;门头沟大学&quot;,&quot;家里蹲大学&quot;&#125;)\tpublic void test() &#123;\t\t&#125;&#125;//定义一个注解//Target 描述注解使用范围@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 描述注解生效时间@Retention(value = RetentionPolicy.RUNTIME)//Documented 表示将注解生成在javadoc中@Documented//Inherited 表示子类可以继承父类的注解@Inherited@interface MyAnnotation&#123;\t//注解的参数：参数类型+参数名()\t//假如只有一参数，建议命名为value\tString name() default &quot;&quot;;\tint age() default 0;\tint id() default -1;\tString[] schools() default &#123;&quot;&quot;&#125;;&#125;\n\n2 反射机制静态语言VS动态语言\n\n动态语言：运行时代码可以根据某些条件改变自身结构（C#, JavaScript, Python…）\n\n静态语言：运行时结构不可变（Java, C, C++…）\n\n\nJava不是动态语言，但Java可以利用反射机制获得类似动态语言的特性\n反射机制（Reflection）允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法\n功能：\n\n运行时进行与类（对象）相关的操作\n运行时处理注解\n生成动态代理（AOP）\n\n优点：实现动态创建对象和编译，体现出很大的灵活性\n缺点：对性能有影响。使用反射基本上是一种解释操作，这类操作总是慢于直接执行相同的操作\n主要API：java.lang.Class…\n2.1 Class类Object类中定义了getClass()方法，被所有子类继承\n\n获取Class类的实例：\npublic class Test01 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\tPerson person = new Student();\t\tSystem.out.println(&quot;这个人是：&quot;+person.name);\t\t//一个类在内存中只有一个Class对象\t\t//一个类被加载后，类的整个结构都会被封装在Class对象中\t\t//获取类的Class对象\t\t//方式一：通过对象获得\t\tClass c1 = person.getClass();\t\tSystem.out.println(c1.hashCode());\t\t\t\t//方式二：通过Class.forName获得\t\tClass c2 = Class.forName(&quot;com.zhg.reflection.Student&quot;);\t\tSystem.out.println(c2.hashCode());\t\t\t\t//方式三：通过类名.class获得\t\tClass c3 = Student.class;\t\tSystem.out.println(c3.hashCode());\t\t\t\t//方式四：基本内置类型的包装类都有一个TYPE属性\t\tClass c4 = Integer.TYPE;\t\tSystem.out.println(c4);\t\t\t\t//获得父类类型\t\tClass c5 = c1.getSuperclass();\t\tSystem.out.println(c5);\t&#125;&#125;class Person&#123;\tpublic String name;\tpublic Person() &#123;\t\tsuper();\t&#125;\tpublic Person(String name) &#123;\t\tsuper();\t\tthis.name = name;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Person [name=&quot; + name + &quot;]&quot;;\t&#125;&#125;class Student extends Person&#123;\tpublic Student() &#123;\t\tthis.name = &quot;学生&quot;;\t&#125;&#125;class Teacher extends Person&#123;\tpublic Teacher() &#123;\t\t\t&#125;&#125;\n\n哪些类型可以有Class对象？\nimport java.lang.annotation.ElementType;//所有类型的Class对象public class Test02 &#123;\tpublic static void main(String[] args) &#123;\t\tClass c1 = Object.class; //类\t\tClass c2 = Comparable.class; //接口\t\tClass c3 = String[].class; //一维数组\t\tClass c4 = int[][].class; //二维数组\t\tClass c5 = Override.class; //注解\t\tClass c6 = ElementType.class; //枚举\t\tClass c7 = Integer.class; //基本数据类型包装类\t\tClass c8 = void.class; //void\t\tClass c9 = Class.class; //Class\t\tSystem.out.println(c1); //class java.lang.Object\t\tSystem.out.println(c2); //interface java.lang.Comparable\t\tSystem.out.println(c3); //class [Ljava.lang.String;\t\tSystem.out.println(c4); //class [[I\t\tSystem.out.println(c5); //interface java.lang.Override\t\tSystem.out.println(c6); //class java.lang.annotation.ElementType\t\tSystem.out.println(c7); //class java.lang.Integer\t\tSystem.out.println(c8); //void\t\tSystem.out.println(c9); //class java.lang.Class\t\t//只要元素类型与维度一样，就是同一Class\t\tint[] a = new int[10];\t\tint[] b = new int[100];\t\tSystem.out.println(a.getClass().hashCode());\t\tSystem.out.println(b.getClass().hashCode()); \t&#125;&#125;\n\n2.2 内存分析Java内存：堆（方法区），栈\n堆：存放new的对象和数组，可以被所有线程共享\n方法区：特殊的堆，存放所有class和static变量\n栈：存放基本变量类型，引用类型的变量\n2.2.1 类的加载过程\n加载（Load）：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象\n链接（Link）：将Java类的二进制代码合并到JVM的运行状态（JRE）中的过程\n\n验证：确保加载类信息符合JVM规范，没有安全问题\n准备：为类变量（static）分配内存并设置默认初始值\n解析：虚拟机常量池的符号（常量名）引用替换为直接引用（地址）的过程\n\n初始化（Initialize）：\n\n执行类构造器&lt;clinit&gt;()方法的过程（类构造器是构造类信息的）\n先触发父类的初始化\n保证&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步\n\npublic class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\tA a = new A();\t\tSystem.out.println(A.m);\t\t/*\t\t 1.加载到内存，会产生一个类对应的Class对象\t\t 2.链接，链接结束后 m = 0\t\t 3.初始化\t\t &lt;clinit&gt;()&#123;\t\t \tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\t\tm = 300;\t\t\tm = 100;\t\t&#125;\t\tm = 100;\t\t */\t&#125;&#125;class A&#123;\tstatic &#123;\t\tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\tm = 300;\t&#125;\tstatic int m = 100;\tpublic A() &#123;\t\tSystem.out.println(&quot;A类的无参构造器初始化&quot;);\t&#125;&#125;\n\n2.2.2 类的初始化什么时候会发生类的初始化？\n\n类的主动引用（一定会发生类的初始化）\n虚拟机启动时先初始化main方法所在的类\nnew一个类的对象\n调用类的静态成员和静态方法（除了final常量）\n对类进行反射调用\n当初始化一个类时，先初始化其父类\n\n\n类的被动引用（不会发生类的初始化）\n当访问静态域时，只有真正声明这个于的类才会被初始化\n通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）\n\n\n\n//测试类什么时候会初始化public class Test04 &#123;\tstatic &#123;\t\tSystem.out.println(&quot;main类被加载&quot;);\t&#125;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//1.主动引用\t\t//Son son = new Son();\t\t\t\t//反射也会产生主动引用\t\t//Class.forName(&quot;com.zhg.reflection.Son&quot;);\t\t\t\t//不会产生类的引用的方法\t\t//System.out.println(Son.b);\t\t//Son[] array = new Son[5];\t\tSystem.out.println(Son.M);\t&#125;&#125;class Father&#123;\tstatic int b = 2;\tstatic &#123;\t\tSystem.out.println(&quot;父类被加载&quot;);\t&#125;&#125;class Son extends Father&#123;\tstatic &#123;\t\tSystem.out.println(&quot;子类被加载&quot;);\t\tm = 300;\t&#125;\t\tstatic int m = 100;\tstatic final int M = 1;&#125;\n\n2.2.3 类加载器作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成这个类的Class对象，作为方法区中类数据的访问入口\n\n类缓存：类加载器加载类时，先按要求查找类，如果某个类被加载到类加载器中，它将维持加载（缓存）一段时间。\n类加载器的类型：\n\n引导类加载器（负责Java核心库）\n扩展类加载器\n系统类加载器\n\npublic class Test05 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//获取系统类的加载器\t\tClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\t\tSystem.out.println(systemClassLoader);\t\t\t\t//获取系统类加载器的父类加载器--&gt;扩展类加载器\t\tClassLoader parent = systemClassLoader.getParent();\t\tSystem.out.println(parent);\t\t\t\t//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）\t\tClassLoader parent1 = parent.getParent();\t\tSystem.out.println(parent1);\t\t\t\t//测试当前类是哪个加载器加载的（系统类加载器）\t\tClassLoader classLoader = Class.forName(&quot;com.zhg.reflection.Test05&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//测试JDK内置的类是谁加载的（根加载器）\t\tclassLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//如何获得系统类加载器可以加载的路径\t\tSystem.out.println(System.getProperty(&quot;java.class.path&quot;));\t\t\t\t//双亲委派机制\t\t\t//java.lang.String--&gt;多重检测，保证安全性\t&#125;&#125;\n\n2.2.4 获取类的结构通过反射获取运行时类的完整结构\nField, Method, Constructor, Superclass, Interface, Annotation…\n//获取类的信息public class Test06 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, NoSuchMethodException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\tPerson person = new Person();\t\tc1 = person.getClass();\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的名字\t\tSystem.out.println(c1.getName()); //获得包名 + 类名\t\tSystem.out.println(c1.getSimpleName()); //获得类名\t\t\t//获得类的属性\t\tField[] fields = c1.getFields(); //只能找到public属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\tfields = c1.getDeclaredFields(); //找到全部的属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\t\t//获取指定属性的值\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\tSystem.out.println(name);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的方法\t\tMethod[] methods = c1.getMethods(); //获得本类及父类的所有public方法\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;正常的：&quot;+method);\t\t&#125;\t\tmethods = c1.getDeclaredMethods(); //获得本类的所有方法（包括private方法）\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;getDeclaredMethods：&quot;+method);\t\t&#125;\t\t//获得指定方法\t\tMethod getName = c1.getMethod(&quot;getName&quot;, null);\t\tMethod setName = c1.getMethod(&quot;setName&quot;, String.class);\t\tSystem.out.println(getName);\t\tSystem.out.println(setName);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得指定的构造器\t\tConstructor[] constructors = c1.getConstructors(); //获得public构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(constructor);\t\t&#125;\t\tconstructors = c1.getDeclaredConstructors(); //获得全部构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(&quot;#&quot;+constructor);\t\t&#125;\t\t//获得指定的构造器\t\tConstructor declaredConstructor = c1.getDeclaredConstructor(String.class);\t\tSystem.out.println(&quot;指定：&quot;+declaredConstructor);\t&#125;&#125;\n\n2.3 实际应用2.3.1 动态创建对象动态创建类的对象：调用Class对象的newInstance()方法\n\n类必须有一个无参构造器\n类的构造器的访问权限需要足够\n\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//通过反射动态的创建对象public class Test07 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;\t\t//构造Class对象\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\t\t\t//构造一个对象\t\tPerson person = (Person) c1.newInstance();  //本质是调用了类的无参构造器\t\tSystem.out.println(person);\t\t\t\t//通过构造器创建对象\t\tConstructor constructor = c1.getDeclaredConstructor(String.class);\t\tPerson person2 = (Person)constructor.newInstance(&quot;XX&quot;);\t\tSystem.out.println(person2);\t\t\t\t//通过反射调用普通方法\t\tPerson person3 = (Person) c1.newInstance();\t\tMethod setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);\t\t//invoke(对象，方法参数)\t\tsetName.invoke(person3, &quot;XXX&quot;);\t\tSystem.out.println(person3.name);\t\tSystem.out.println(&quot;=================&quot;);\t\t//通过反射操作属性\t\tPerson person4 = (Person) c1.newInstance();\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\t//不能直接操作私有属性，需要关闭程序的安全检测，属性或者方法的setAccessible(true)\t\tname.setAccessible(true); //\t\tname.set(person4, &quot;XXXX&quot;);\t\tSystem.out.println(person4.getName());\t\t\t&#125;&#125;\n\nsetAccessible参数值为true则指示反射的对象在使用时取消Java语言访问检查→提高了反射的效率；使得原本无法访问的私有成员也可以访问\n性能分析（调用对象的方法）：普通方式 VS 反射方式 VS 关闭检测后反射\nimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class Test08 &#123;\t//普通方式调用\tpublic static void test01() &#123;\t\tPerson person = new Person();\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tperson.getName();\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;普通方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t//反射方式调用\tpublic static void test02() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t\t//反射方式调用 关闭检测\tpublic static void test03() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\tgetName.setAccessible(true);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;关闭检测后反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\tpublic static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\ttest01();\t\ttest02();\t\ttest03();\t&#125;&#125;\n\n2.3.2 获取泛型信息Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，一旦编译完成，所有和泛型有关的类型全部擦除\n通过反射操作类型：\nimport java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;//通过反射获取泛型public class Test09 &#123;\tpublic void test01(Map&lt;String,Person&gt; map,List&lt;Person&gt; list)&#123;\t\tSystem.out.println(&quot;test01&quot;);\t&#125;\tpublic Map&lt;String,Person&gt;test02()&#123;\t\tSystem.out.println(&quot;test02&quot;);\t\treturn null;\t&#125;\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException &#123;\t\tMethod method = Test09.class.getMethod(&quot;test01&quot;, Map.class,List.class);\t\tType[] genericParameterTypes = method.getGenericParameterTypes();\t\tfor(Type genericParameterType:genericParameterTypes) &#123;\t\t\tSystem.out.println(&quot;#&quot;+genericParameterType);\t\t\tif(genericParameterType instanceof ParameterizedType) &#123;\t\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericParameterType).getActualTypeArguments();\t\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tmethod = Test09.class.getMethod(&quot;test02&quot;, null);\t\tType genericReturnType = method.getGenericReturnType();\t\tif(genericReturnType instanceof ParameterizedType) &#123;\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericReturnType).getActualTypeArguments();\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n2.3.3 获取注解信息ORM(Object Relationship Mapping)：对象关系映射\n\n类和表结构对应\n属性和字段对应\n对象和记录对应\n\n利用注解和反射完成类和表结构的映射关系：\nimport java.lang.annotation.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;//练习反射操作注解public class Test10 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.StudentX&quot;);\t\t\t\t//通过反射获得注解\t\tAnnotation[] annotations = c1.getAnnotations();\t\tfor(Annotation annotation:annotations) &#123;\t\t\tSystem.out.println(annotation);\t\t&#125;\t\t\t\t//获取注解的value值\t\tTableX table = (TableX)c1.getAnnotation(TableX.class);\t\tString value = table.value();\t\tSystem.out.println(value);\t\t\t\t//获取类指定的注解\t\tField f = c1.getDeclaredField(&quot;name&quot;);\t\tFieldX annotation = f.getAnnotation(FieldX.class);\t\tSystem.out.println(annotation.columnName());\t\tSystem.out.println(annotation.type());\t\tSystem.out.println(annotation.length());\t&#125;&#125;@TableX(&quot;db_student&quot;)class StudentX&#123;\t\t@FieldX(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)\tprivate int id;\t@FieldX(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)\tprivate int age;\t@FieldX(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)\tprivate String name;\tpublic StudentX() &#123;\t\tsuper();\t&#125;\tpublic StudentX(int id, int age, String name) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.age = age;\t\tthis.name = name;\t&#125;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\tpublic int getAge() &#123;\t\treturn age;\t&#125;\tpublic void setAge(int age) &#123;\t\tthis.age = age;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Student [id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;\t&#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableX&#123;\tString value();&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldX&#123;\tString columnName();\tString type();\tint length();&#125;","tags":["Java","JavaSE","注解","反射"]},{"title":"多线程详解","url":"/2020/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/","content":"1.1 线程简介多任务→多线程\n进程 VS 线程\n\n程序是指令和数据的有序集合，是一个静态的概念。\n进程是程序的一次执行过程,是一个动态的概念。\n进程中至少有一个线程，线程是CPU调度和执行的基本单位。\n\n1.2 线程创建三种创建方式：\n\n继承Thread类\n实现Runnable接口\n实现Callable接口（了解）\n\n1.2.1 继承Thread类创建线程方式一：继承Thread类→重写run()方法→调用start()启动线程\n//注意，线程开启不一定立即执行，由CPU调度执行public class TestThread1 extends Thread&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//main线程，主线程\t\tTestThread1 testThread1 = new TestThread1();\t\t//调用start()方法开启线程，交替执行\t\ttestThread1.start();\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;\t&#125;\n\n实现多线程同步下载图片\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;public class TestThread2 extends Thread&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2 t1 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2 t2 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2 t3 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\tt1.start();\t\tt2.start();\t\tt3.start();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n1.2.2 实现Runnable接口创建线程方式二：实现Runnable接口→重写run()方法→调用start()启动线程（需要Runnable接口实现类）\npublic class TestThread3 implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//创建runnable接口的实现类对象\t\tTestThread3 testThread3 = new TestThread3();\t\t\t\t//创建线程对象，通过线程对象来开启线程，代理//\t\tThread thread = new Thread(testThread3);//\t\tthread.start();\t\tnew Thread(testThread3).start();\t\t\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;&#125;\n\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;//练习Thread，实现多线程同步下载图片public class TestThread2n implements Runnable&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2n(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader1 webDownloader = new WebDownloader1();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2n t1 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2n t2 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2n t3 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\tnew Thread(t1).start();\t\tnew Thread(t2).start();\t\tnew Thread(t3).start();\t&#125;&#125;//下载器class WebDownloader1&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n小结：\n\n继承Thread类\n子类继承Thread类具备多线程能力\n启动线程：子类对象.start()\n不建议使用：避免OOP单继承局限性\n\n\n实现Runnable接口\n实现接口Runnable具有多线程能力\n启动线程：传入目标对象+Thread对象.start()\n推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用\n\n\n\n多个线程同时操作一个对象，买火车票的例子\n//问题：多个线程操作同一个资源，线程不安全，数据紊乱public class TestThread4 implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\ttry &#123;\t\t\t\tThread.sleep(10);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread4 ticket = new TestThread4();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\n案例：龟兔赛跑\n//模拟龟兔赛跑public class Race implements Runnable&#123;\t//胜利者\tprivate static String winner; \tpublic static void main(String[] args) &#123;\t\tRace race = new Race();\t\tnew Thread(race,&quot;兔子&quot;).start();\t\tnew Thread(race,&quot;乌龟&quot;).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tfor(int i = 0; i &lt;= 100;i++) &#123;\t\t\t//模拟兔子休息\t\t\tif(&quot;兔子&quot;.equals(Thread.currentThread().getName() )&amp;&amp; i%10==5) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(56);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(&quot;乌龟&quot;.equals(Thread.currentThread().getName() )) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(5);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\t//判断比赛是否结束\t\t\tboolean flag = gameOver(i);\t\t\t//如果比赛结束了，就停止程序\t\t\tif(flag) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;);\t\t&#125;\t\t&#125;\t//判断是否完成比赛\tprivate boolean gameOver(int steps) &#123;\t\t//判断是否有胜利者\t\tif(winner!=null) &#123;\t\t\treturn true;\t\t&#125;else &#123;\t\t\tif(steps==100) &#123;\t\t\t\twinner = Thread.currentThread().getName();\t\t\t\tSystem.out.println(&quot;winner is &quot;+winner);\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t\treturn false;\t&#125;&#125;\n\n1.2.3 实现Callable接口创建线程方式三（了解即可）：实现Callable接口（需要返回值类型）→重写call()方法（需要抛出异常）→创建目标对象→创建关闭服务\nimport java.io.File;import java.net.URL;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import org.apache.commons.io.FileUtils;//创建方式三：实现Callable接口/* * Callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 */public class TestCallable implements Callable&lt;Boolean&gt;&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestCallable(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic Boolean call() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t\treturn true;\t&#125;\tpublic static void main(String[] args) throws Exception &#123;\t\tTestCallable t1 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestCallable t2 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestCallable t3 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\t//创建执行服务 \t\tExecutorService ser = Executors.newFixedThreadPool(3);\t\t\t\t//提交执行\t\tFuture&lt;Boolean&gt; r1 = ser.submit(t1);\t\tFuture&lt;Boolean&gt; r2 = ser.submit(t2);\t\tFuture&lt;Boolean&gt; r3 = ser.submit(t3);\t\t\t\t//获取结果\t\tboolean rs1 = r1.get();\t\tboolean rs2 = r2.get();\t\tboolean rs3 = r3.get();\t\t\t\tSystem.out.println(rs1);\t\tSystem.out.println(rs2);\t\tSystem.out.println(rs3);\t\t//关闭服务\t\tser.shutdown();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\nLamda表达式语法：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }\n作用：简化代码，避免匿名内部类定义过多\nFunction Interface（函数式接口）：只包含唯一一个抽象方法\n可以通过lamda表达式来创建函数式接口的对象\n推导lambda表达式\npublic class TestLambda1 &#123;\t//3.静态内部类\tstatic class Like2 implements ILike&#123;\t\t@Override\t\tpublic void lambda() &#123;\t\t\tSystem.out.println(&quot;I like lambda2&quot;);\t\t&#125;\t\t\t&#125;\t\tpublic static void main(String[] args) &#123;\t\tILike like = new Like();\t\tlike.lambda();\t\tlike = new Like2();\t\tlike.lambda();\t\t\t\t//4.局部内部类\t\tclass Like3 implements ILike&#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda3&quot;);\t\t\t&#125;\t\t\t\t&#125;\t\tlike = new Like3();\t\tlike.lambda();\t\t\t\t//5.匿名内部类，没有类的名称，必须借助接口或者父类\t\tlike = new ILike() &#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda4&quot;);\t\t\t&#125;\t\t&#125;;\t\tlike.lambda();\t\t\t\t//6.用lambda简化\t\tlike = () -&gt; &#123;\t\t\tSystem.out.println(&quot;I like lambda5&quot;);\t\t&#125;;\t\tlike.lambda();\t&#125;&#125;//1.定义一个函数式接口interface ILike&#123;\tvoid lambda();&#125;//2.实现类class Like implements ILike&#123;\t@Override\tpublic void lambda() &#123;\t\tSystem.out.println(&quot;I like lambda&quot;);\t&#125;\t&#125;\n\n简化lambda表达式：1.省略参数类型 2.省略括号\n静态代理示例（婚庆公司）\npublic class StaticProxy &#123;\tpublic static void main(String[] args) &#123;        You you = new You(); \t\tyou.HappyMarry();        //\t\tnew Thread(()-&gt;System.out.println(&quot;我爱你&quot;)).start();//\t\tnew WeddingCompany(new You()).HappyMarry();\t\t//代理\t\tWeddingCompany weddingCompany = new WeddingCompany(new You());\t\tweddingCompany.HappyMarry();\t&#125;&#125;interface Marry&#123;\tvoid HappyMarry();&#125;//真实角色class You implements Marry&#123;\t@Override\tpublic void HappyMarry() &#123;\t\tSystem.out.println(&quot;结婚了，开心&quot;);\t\t\t&#125;&#125;//代理角色class WeddingCompany implements Marry&#123;\tprivate Marry target;\t\tpublic WeddingCompany(Marry target) &#123;\t\tthis.target = target;\t&#125;\t@Override\tpublic void HappyMarry() &#123;\t\tbefore();\t\tthis.target.HappyMarry(); //真实对象\t\tafter();\t&#125;\tprivate void after() &#123;\t\tSystem.out.println(&quot;结婚之后，收尾款&quot;);\t\t\t&#125;\tprivate void before() &#123;\t\tSystem.out.println(&quot;结婚之前，布置现场&quot;);\t\t\t&#125;\t&#125;\n\n静态代理模式总结：\n\n真实对象和代理对象都要实现同一个接口\n代理对象代理真实对象\n\n好处：\n\n代理对象可以做很多真实对象做不了的事情\n真实对象专注做自己的事情\n\n1.3 线程状态1.3.1 五大状态\n\n1.3.2 线程停止\n不推荐使用JDK提供的stop()、destroy()方法【已废弃】\n推荐线程自己停下来（建议使用一标志位进行终止变量）\n\n//测试stop//1.建议线程正常停止--&gt;利用次数，不建议死循环//2.建议使用标志位//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法public class TestStop implements Runnable&#123;\tprivate boolean flag = true;\tpublic static void main(String[] args) &#123;\t\tTestStop testStop = new TestStop();\t\tnew Thread(testStop).start();\t\tfor(int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t\tif(i == 900) &#123;\t\t\t\t//调用stop()方法切换标志位，让线程停止\t\t\t\ttestStop.stop();\t\t\t\tSystem.out.println(&quot;线程停止&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tint i = 0;\t\twhile(flag) &#123;\t\t\tSystem.out.println(&quot;run ... Thread&quot;+i++);\t\t&#125;\t\t&#125;\tpublic void stop() &#123;\t\tthis.flag = false;\t&#125;&#125;\n\n1.3.3 线程休眠sleep(毫秒)→就绪\n每个对象有个锁，sleep不会释放锁\n//模拟网络延时：放大问题的发生性public class TestSleep implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t//模拟延时\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestSleep ticket = new TestSleep();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\nimport java.text.SimpleDateFormat;import java.util.Date;public class TestSleep2&#123;\tpublic static void main(String[] args) &#123;\t\t//模拟倒计时\t\ttry &#123;\t\t\ttenDown();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t//打印当前系统时间\t\tDate startTime = new Date(System.currentTimeMillis());\t\twhile(true) &#123;\t\t\ttry &#123;\t\t\t\tSystem.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\t\t\t\tThread.sleep(1000);\t\t\t\tstartTime = new Date(System.currentTimeMillis()); //更新当前时间\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t&#125;\tpublic static void tenDown() throws InterruptedException &#123;\t\tint num = 3;\t\twhile(true) &#123;\t\t\tThread.sleep(1000);\t\t\tSystem.out.println(num--);\t\t\tif(num&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t&#125;&#125;\n\n1.3.4 线程礼让Yield让当前线程暂停但不阻塞，转为就绪状态\n礼让不一定成功\n//测试礼让线程，礼让不一定成功public class TestYield &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tMyYield myYield = new MyYield();\t\tnew Thread(myYield,&quot;a&quot;).start();\t\tnew Thread(myYield,&quot;b&quot;).start();\t&#125;&#125;class MyYield implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);\t\tThread.yield(); //礼让\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);\t&#125;\t&#125;\n\n1.3.5 线程强制执行Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞（可以看作是插队）\n//测试join方法public class TestJoin implements Runnable&#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\t//启动我们的线程\t\tTestJoin testJoin = new TestJoin();\t\tThread thread = new Thread(testJoin);\t\tthread.start();\t\tfor (int i = 0; i &lt; 500; i++) &#123;\t\t\tif(i==200) &#123;\t\t\t\tthread.join();//插队\t\t\t&#125;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;线程vip来了&quot;+i);\t\t&#125;\t\t&#125;&#125;\n\n1.3.6 线程优先级优先高的不一定先执行，默认是5\n//测试线程的优先级public class TestPriority&#123;\tpublic static void main(String[] args) &#123;\t\t//主线程默认优先级\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\tMyPriority myPriority = new MyPriority();\t\tThread t1 = new Thread(myPriority);\t\tThread t2 = new Thread(myPriority);\t\tThread t3 = new Thread(myPriority);\t\tThread t4 = new Thread(myPriority);\t\t//先设置优先级，再启动\t\tt1.start();\t\tt2.setPriority(1);\t\tt2.start();\t\tt3.setPriority(4);\t\tt3.start();\t\tt4.setPriority(Thread.MAX_PRIORITY); //MAX_PRIORITY=10\t\tt4.start();\t&#125;&#125;class MyPriority implements Runnable&#123;\t@Override\tpublic void run() &#123;\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\t\t&#125;\t&#125;\n\n1.3.7 守护（daemon）线程线程分为用户线程和守护线程\n虚拟机必须确保用户线程（如，后台记录操作日志，监控内存，垃圾回收等待）执行完毕，但不用等待守护线程执行完毕\n//测试守护线程//上帝守护你public class TestDaemon &#123;\tpublic static void main(String[] args) &#123;\t\tGod god = new God();\t\tYou you = new You();\t\tThread thread = new Thread(god);\t\tthread.setDaemon(true); //默认是false表示是用户线程，正常的线程都是用户线程\t\tthread.start(); //守护线程启动\t\tnew Thread(you).start(); //用户线程启动\t&#125;&#125;//上帝class God implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tSystem.out.println(&quot;上帝保佑着你&quot;);\t\t&#125;\t&#125;\t&#125;//你class You implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 36500; i++) &#123;\t\t\tSystem.out.println(&quot;开心活着&quot;);\t\t&#125;\t\tSystem.out.println(&quot;====Good bye!====&quot;);\t&#125;\t&#125;\n\n1.4 线程同步多个线程操作同一资源（并发）\n线程同步是一种等待机制，多个需要同时访问同一对象的线程进图该对象的等待池形成队列，等待前面线程使用完毕，下一线程再使用\n形成条件：队列+锁（synchronized）\n1.4.1 同步方法及同步块三个不安全案例1.不安全的买票\n//不安全的买票(线程不安全）public class UnsafeBuyTicket &#123;\tpublic static void main(String[] args) &#123;\t\tBuyTicket station = new BuyTicket();\t\tnew Thread(station,&quot;苦逼的我&quot;).start();\t\tnew Thread(station,&quot;牛逼的你们&quot;).start();\t\tnew Thread(station,&quot;可恶的黄牛党&quot;).start();\t&#125;\t&#125;class BuyTicket implements Runnable&#123;\t\t//票\tprivate int ticketNum = 10;\tboolean flag = true; //外部停止方式\t@Override\tpublic void run() &#123;\t\t//买票\t\twhile(flag) &#123;\t\t\tbuy();\t\t&#125;\t&#125;\tprivate void buy() &#123;\t\tif(ticketNum&lt;=0) &#123;\t\t\tflag = false;\t\t\treturn;\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//买票        System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--);\t&#125;\t&#125;\n\n2.不安全的取钱\n//不安全的取钱（两个人）public class UnsafeBank &#123;\tpublic static void main(String[] args) &#123;\t\tAccount account = new Account(100,&quot;结婚基金&quot;);\t\tDrawing you = new Drawing(account,50,&quot;你&quot;);\t\tDrawing GF = new Drawing(account,100,&quot;女朋友&quot;);\t\tyou.start();\t\tGF.start();\t&#125;&#125;//账户class Account&#123;\tint money; //余额\tString name; //卡名\tpublic Account(int money, String name) &#123;\t\tsuper();\t\tthis.money = money;\t\tthis.name = name;\t&#125;&#125;//银行：模拟取款class Drawing extends Thread&#123;\tAccount account;\t//取了多少钱\tint drawingMoney;\t//现在手里有多少钱\tint nowMoney;\tpublic Drawing(Account account,int drawingMoney,String name) &#123;\t\tsuper(name);\t\tthis.account = account;\t\tthis.drawingMoney = drawingMoney;\t&#125;\t//取钱\t@Override\tpublic void run() &#123;\t\t//判断有没有钱\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\treturn;\t\t&#125;\t\t//放大问题的发生性\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//卡内余额 = 余额 - 取的钱\t\taccount.money = account.money - drawingMoney;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;&#125;\n\n3.不安全的集合\n//线程不安全的集合//添加到同一位置被覆盖public class UnsafeList &#123;\tpublic static void main(String[] args) &#123;\t\tList&lt;String&gt; list = new ArrayList&lt;String&gt;();\t\tfor (int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\nsynchronized同步方法：public synchronized void method(int args) { }\nsynchronized方法控制对“对象”的访问，每个对象对象对应一把锁，每个synchronized方法都必须获得调用该方法的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行\n同步块：synchronized(Obj) { }\nObj称为同步监视器\n\nObj可以是任何对象，但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this\n\npublic void run() &#123;\t\t//锁的对象就是变化的量，需要增删改的对象\t\tsynchronized (account) &#123;\t\t\t//判断有没有钱\t\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\t\treturn;\t\t\t&#125;\t\t\t//放大问题的发生性\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t//卡内余额 = 余额 - 取的钱\t\t\taccount.money = account.money - drawingMoney;\t\t&#125;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;\n\nCopyOnWriteArrayListJUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。Callable接口也在JUC中。\nimport java.util.concurrent.CopyOnWriteArrayList;//测试JUC安全类型的集合public class TestJUC &#123;\tpublic static void main(String[] args) &#123;\t\tCopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();\t\tfor(int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(3000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\n1.4.2 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“的问题\n//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class DeadLock &#123;\tpublic static void main(String[] args) &#123;\t\tMakeup g1 = new Makeup(0,&quot;灰姑娘&quot;);\t\tMakeup g2 = new Makeup(1,&quot;白雪公主&quot;);\t\tg1.start();\t\tg2.start();\t&#125;&#125;//口红class Lipstick&#123;\t&#125;//镜子class Mirror&#123;\t&#125;class Makeup extends Thread&#123;\t//需要的资源只有一份，用static来保证只有一份\tstatic Lipstick lipstick = new Lipstick();\tstatic Mirror mirror = new Mirror();\t\tint choice; //选择\tString girlName; //选择化妆品的人\t\tMakeup(int choice,String girlName)&#123;\t\tthis.choice = choice;\t\tthis.girlName = girlName;\t&#125;\t@Override\tpublic void run() &#123;\t\t//化妆\t\ttry &#123;\t\t\tmakeup();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t\t//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t\t\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t\t\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n锁中锁（多个对象互相嵌套的锁）使多个线程互相抱着对方需要的资源，然后形成僵持\n解决方法：锁分开写，不要同时占有多个资源\n//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t&#125;\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125;\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t&#125;\n\n产生死锁的四个必要条件：\n\n互斥条件\n请求与保持条件\n不剥夺条件\n循环等待条件\n\n1.4.3 Lock锁从JDK 5.0开始，Java提供了更强大的线程同步机制——显式定义同步锁对象来实现同步。同步锁使用Lock对象充当，Lock锁也包含在JUC内\nReentrantLock（可重入锁）类实现了Lock，可以显式加锁、释放锁\n使用格式：\nLock lock=new ReentrantLock();lock.lock();try&#123;    //处理任务&#125;catch(Exception ex)&#123;     &#125;finally&#123;    lock.unlock();   //释放锁&#125;\n\n测试Lock类（买票）：\nimport java.util.concurrent.locks.ReentrantLock;//测试Lock类public class TestLock &#123;\tpublic static void main(String[] args) &#123;\t\tTestLock2 testLock2 = new TestLock2(); \t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t&#125;&#125;class TestLock2 implements Runnable&#123;\tint ticketNum = 10;\t\t//定义Lock锁\tprivate final ReentrantLock lock = new ReentrantLock();\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tlock.lock();//加锁\t\t\ttry &#123;\t\t\t\tif(ticketNum &gt; 0) &#123;\t\t\t\t\ttry &#123;\t\t\t\t\t\tThread.sleep(1000);\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t\t\t\tSystem.out.println(ticketNum--);\t\t\t\t&#125;else &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;finally &#123;\t\t\t\t//解锁\t\t\t\tlock.unlock();\t\t\t&#125;\t\t\t\t&#125;\t&#125;&#125;\n\nsynchronized与Lock对比\n\nLock是显式锁（手动开启和关闭锁），synchronized是隐式锁，自动释放\n使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）\n\n1.4.4 线程通信线程通信方法：\n\n注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常\n生产者消费者问题解决方法：\n\n利用缓冲区解决：管程法\n//测试生产者消费者模型--&gt;利用缓冲区解决：管程法//生产者，消费者，产品，缓冲区public class TestPC &#123;\tpublic static void main(String[] args) &#123;\t\tSynContainer container = new SynContainer();\t\t\t\tnew Producer(container).start();\t\tnew Consumer(container).start();\t&#125;&#125;//生产者class Producer extends Thread&#123;\tSynContainer container;\tpublic Producer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t\t//生产\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\tcontainer.push(new Chicken(i));\t\t\tSystem.out.println(&quot;生产了第&quot;+i+&quot;只鸡&quot;);\t\t&#125;\t&#125;&#125;//消费者class Consumer extends Thread&#123;\tSynContainer container;\tpublic Consumer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t//消费\t\t@Override\t\tpublic void run() &#123;\t\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\t\tSystem.out.println(&quot;消费了第&quot;+container.pop().id+&quot;只鸡&quot;);\t\t\t&#125;\t\t\t\t&#125;&#125;//产品class Chicken&#123;\tint id; //产品编号\tpublic Chicken(int id) &#123;\t\tthis.id = id;\t&#125;\t&#125;//缓冲区class SynContainer&#123;\t//需要一个容器大小\tChicken[] chickens = new Chicken[10];\t//容器计数器\tint count = 0;\t\t//生产者放入产品\tpublic synchronized void push(Chicken chicken) &#123;\t\t//如果容器满了，就需要等待消费者消费\t\tif(count == chickens.length) &#123;\t\t\t//通知消费者消费，生产等待\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果没有满，我们就需要丢入产品\t\tchickens[count] = chicken;\t\tcount++;\t\t\t\t//可以通知消费者消费了\t\tthis.notifyAll();\t&#125;\t//消费者消费产品\tpublic synchronized Chicken pop() &#123;\t\t//判断能否消费\t\tif(count==0) &#123;\t\t\t//等待生产者生产\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果可以消费\t\tcount--;\t\tChicken chicken = chickens[count];\t\t\t//吃完了，通知生产者生产\t\tthis.notifyAll();\t\treturn chicken;\t\t\t&#125;&#125;\n\n利用标志位解决：信号灯法\npackage com.zhg.thread;//测试生产者消费者模型2--&gt;利用标志位解决：信号灯法public class TestPC2 &#123;\tpublic static void main(String[] args) &#123;\t\tTV tv = new TV();\t\tnew Player(tv).start();\t\tnew Watcher(tv).start();\t&#125;&#125;//生产者--&gt;演员class Player extends Thread&#123;\tTV tv;\tpublic Player(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\tif(i%2==0) &#123;\t\t\t\tthis.tv.play(&quot;快乐大本营&quot;);\t\t\t&#125;else &#123;\t\t\t\tthis.tv.play(&quot;广告&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;//消费者--&gt;观众class Watcher extends Thread&#123;\tTV tv;\tpublic Watcher(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\ttv.watch();\t\t&#125;\t&#125;&#125;//产品--&gt;节目class TV&#123;\t\t//演员表演，观众等待 T\t//观众观看，演员等待 F\tString voice;//表演的节目\tboolean flag = true;\t\t//表演\tpublic synchronized void play(String voice) &#123;\t\t\t\tif(!flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(&quot;演员表演了：&quot;+voice);\t\t//通知观众观看\t\tthis.notifyAll(); //通知唤醒\t\tthis.voice = voice;\t\tthis.flag = !this.flag;\t&#125;\t\t//观看\tpublic synchronized void watch() &#123;\t\tif(flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;观众观看了：&quot;+voice);\t\t//通知演员表演\t\tthis.notifyAll();\t\tthis.flag = !this.flag;\t&#125;&#125;\n\n\n\n线程池背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。\n好处：\n\n提高响应速度\n降低资源消耗\n便于线程管理\n\nJDK 5.0起提供了线程池相关API：ExecutorService和Executors\n\nExecutorService：真正的线程池接口。\n\nExecutor：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。\n\n\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//测试线程池public class TestPool &#123;\tpublic static void main(String[] args) &#123;\t\t//1.创建服务，创建线程池\t\t//newFixedThreadPool 参数为线程池大小\t\tExecutorService service = Executors.newFixedThreadPool(10);\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\t//2.关闭连接\t\tservice.shutdown();\t&#125;&#125;class MyThread implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tSystem.out.println(Thread.currentThread().getName());\t\t\t&#125;&#125;","tags":["Java","JavaSE","多线程"]},{"title":"LeetCode 140.单词拆分II","url":"/2020/11/01/LeetCode140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II/","content":"题目描述：\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n说明：\n\n分隔时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n\n示例1：\n输入:s = “catsanddog”wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]输出:[  “cats and dog”,  “cat sand dog”]\n示例2：\n输入:s = “pineapplepenapple”wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]输出:[  “pine apple pen apple”,  “pineapple pen apple”,  “pine applepen apple”]解释: 可以重复使用字典中的单词。\n示例3：\n输入:s = “catsandog”wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出:[]\n概述：动态规划求是否有解、回溯算法求所有具体解。题目问可不可以拆分，没有问具体怎么拆分，通常考虑使用动态规划解决；题目如果问一个问题的所有的具体解，一般而言使用回溯算法（DFS）完成。\n动态规划求是否有解：\nimport java.util.HashSet;import java.util.List;import java.util.Set;public class Solution &#123;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);        int len = s.length();        // 状态定义：以 s[i] 结尾的子字符串是否符合题意        boolean[] dp = new boolean[len];        for (int right = 0; right &lt; len; right++) &#123;            // 分类讨论 1：不拆分，substring 右端点不包含，所以是 right + 1            if (wordSet.contains(s.substring(0, right + 1))) &#123;                dp[right] = true;                continue;            &#125;            // 分类讨论 2：拆分            for (int left = right - 1; left &gt;= 0; left--) &#123;                if (wordSet.contains(s.substring(left + 1, right + 1)) &amp;&amp; dp[left]) &#123;                    dp[right] = true;                    // 这个 break 很重要，一旦得到 dp[right] = True ，循环不必再继续                    break;                &#125;            &#125;        &#125;        return dp[len - 1];    &#125;&#125;\n\n回溯算法求所有具体解：\n回溯的时间复杂度在最坏情况下高达 O(n^n)。时间复杂度高的原因是存在大量重复计算，可以通过动态规划+深度优先搜索或者记忆化搜索的方式降低时间复杂度。\n1.动态规划+深度优先搜索\nimport java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.HashSet;import java.util.List;import java.util.Set;public class Solution &#123;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        // 为了快速判断一个单词是否在单词集合中，需要将它们加入哈希表        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);        int len = s.length();        // 第 1 步：动态规划计算是否有解        // dp[i] 表示「长度」为 i 的 s 前缀子串可以拆分成 wordDict 中的单词        // 长度包括 0 ，因此状态数组的长度为 len + 1        boolean[] dp = new boolean[len + 1];        // 0 这个值需要被后面的状态值参考，如果一个单词正好在 wordDict 中，dp[0] 设置成 true 是合理的        dp[0] = true;        for (int right = 1; right &lt;= len; right++) &#123;            // 如果单词集合中的单词长度都不长，从后向前遍历是更快的            for (int left = right - 1; left &gt;= 0; left--) &#123;                // substring 不截取 s[right]，dp[left] 的结果不包含 s[left]                if (wordSet.contains(s.substring(left, right)) &amp;&amp; dp[left]) &#123;                    dp[right] = true;                    // 这个 break 很重要，一旦得到 dp[right] = True ，不必再计算下去                    break;                &#125;            &#125;        &#125;        // 第 2 步：回溯算法搜索所有符合条件的解        List&lt;String&gt; res = new ArrayList&lt;&gt;();        if (dp[len]) &#123;            Deque&lt;String&gt; path = new ArrayDeque&lt;&gt;();            dfs(s, len, wordSet, dp, path, res);            return res;        &#125;        return res;    &#125;    private void dfs(String s, int len, Set&lt;String&gt; wordSet, boolean[] dp, Deque&lt;String&gt; path, List&lt;String&gt; res) &#123;        if (len == 0) &#123;            res.add(String.join(&quot; &quot;,path));            return;        &#125;        // 可以拆分的左边界从 len - 1 依次枚举到 0        for (int i = len - 1; i &gt;= 0; i--) &#123;            String suffix = s.substring(i, len);            if (wordSet.contains(suffix) &amp;&amp; dp[i]) &#123;                path.addFirst(suffix);                dfs(s, i, wordSet, dp, path, res);                path.removeFirst();            &#125;        &#125;    &#125;&#125;\n\n2.记忆化搜索\nclass Solution &#123;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map = new HashMap&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;();        List&lt;List&lt;String&gt;&gt; wordBreaks = backtrack(s, s.length(), new HashSet&lt;String&gt;(wordDict), 0, map);        List&lt;String&gt; breakList = new LinkedList&lt;String&gt;();        for (List&lt;String&gt; wordBreak : wordBreaks) &#123;            breakList.add(String.join(&quot; &quot;, wordBreak));        &#125;        return breakList;    &#125;    public List&lt;List&lt;String&gt;&gt; backtrack(String s, int length, Set&lt;String&gt; wordSet, int index, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map) &#123;        if (!map.containsKey(index)) &#123;            List&lt;List&lt;String&gt;&gt; wordBreaks = new LinkedList&lt;List&lt;String&gt;&gt;();            if (index == length) &#123;                wordBreaks.add(new LinkedList&lt;String&gt;());            &#125;            for (int i = index + 1; i &lt;= length; i++) &#123;                String word = s.substring(index, i);                if (wordSet.contains(word)) &#123;                    List&lt;List&lt;String&gt;&gt; nextWordBreaks = backtrack(s, length, wordSet, i, map);                    for (List&lt;String&gt; nextWordBreak : nextWordBreaks) &#123;                        LinkedList&lt;String&gt; wordBreak = new LinkedList&lt;String&gt;(nextWordBreak);                        wordBreak.offerFirst(word);                        wordBreaks.add(wordBreak);                    &#125;                &#125;            &#125;            map.put(index, wordBreaks);        &#125;        return map.get(index);    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/word-break-ii\n","tags":["算法","LeetCode","DFS","记忆化搜索","动态规划"]},{"title":"JavaWeb入门","url":"/2020/11/03/JavaWeb%E5%85%A5%E9%97%A8/","content":"1 环境配置1.1 TomcatTomcat服务器目录\n\nsever.xml可以配置启动的端口号，配置主机的名称\n&lt;!--配置启动的端口号--&gt;&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!--配置主机的名称--&gt;&lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;&gt;\n\n默认端口号：\ntomcat：8080\nmysql：3306\nhttp：80\nhttps：443\n1.2 MavenMaven项目架构管理工具，自动导入和配置jar包\nMaven核心思想：约定大于配置\nMaven会规定如何编写java代码\n镜像：mirrors\n&lt;!--阿里云镜像--&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;\n\n建立一个本地仓库 localRepository\n&lt;localRepository&gt;C:\\apache-maven-3.6.3\\maven-repo&lt;/localRepository&gt;\n\n在IDEA中使用Maven\n\n\n\nMaven项目目录\n\nMaven Web应用项目目录\n\n\npom.xml是maven项目的核心文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Maven版本和头文件--&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--一开始配置的GAV--&gt;  &lt;groupId&gt;com.zhg&lt;/groupId&gt;  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;&lt;!--package：项目打包的方式jar：Java应用war：JavaWeb应用--&gt;  &lt;name&gt;javaweb-01-maven Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#x27;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;&lt;!--配置--&gt;  &lt;properties&gt;    &lt;!--项目的默认构建编码--&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;!--编码版本--&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;!--项目依赖--&gt;  &lt;dependencies&gt;    &lt;!--具体依赖的jar包配置文件--&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;!--项目构建--&gt;  &lt;build&gt;    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.8.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.22.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;\n\nMaven的高级之处在于，它会帮你导入jar包依赖的jar包\n配置resouces节点防止资源导出失败\n&lt;build&gt;    .......      &lt;resources&gt;        &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.properties&lt;/include&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;    ......&lt;/build&gt;\n\nMaven的使用\n地址：https://mvnrepository.com/\n2 HTTP两个时代：\n\nhttp1.0：\nHTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n\nhttp2.0\nHTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源\n\n\n网站访问过程：\n\n输入域名，回车；\n检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有输入域名的映射\n有：直接返回并访问对应的ip地址\n没有：去DNS服务器找，找到就返回并访问\n\n\n\nHTTP请求：\n访问百度请求：\nRequest URL: https://www.baidu.com/ Request Method: GETStatus Code: 200 OKRemote Address: 36.152.44.95:443Accept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7Cache-Control: max-age=0Connection: keep-alive\n\n请求行：请求方式（GET, POST, HEAD, DELETE, PUT, TRACT…）\nRequest URL: https://www.baidu.com/ Request Method: GET\n\n消息头：\nAccept: text/html // 支持的数据类型Accept-Encoding: gzip, deflate, br // 支持的编码格式Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7 // 语言环境Cache-Control: max-age=0 // 缓存控制Connection: keep-alive //保持连接HOST...\n\n\nHTTP响应：\n访问百度响应：\nRequest URL: https://www.baidu.com/ Request Method: GETStatus Code: 200 OKRemote Address: 36.152.44.95:443Cache-Control: privateConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8\n\n响应体：\nAccept: text/html // 支持的数据类型Accept-Encoding: gzip, deflate, br // 支持的编码格式Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7 // 语言环境Cache-Control: max-age=0 // 缓存控制Connection: keep-alive //保持连接HOST...Refresh...Location...\n\n响应状态码：\n200 请求响应成功\n3** 请求重定向\n404 找不到资源\n5** 服务器代码错误 502：网关错误\n3 ServletServlet程序开发步骤：\n\n编写一个类，实现Servlet接口\n把开发好的Java类部署到Web服务器中\n\n用IDEA开发Servlet程序步骤：\n\n构建一个普通的Maven项目，删掉里面的src目录，之后就在项目里创建module，这个空工程就是Maven的主工程\n\n创建子模块（Maven Web应用）\n父项目pom.xml中会有\n&lt;modules&gt;        &lt;module&gt;servlet-01&lt;/module&gt;&lt;/modules&gt;\n\n子项目pom.xml中会有\n&lt;parent&gt;    &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;    &lt;groupId&gt;com.zhg&lt;/groupId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;\n\nMaven环境优化（更新web.xml，创建java和resources目录）\n\n编写Servlet程序\n\n编写普通类\n实现Servlet接口，这里直接继承HttpServlet\n\n\n\nServlet接口→GenericServlet→HttpServlet→自己写的Servlet类\n\n编写Servlet映射\n\n配置Tomcat\n\n\n一个Servlet可以映射到多个路径\n默认请求路径\n&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;error&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n映射路径可以自定义后缀（*.do）\n注意：*前不能加路径！\n具体指定的映射路径优先级更高\n3.1 ServletContextweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用\n\n共享数据\n//servlet1设置共享数据ServletContext context = this.getServletContext();String username = &quot;XXX&quot;;context.setAttribute(&quot;username&quot;,username);//servlet2读取共享数据ServletContext context = this.getServletContext();String username = (String) context.getAttribute(&quot;username&quot;);\n\n获取初始化参数\n&lt;context-param&gt;    &lt;param-name&gt;url&lt;/param-name&gt;    &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;  &lt;/context-param&gt;\n\nServletContext context = this.getServletContext();String url = context.getInitParameter(&quot;url&quot;);\n\n请求转发\nServletContext context = this.getServletContext();context.getRequestDispatcher(&quot;/xx&quot;).forward(req,resp);\n\n读取资源文件\nServletContext context = this.getServletContext();InputStream is = context.getResourceAsStream(&quot;/WEB-  INF/classes/db.properties&quot;);Properties prop = new Properties();prop.load(is);String user = prop.getProperty(&quot;username&quot;);\n\n\n\n3.2 ServletResponse\n发送数据\n\npublic ServletOutputStream getOutputStream() throws IOException;public PrintWriter getWriter() throws IOException;\n\n\n发送响应头\n\npublic void setCharacterEncoding(String charset);public void setContentLength(int len);public void setContentLengthLong(long len);public void setContentType(String type);public void setDateHeader(String name, long date);public void addDateHeader(String name, long date);public void setHeader(String name, String value);public void addHeader(String name, String value);public void setIntHeader(String name, int value);public void addIntHeader(String name, int value);\n\n\n响应状态码\n\n/**     * Status code (100) indicating the client can continue.     */    public static final int SC_CONTINUE = 100;    /**     * Status code (101) indicating the server is switching protocols     * according to Upgrade header.     */    public static final int SC_SWITCHING_PROTOCOLS = 101;    /**     * Status code (200) indicating the request succeeded normally.     */    public static final int SC_OK = 200;    /**     * Status code (201) indicating the request succeeded and created     * a new resource on the server.     */    public static final int SC_CREATED = 201;    /**     * Status code (202) indicating that a request was accepted for     * processing, but was not completed.     */    public static final int SC_ACCEPTED = 202;    /**     * Status code (203) indicating that the meta information presented     * by the client did not originate from the server.     */    public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;    /**     * Status code (204) indicating that the request succeeded but that     * there was no new information to return.     */    public static final int SC_NO_CONTENT = 204;    /**     * Status code (205) indicating that the agent &lt;em&gt;SHOULD&lt;/em&gt; reset     * the document view which caused the request to be sent.     */    public static final int SC_RESET_CONTENT = 205;    /**     * Status code (206) indicating that the server has fulfilled     * the partial GET request for the resource.     */    public static final int SC_PARTIAL_CONTENT = 206;    /**     * Status code (300) indicating that the requested resource     * corresponds to any one of a set of representations, each with     * its own specific location.     */    public static final int SC_MULTIPLE_CHOICES = 300;    /**     * Status code (301) indicating that the resource has permanently     * moved to a new location, and that future references should use a     * new URI with their requests.     */    public static final int SC_MOVED_PERMANENTLY = 301;    /**     * Status code (302) indicating that the resource has temporarily     * moved to another location, but that future references should     * still use the original URI to access the resource.     *     * This definition is being retained for backwards compatibility.     * SC_FOUND is now the preferred definition.     */    public static final int SC_MOVED_TEMPORARILY = 302;    /**    * Status code (302) indicating that the resource reside    * temporarily under a different URI. Since the redirection might    * be altered on occasion, the client should continue to use the    * Request-URI for future requests.(HTTP/1.1) To represent the    * status code (302), it is recommended to use this variable.    */    public static final int SC_FOUND = 302;    /**     * Status code (303) indicating that the response to the request     * can be found under a different URI.     */    public static final int SC_SEE_OTHER = 303;    /**     * Status code (304) indicating that a conditional GET operation     * found that the resource was available and not modified.     */    public static final int SC_NOT_MODIFIED = 304;    /**     * Status code (305) indicating that the requested resource     * &lt;em&gt;MUST&lt;/em&gt; be accessed through the proxy given by the     * &lt;code&gt;&lt;em&gt;Location&lt;/em&gt;&lt;/code&gt; field.     */    public static final int SC_USE_PROXY = 305;     /**     * Status code (307) indicating that the requested resource      * resides temporarily under a different URI. The temporary URI     * &lt;em&gt;SHOULD&lt;/em&gt; be given by the &lt;code&gt;&lt;em&gt;Location&lt;/em&gt;&lt;/code&gt;      * field in the response.     */    public static final int SC_TEMPORARY_REDIRECT = 307;    /**     * Status code (400) indicating the request sent by the client was     * syntactically incorrect.     */    public static final int SC_BAD_REQUEST = 400;    /**     * Status code (401) indicating that the request requires HTTP     * authentication.     */    public static final int SC_UNAUTHORIZED = 401;    /**     * Status code (402) reserved for future use.     */    public static final int SC_PAYMENT_REQUIRED = 402;    /**     * Status code (403) indicating the server understood the request     * but refused to fulfill it.     */    public static final int SC_FORBIDDEN = 403;    /**     * Status code (404) indicating that the requested resource is not     * available.     */    public static final int SC_NOT_FOUND = 404;    /**     * Status code (405) indicating that the method specified in the     * &lt;code&gt;&lt;em&gt;Request-Line&lt;/em&gt;&lt;/code&gt; is not allowed for the resource     * identified by the &lt;code&gt;&lt;em&gt;Request-URI&lt;/em&gt;&lt;/code&gt;.     */    public static final int SC_METHOD_NOT_ALLOWED = 405;    /**     * Status code (406) indicating that the resource identified by the     * request is only capable of generating response entities which have     * content characteristics not acceptable according to the accept     * headers sent in the request.     */    public static final int SC_NOT_ACCEPTABLE = 406;    /**     * Status code (407) indicating that the client &lt;em&gt;MUST&lt;/em&gt; first     * authenticate itself with the proxy.     */    public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;    /**     * Status code (408) indicating that the client did not produce a     * request within the time that the server was prepared to wait.     */    public static final int SC_REQUEST_TIMEOUT = 408;    /**     * Status code (409) indicating that the request could not be     * completed due to a conflict with the current state of the     * resource.     */    public static final int SC_CONFLICT = 409;    /**     * Status code (410) indicating that the resource is no longer     * available at the server and no forwarding address is known.     * This condition &lt;em&gt;SHOULD&lt;/em&gt; be considered permanent.     */    public static final int SC_GONE = 410;    /**     * Status code (411) indicating that the request cannot be handled     * without a defined &lt;code&gt;&lt;em&gt;Content-Length&lt;/em&gt;&lt;/code&gt;.     */    public static final int SC_LENGTH_REQUIRED = 411;    /**     * Status code (412) indicating that the precondition given in one     * or more of the request-header fields evaluated to false when it     * was tested on the server.     */    public static final int SC_PRECONDITION_FAILED = 412;    /**     * Status code (413) indicating that the server is refusing to process     * the request because the request entity is larger than the server is     * willing or able to process.     */    public static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;    /**     * Status code (414) indicating that the server is refusing to service     * the request because the &lt;code&gt;&lt;em&gt;Request-URI&lt;/em&gt;&lt;/code&gt; is longer     * than the server is willing to interpret.     */    public static final int SC_REQUEST_URI_TOO_LONG = 414;    /**     * Status code (415) indicating that the server is refusing to service     * the request because the entity of the request is in a format not     * supported by the requested resource for the requested method.     */    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;    /**     * Status code (416) indicating that the server cannot serve the     * requested byte range.     */    public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;    /**     * Status code (417) indicating that the server could not meet the     * expectation given in the Expect request header.     */    public static final int SC_EXPECTATION_FAILED = 417;    /**     * Status code (500) indicating an error inside the HTTP server     * which prevented it from fulfilling the request.     */    public static final int SC_INTERNAL_SERVER_ERROR = 500;    /**     * Status code (501) indicating the HTTP server does not support     * the functionality needed to fulfill the request.     */    public static final int SC_NOT_IMPLEMENTED = 501;    /**     * Status code (502) indicating that the HTTP server received an     * invalid response from a server it consulted when acting as a     * proxy or gateway.     */    public static final int SC_BAD_GATEWAY = 502;    /**     * Status code (503) indicating that the HTTP server is     * temporarily overloaded, and unable to handle the request.     */    public static final int SC_SERVICE_UNAVAILABLE = 503;    /**     * Status code (504) indicating that the server did not receive     * a timely response from the upstream server while acting as     * a gateway or proxy.     */    public static final int SC_GATEWAY_TIMEOUT = 504;    /**     * Status code (505) indicating that the server does not support     * or refuses to support the HTTP protocol version that was used     * in the request message.     */    public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\n\n应用：\n\n浏览器输出消息\n\n下载文件\nimport javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class FileServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //下载步骤：        //1.获取下载文件的路径        //String realPath = this.getServletContext().getRealPath(&quot;/1.png&quot;);        String realPath = &quot;C:\\\\Users\\\\zhomg\\\\Documents\\\\Java\\\\JavaEE\\\\javaweb-02-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png&quot;;        System.out.println(&quot;下载文件的路径：&quot;+realPath);        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;)+1); //获取下载文件名        //2.设置浏览器响应头        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));        //3.获取下载文件的输入流        FileInputStream in = new FileInputStream(realPath);        //4.创建缓冲区和输出流        int len = 0;        byte[] buffer = new byte[1024];        ServletOutputStream out = resp.getOutputStream();        //5.读取输入流并存储到缓冲区，使用输出流将缓冲区中的数据输出到客户端        while((len=in.read(buffer))!=-1)&#123;            out.write(buffer,0,len);        &#125;        in.close();        out.close();    &#125;\n\n验证码\n@Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //让浏览器自动刷新        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);        //在内存中创建一个图片        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);        //得到图片，Graphics对象相当于画笔        Graphics2D g = (Graphics2D)image.getGraphics();        //设置图片的背景颜色        g.setColor(Color.WHITE);        g.fillRect(0,0,45,20);        //给图片写数据        g.setColor(Color.BLUE);        g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD,20));        g.drawString(makeNum(),0,20);        //设置浏览器打开方式为图片        resp.setContentType(&quot;image/jpeg&quot;);        //关闭浏览器缓存        resp.setDateHeader(&quot;expires&quot;,-1);        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);        //把图片写给浏览器        ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream());    &#125;    private String makeNum()&#123;        Random random = new Random();        String num = random.nextInt(10000)+&quot;&quot;;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 4-num.length(); i++) &#123;            sb.append(&quot;0&quot;);        &#125;        num = sb.toString() + num;        return num;    &#125;\n\n重定向\n\n\nA→B，B通知A访问另一个Web资源C\npublic void sendRedirect(String location) throws IOException;/*相当于resp.setHeader(&quot;Location&quot;,/r/success.jsp);resp.setStatus(302);*/\n\n重定向和转发的区别\n相同点\n\n页面都会实现跳转\n\n不同点\n\n请求转发时，URL不会产生变化 307\n重定向时，URL会产生变化 302\n\n&lt;form action=&quot;$&#123;pageContext.request.getContextPath&#125;/login&quot; method=&quot;get&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    ...    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n\n\n3.3 ServletRequestRequest是用户（客户端）的请求，可以获取客户端的各种信息\n应用：\n\n获取前端传递的参数\n\nStirng username = req.getParameter(&quot;username&quot;);\n\n\n请求转发\n\n//这里的/代表当前web应用根目录req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);\n\n4 Cookie &amp; Session4.1 Cookie\n从请求中拿到cookie信息\n服务器响应给客户端cookie\n\nCookie[] cookies = req.getCookies();cookie.getName(); //获得cookie中的keycookie.getValue(); new Cookie(&quot;lastLoginTime&quot;,System.currentTimeMills()+&quot;&quot;);cookie.setMaxAge(24*60*60);//cookie.setMaxAge(0);将cookie设置过期resp.addCookie(cookie); //响应给客户端一个cookie\n\nCookie只能存放一个大小限制为4KB的字符串信息\n编码解码：\nURLEncoder.encode(&quot;中文&quot;，&quot;utf-8&quot;);URLDecoder.decode(copkie.getValue(),&quot;utf-8&quot;);\n\n4.2 SessionHttpSession session = req.getSession();session.removeAttribute(&quot;name&quot;);//手动注销Sessionsession.invalidate();\n\n会话自动过期：web.xml配置\n&lt;!--设置session默认失效的时间--&gt;&lt;session-config&gt;\t&lt;!--15分钟后session自动失效--&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;\n\n5 JSPJSP执行原理：\ntomcat服务器中有一个work目录；\nIDEA中使用tomcat的会在IDEA中产生一个work目录\n\n发现页面转变成了Java程序\n\n浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet\nJSP最终也会被转换为一个Java类\nJSP本质上就是一个Servlet\n//初始化public void _jspInit() &#123;&#125;//销毁public void _jspDestroy() &#123;&#125;//JSPServicepublic void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)\n\n\n判断请求\n内置对象 \n\nfinal javax.servlet.jsp.PageContext pageContext;final javax.servlet.ServletContext application; //applicationContextfinal javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null;final java.lang.Object page = this; //当前页面javax.servlet.http.HttpServletRequest request;final javax.servlet.http.HttpServletResponse response;\n\n\n输出页面前增加的代码\n\nresponse.setContentType(&quot;text/html; charset=UTF-8&quot;);pageContext = _jspxFactory.getPageContext(this, request, response,null, false, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();out = pageContext.getOut();_jspx_out = out;\n\n可以在JSP页面中直接使用内置对象\nJSP基础语法\n\nJSP表达式&lt;%=(var/exp)%&gt;\n\nJSP脚本&lt;%(script)%&gt;\n\nJSP声明&lt;%!(statement)%&gt;\n\n\n区别：\nJSP声明会被编译到JSP生成的类中，而JSP表达式和脚本则会被生成到_jspService方法中\nJSP注释：&lt;%--注释--%&gt;，不会在客户端（浏览器）显示\nEL表达式：${var}\n5.1 JSP指令\npage指令\n\n&lt;%--自动生成--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;Java&quot; %&gt;&lt;%--导入jar包--%&gt;&lt;%@ page import=&quot;java.util.*&quot; %&gt;&lt;%--定制错误页面--%&gt;&lt;%@ page errorPage=&quot;error/500.jsp&quot; %&gt;\n\nweb.xml\n&lt;error-page&gt;\t&lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/error/404.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;\t&lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/error/500.jsp&lt;/location&gt;&lt;/error-page&gt;\n\n\ninclude指令\n\n&lt;%@include file=&quot;common/header.jsp&quot; %&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=&quot;common/footer.jsp&quot; %&gt;&lt;%--JSP标签--%&gt;&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;\n\n区别：\ninclude指令将三个页面的内容一并输出，本质是一个页面\ninclude标签是主页面调用两个子页面，本质还是三个页面\n作用域大小不同的内置对象\n&lt;%\t//底层→高层（作用域）：page→request→session→application\t//JVM：双亲委派机制\tpageContext.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一个页面中有效    request.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一次请求中有效    session.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一次会话中有效    application.setAttribute(&quot;name1&quot;,&quot;1&quot;); //servletContext,在打开服务器期间有效%&gt;\n\n双亲委派机制的作用：\n1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。\n拓展：请求转发\n&lt;%\tpageContext.forward(&quot;/index.jsp&quot;);\t//request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request,response);%&gt;\n\n5.2 JSP标签JSP标签\n&lt;jsp:forward page = &quot;/jsptag2.jsp&quot;&gt;\t&lt;jsp:param name = &quot;name&quot; value = &quot;xxx&quot;&gt;&lt;/jsp:param&gt;    &lt;jsp:param name = &quot;age&quot; value = &quot;18&quot;&gt;&lt;/jsp:param&gt;&lt;/jsp:forward&gt;\n\nJSTL标签→弥补HTML标签的不足\n使用jstl标签的maven依赖\n&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;\n\n核心标签\n&lt;%--引入JSTL核心标签库，才能使用JSTL标签--%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;\n\n\n格式化标签，SQL标签，XML标签\n6 JavaBeanJavaBean特定写法：\n\n必须要有一个无参构造\n属性必须私有化\n必须有对应的get/set方法\n\n一般用来和数据库字段做映射ORM\nORM：对象关系映射\n\n表→类\n字段→属性\n行→对象\n\n过滤器，文件上传，邮件发送\n7 MVC三层架构Model\n\n业务处理：业务逻辑（Service）\n数据持久层：CRUD（Dao）\n\nView\n\n展示数据\n提供链接发起Servlet请求（a, form, img…）\n\nController(Servlet)\n\n接收用户的请求：（req：请求参数、Session信息…）\n交给业务层处理相应的代码\n控制视图的跳转\n\n8 FilterFilter：过滤器，用来过滤网站的数据\n\n处理中文乱码\n登录验证\n\nFilter开发步骤：\n\n导包\n编写过滤器\n\nimport javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);    &#125;    /*    1.在过滤特定请求时，Filter所有代码都会执行    2.注意务必通过chain.doFilter让过滤器继续通行     */    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        request.setCharacterEncoding(&quot;utf-8&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        System.out.println(&quot;CharacterEncodingFilter执行前...&quot;);        chain.doFilter(request,response);        System.out.println(&quot;CharacterEncodingFilter执行后...&quot;);    &#125;    @Override    public void destroy() &#123;        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);    &#125;&#125;\n\n\nweb.xml配置Filter\n\n&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.zhg.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n9 Listener\n编写一个监听器（实现监听器的接口）\n\nimport javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class OnlineCounterListener implements HttpSessionListener &#123;    @Override    public void sessionCreated(HttpSessionEvent se) &#123;        ServletContext ctx = se.getSession().getServletContext();        Integer onlineCount = (Integer)ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count+1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;    @Override    public void sessionDestroyed(HttpSessionEvent se) &#123;        ServletContext ctx = se.getSession().getServletContext();        Integer onlineCount = (Integer)ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count-1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;&#125;\n\n\n在web.xml中注册监听器\n\n&lt;listener&gt;    &lt;listener-class&gt;com.zhg.listener.OnlineCounterListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n10 JDBC环境搭建\nmaven导入jar包\n&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n\n\n10.2 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n11 Ajax\nAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n$.ajax(&#123; \ttype: &quot;POST&quot;, \turl: &quot;$&#123;pageContext.request.contextPath&#125;/jsp/user.do&quot;,    dataType: &quot;json&quot;,    success:function(data)&#123;    \t...\t&#125;,    error:function(data)&#123;        ...    &#125;&#125;);\n\n11.1 JSON\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n使用阿里巴巴的fastjson.jar包\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;\n\nServlet中设置一个Map结果集\nMap&lt;String,String&gt; resultMap = new HashMap&lt;&gt;();...resp.setContentType(&quot;application/json&quot;);PrintWriter writer = resp.getWritter();// JSONArray 阿里巴巴的JSON工具类 → 转换格式// Map（[&quot;key1&quot;:&quot;value1&quot;]）→JSON（&#123;key:value&#125;）writter.write(JSONArray.toJSONString(resultMap));writer.flush();writer.close();\n\n12 Web项目开发用户请求数据流：前端页面（Ajax/表单提交）→Servlet→Service（处理事务）→Dao→JDBC→数据库\n12.1 上传文件实现文件上传需要jar包common-io，上传组件common-fileupload\n在页面中创建上传按钮\n&lt;form action=&quot;/upload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n上传文件处理代码（Servlet）\n// 判断上传文件是普通表单还是带文件的表单if(!ServletFileUpload.isMultipartContent(request))&#123;    return;&#125;// 创建上传文件的保存路径，建议保存在WEB-INF路径下，安全，用户无法直接访问上传的文件String uploadPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);File uploadFile = new File(uploadPath);if(!uploadFile.exists())&#123;    uploadFile.mkdir();&#125;// 临时路径，假如文件超过了预期的大小，就把这个文件放到一个临时文件中，过几天自动删除，或者提醒用户转存为永久String tmpPath = this.getServletContext().getRealPath(&quot;/WEB-INF/tmp&quot;);File tmpFile = new File(tmpPath);if(!tmpFile.exists())&#123;    tmpFile.mkdir();&#125;// 1.创建DiskFileItemFactory对象，处理文件上传路径或文件大小限制DiskFileItemFactory factory = new DiskFileItemFactory();// 通过这个工厂设置一个缓冲区，当上传文件大于缓冲区时，将其放到临时文件中factory.setSizeThreshold(1024*1024); // 缓存区大小为1Mfactory.setRepository(tmpFile);// 2.获取ServletFileUploadServletFileUpload upload = new ServletFileUpload(factory);// 监听文件上传进度upload.setProgressListener(new ProgressListener()&#123;    @Override    public void update(long pByteRead,long pContentLength,int pItem)&#123;        System.out.println(&quot;总大小：&quot;+pContentLength+&quot;已上传：&quot;+pBytesRead);    &#125;&#125;);upload.setHeaderEncoding(&quot;UTF-8&quot;);upload.setFileSizeMax(1024*1024*10); // 设置总共能上传10M文件// 3.解析前端请求，封装成FileItem对象List&lt;FileItem&gt; fileItems = upload.parseRequest(request);for(FileItem fileItem : fileItems)&#123;    if(fileItem.isFormField())&#123; //普通的表单        // getFieldName指的是前端表单控件的name        String name = fileItem.getFieldName();        String value = fileItem.getString(&quot;UTF-8&quot;);        System.out.println(name+&quot;:&quot;+value);    &#125;else&#123; //上传文件        String uploadFileName = fileItem.getName();        System.out.println(&quot;上传的文件名：&quot;+uploadFileName);        if(uploadFileName.trim().equals(&quot;&quot;)||uploadFileName==null)&#123;            continue;        &#125;        String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(/)+1);        String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(.)+1);        String uuidPath = UUID.randomUUID().toString();                String realPath = uploadPath+&quot;/&quot;+uuidPath;        File realPathFile = new File(realPath);        if(!realPathFile.exists())&#123;            realPathFile.mkdir();        &#125;        InputStream inputStream = fileItem.getInputStream();        FileOutputStream fos = new FileOutputStream(realPath+&quot;/&quot;+fileName);        byte[] buffer = new byte[1024*1024];        int len = 0;        while((len = inputStream.read(buffer)) != -1)&#123;            fos.write(buffer,0,len);        &#125;        fos.close();        inputStream.close();                msg = &quot;文件上传成功！&quot;;        fileItem.delete(); // 上传成功，清除临时文件    &#125;&#125;\n\nServletFileUpload负责上传得文件数据，并将表单中每个输入项封装成一个FileItem对象，在使用ServletFileUpload对象解析请求时需要DiskFileItemFactory对象（通过ServletFileUpload对象的构造方法或setFileItemFactory()方法设置ServletFileUpload对象的FileItemFactory属性）\n上传的注意事项：\n\n为保护服务器安全，上传文件应该放在外界无法直接访问的目录下（WEB-INF）\n为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名（时间戳，UUID，MD5，位运算）\n要限制上传文件的最大值\n可以限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法\n\n12.2 发送邮件协议：SMTP和POP3/IMAP、MIME\n当两台不同的服务器进行消息通讯时，是SMTP进行握手，A服务器发送邮件到B服务器，B服务器的SMTP会替本地用户接受外面发过来的邮件，然后POP3/IMAP去读取SMTP收取的邮件\nSMTP是邮局，POP3是快递员，快递员只会去邮局领取邮件，而不是直接去发件人手上直接拿，两个地区（邮箱服务器）邮件收发也是通过邮局（SMTP）来完成\n收发邮件步骤：\n\n用户A的邮箱为&#x78;&#120;&#x78;&#x40;&#113;&#113;&#x2e;&#x63;&#109;，通过foxmail客户端写好一封邮件点击发送，即提交到了QQ邮箱服务器，使用的是SMTP协议。\nQQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是qq邮箱，会直接存储到自己的存储空间，\n如果不是则会发送到指定邮箱服务器，使用的也是SMTP协议。163服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件\n用户B收到消息后，打开客户端访问163服务器（也可以自己敲命令直接访问），163服务器会去调用POP3服务\nPop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。\n将读取到的邮件返回给客户端软件\n\n用Java实现邮件收发，首先应该准备JavaMail API和Java Activation Framework（mail.jar, activation.jar）\nSession：定义整个程序所需程序环境信息（主机名、端口号、协议）\nMessage：邮件\nTransport（发送邮件）→Store（接收邮件）\nProperties prop = new Properties();prop.setProperty(&quot;mail.host&quot;,&quot;smtp.qq.com&quot;);prop.setProperty(&quot;mail.transport.protocol&quot;,&quot;smtp&quot;);prop.setProperty(&quot;mail.smtp.auth&quot;,true); // 需要验证用户名密码// QQ邮箱还需要设置SSL加密MailSSLSocketFactory sf = new MailSSLSocketFactory();sf.setTrustAllHosts(true);prop.put(&quot;mail.smtp.ssl.enable&quot;,&quot;true&quot;);prop.put(&quot;mail.smtp.ssl.socketFactory&quot;,sf);// 使用JavaMail发送邮件的5个步骤// 1.创建定义整个应用程序所需环境信息的Session对象// 只有QQ邮箱需要Session session = Session.getDefaultInstance(prop,new Authenticator()&#123;    public PasswordAuthentication getPasswordAuthentication()&#123;        // 发送人邮件用户名、授权码        return new PasswordAuthentication(&quot;xxxxx@qq.com&quot;,&quot;授权码&quot;); //授权码可以在QQ邮箱 设置 → 开启POP3/SMTP服务后获取    &#125;&#125;);//开启Session的debug模式，可以查看程序发送Email的运行状态session.setDebug(true);// 2.通过Session得到Transport对象Transport ts = session.getTransport();// 3.使用邮箱的用户名和授权码连接邮件服务器ts.connect(&quot;smtp.qq.com&quot;,&quot;xxxxx@qq.com&quot;,&quot;授权码&quot;)    // 4.创建邮件MimeMessage message = new MimeMessage(session);message.setFrom(new InternetAddress(&quot;xxxxx@qq.com&quot;)); // 指明发件人message.setRecipient(Message.RecipientType.To,new InternetAddress(&quot;yyyyy@qq.com&quot;)); // 指明收件人// 4.1.发送只含文本的简单邮件message.setSubject(&quot;只含文本的简单邮件&quot;);message.setContent(&quot;你好啊！&quot;,&quot;text/html;charset=UTF-8&quot;);// 4.2.发送带图片/附件的邮件message.setSubject(&quot;带图片的邮件&quot;);// 图片MimeBodyPart image = new MimeBodyPart();DataHandler dh = new DataHandler(new FileDataSource(&quot;src/resouces/xxx.jpg&quot;));image.setDataHandler(dh);image.setContentID(&quot;bz.jpg&quot;);// 文本MimeBodyPart text = new MimeBodyPart();text.setContent(&quot;这是一封带图片&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;的邮件&quot;,&quot;text/html;charset=UTF-8&quot;);// 附件MimeBodyPart attachment = new MieBodyPart();attachment.setDataHandler(new DataHandler(new FileDataSource(&quot;src/resources/1.txt&quot;)));attachment.setFileName(&quot;1.txt&quot;);// 拼装邮件正文内容MimeMultipart mm1 = new MimeMultipart();mm.addBodyPart(text);mm.addBodyPart(image);// MimeMultipart.subType:alternative(超文本) → related(内嵌资源) → mixed(附件)mm.setSubType(&quot;related&quot;); // 图片文本内嵌成功MimeBodyPart contextText = new MimeBodyPart();contentText.setContent(mm1);//拼接附件MimeMultipart allFile = new MimeMultipart();allFile.addBodyPart(attachment); allFile.addBodyPart(contentText);allFile.setSubType(&quot;mixed&quot;);// 设置到消息中，保存修改message.setContent(mm);message.saveChanges();   // 5.发送邮件ts.sendMessage(message,message.getAllRecipients());// 6.关闭连接ts.close();\n\n","tags":["Java","JavaWeb","Servlet","Session","Cookie","JSP"]},{"title":"LeetCode 57.插入区间","url":"/2020/11/04/LeetCode57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/","content":"题目描述：\n给出一个无重叠的 ，按照区间起始端点排序的区间列表。\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n示例1：\n输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]\n示例2：\n输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]\n思路：找出所有与新插入区间 newInterval = [left,right] 重叠的区间集合并将这些区间合并\n\n遍历 intervals 的区间 [li,ri] \n\n如果 ri &lt; left 或者 li &gt; right，说明 [li,ri] 与 newInterval不重叠，可直接将 [li,ri] 加入答案\n否则， [li,ri] 与 newInterval重叠，需要将 [li,ri] 与 newInterval合并\n\npublic int[][] insert(int[][] intervals, int[] newInterval) &#123;    int left = newInterval[0];    int right = newInterval[1];    boolean placed = false;    List&lt;int[]&gt; ansList = new ArrayList&lt;int[]&gt;();    for (int[] interval : intervals) &#123;        if (interval[0] &gt; right) &#123;            // 在插入区间的右侧且无交集            if (!placed) &#123;                ansList.add(new int[]&#123;left, right&#125;);                placed = true;                                &#125;            ansList.add(interval);        &#125; else if (interval[1] &lt; left) &#123;            // 在插入区间的左侧且无交集            ansList.add(interval);        &#125; else &#123;            // 与插入区间有交集，计算它们的并集            left = Math.min(left, interval[0]);            right = Math.max(right, interval[1]);        &#125;    &#125;    if (!placed) &#123;        ansList.add(new int[]&#123;left, right&#125;);    &#125;    int[][] ans = new int[ansList.size()][2];    for (int i = 0; i &lt; ansList.size(); ++i) &#123;        ans[i] = ansList.get(i);    &#125;    return ans;&#125;\n\n链接：https://leetcode-cn.com/problems/insert-interval\n类似题目：56.合并区间\n题目描述：\n给出一个区间的集合，请合并所有重叠的区间。\n示例1：\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]\n示例2：\n输入: intervals = [[1,4],[4,5]]输出: [[1,5]]\n思路：按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。\n\n然后将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间。如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，直接将这个区间加入数组 merged 的末尾；否则，需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。\npublic int[][] merge(int[][] intervals) &#123;    if (intervals.length == 0) &#123;        return new int[0][2];    &#125;    Arrays.sort(intervals, (int[] interval1, int[] interval2) -&gt; interval1[0] - interval2[0]);    List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;();    for (int i = 0; i &lt; intervals.length; ++i) &#123;        int L = intervals[i][0], R = intervals[i][1];        if (merged.size() == 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123;            merged.add(new int[]&#123;L, R&#125;);        &#125; else &#123;            merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);        &#125;    &#125;    return merged.toArray(new int[merged.size()][]);&#125;\n\n链接：https://leetcode-cn.com/problems/merge-intervals\n","tags":["算法","LeetCode","数组","排序"]},{"title":"LeetCode 1356.根据数字二进制下1的数目排序","url":"/2020/11/06/Leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/","content":"题目描述：\n给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。\n如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。\n请你返回排序后的数组。\n示例1：\n输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]\n示例2：\n输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]\n思路：调用系统自带的排序函数，改写一下排序规则即可\n统计数字二进制下1的数目：\n// 方法一int bitCount(int n) &#123;    int count = 0;    while (n &gt; 0) &#123;        if((n &amp; 1) == 1)  count++;        n &gt;&gt;= 1 ;    &#125;    return count;&#125;// 方法二int bitCount(int n) &#123;    int count = 0;    while (n != 0) &#123;        n &amp;= (n-1);        count++;    &#125;    return count;&#125;\n\n改写排序规则:\npublic int[] sortByBits(int[] arr) &#123;    int[] bit = new int[10001];    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    for (int x : arr) &#123;        list.add(x);        bit[x] = bitCount(x);    &#125;    Collections.sort(list, (Integer x,Integer y) -&gt; &#123;        if (bit[x] != bit[y]) &#123;            return bit[x] - bit[y];        &#125; else &#123;            return x - y;        &#125;    &#125;);    //return list.stream().mapToInt(Integer::intValue).toArray();    for (int i = 0; i &lt; arr.length; ++i) &#123;        arr[i] = list.get(i);    &#125;    return arr;&#125;public int bitCount(int n) &#123;    int count = 0;    while (n != 0) &#123;        n &amp;= (n-1);        count++;    &#125;    return count;&#125;\n\n\n链接：https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\n","tags":["算法","LeetCode","排序","位运算"]},{"title":"Java优先级队列（PriorityQueue）","url":"/2020/11/10/Java%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88PriorityQueue%EF%BC%89/","content":"PriorityQueue，即优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。\nJava中PriorityQueue实现了Queue接口，不允许放入null元素以及不可比较的对象（没有实现Comparable接口的对象）；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆。PriorityQueue 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。\n用法示例：\npublic class App &#123;    public static void main(String[] args) &#123;        //通过改造器指定排序规则        PriorityQueue&lt;Student&gt; q = new PriorityQueue&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;            public int compare(Student o1, Student o2) &#123;                //按照分数低到高，分数相等按名字                if(o1.getScore() == o2.getScore())&#123;                    return o1.getName().compareTo(o2.getName());                &#125;                return o1.getScore() - o2.getScore();            &#125;        &#125;);        //入列        q.offer(new Student(&quot;dafei&quot;, 20));        q.offer(new Student(&quot;will&quot;, 17));        q.offer(new Student(&quot;setf&quot;, 30));        q.offer(new Student(&quot;bunny&quot;, 20));        //出列        System.out.println(q.poll());  //Student&#123;name=&#x27;will&#x27;, score=17&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;bunny&#x27;, score=20&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;dafei&#x27;, score=20&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;setf&#x27;, score=30&#125;    &#125;&#125;\n\nLeetCode相关题目：\nLeetCode 347.前K个高频元素\n题目描述：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\nclass Solution &#123;    public int[] topKFrequent(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; occurrences = new HashMap&lt;Integer, Integer&gt;();        for (int num : nums) &#123;            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);        &#125;        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] m, int[] n) &#123;                return m[1] - n[1];            &#125;        &#125;);        for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;            int num = entry.getKey(), count = entry.getValue();            if (queue.size() == k) &#123;                if (queue.peek()[1] &lt; count) &#123;                    queue.poll();                    queue.offer(new int[]&#123;num, count&#125;);                &#125;            &#125; else &#123;                queue.offer(new int[]&#123;num, count&#125;);            &#125;        &#125;        int[] ret = new int[k];        for (int i = 0; i &lt; k; ++i) &#123;            ret[i] = queue.poll()[0];        &#125;        return ret;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/top-k-frequent-elements\nLeetCode 973.最接近原点的K的点\n题目描述：我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。\nclass Solution &#123;    public int[][] kClosest(int[][] points, int K) &#123;        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] array1, int[] array2) &#123;                return array2[0] - array1[0];            &#125;        &#125;);        for (int i = 0; i &lt; K; ++i) &#123;            pq.offer(new int[]&#123;points[i][0] * points[i][0] + points[i][1] * points[i][1], i&#125;);        &#125;        int n = points.length;        for (int i = K; i &lt; n; ++i) &#123;            int dist = points[i][0] * points[i][0] + points[i][1] * points[i][1];            if (dist &lt; pq.peek()[0]) &#123;                pq.poll();                pq.offer(new int[]&#123;dist, i&#125;);            &#125;        &#125;        int[][] ans = new int[K][2];        for (int i = 0; i &lt; K; ++i) &#123;            ans[i] = points[pq.poll()[1]];        &#125;        return ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/k-closest-points-to-origin/\n","tags":["算法","LeetCode","Java","JavaSE","数据结构"]},{"title":"Mybatis教程","url":"/2020/11/14/Mybatis%E6%95%99%E7%A8%8B/","content":"Mybatis教程官方文档：https://mybatis.org/mybatis-3/zh/index.html\n1 简介\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n获取方式：\n\nMaven\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.3&lt;/version&gt;&lt;/dependency&gt;\n\nGithub：https://github.com/mybatis/mybatis-3/tree/master/src/site\n\n\n数据持久化就是将程序的数据在持久状态和瞬时状态转化的过程（内存：断电即失）\nMybatis框架简化JDBC代码操作，sql与java代码分离\n2 编写Mybatis程序思路：搭建环境→导入Mybatis→编写代码→测试\n\n搭建环境\n创建数据库→新建maven项目（删除src目录）→导入maven依赖\n&lt;dependencies&gt;        &lt;!--mysql驱动--&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--junit--&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建一个模块\n编写mybatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1031&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n编写mybatis工具类\nimport org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory → sqlSessionpublic class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static&#123;        try &#123;            // 使用Mybatis首先获取sqlSessionFactory对象            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。    // 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n编写代码\n\n实体类\n\n// 实体类public class User &#123;    private int id;    private String name;    private String pwd;    public User() &#123;    &#125;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\nDao接口\n\nimport com.zhg.pojo.User;import java.util.List;public interface UserDao &#123;    List&lt;User&gt; getUserList();&#125;\n\n\n接口实现类（UserDaoImpl.java → UserMapper.xml）\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.zhg.dao.UserDao&quot;&gt;    &lt;!--select查询语句--&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.zhg.pojo.User&quot;&gt;    select * from mybatis.user;  &lt;/select&gt;&lt;/mapper&gt;\n\n\njunit测试\n\nimport com.zhg.pojo.User;import com.zhg.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123;    @Test    public void test()&#123;        // 第一步：获得SqlSession对象        SqlSession sqlSession = MybatisUtils.getSqlSession();        // 方式一：getMapper        UserDao userDao = sqlSession.getMapper(UserDao.class);        List&lt;User&gt; userList = userDao.getUserList();//      // 方式二：不推荐//        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.zhg.dao.UserDao.getUserList&quot;);        for (User user : userList) &#123;            System.out.println(user);        &#125;        // 关闭SqlSession        sqlSession.close();    &#125;&#125;\n\n可能遇到的问题：\n\n配置文件没有注册\n绑定接口错误\n方法名不对\n返回类型不对\nMaven导出资源问题\n\n注意点：\norg.apache.ibatis.binding.BindingException\njunit测试\n\n\n3 CRUDnamespace（命名空间）中绑定的包名与Dao/Mapper接口名要一致\nselect查询语句：\n\nid：namespace绑定接口中的方法名\n\nresultType：SQL语句执行的返回类型\n\nparameterType：参数类型\n\nMap：#{key}\n类：#{field}\n基本类型：直接取到\n\n多个参数用Map或注解\n\n\nUserMapper.xml\n&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zhg.pojo.User&quot;&gt;    select * from user where id = #&#123;id&#125;;&lt;/select&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.zhg.pojo.User&quot;&gt;    insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt;\n\njunit测试\nSqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User user = userMapper.getUserById(1);System.out.println(user);int count = userMapper.addUser(new User(4,&quot;XXX&quot;,&quot;111111&quot;));if(count &gt; 0)&#123;\tSystem.out.println(&quot;插入成功！&quot;);&#125;// 更新(增删改)数据库数据需要提交事务！sqlSession.commit();\n\n4 配置解析4.1 核心配置文件mybatis-config.xml\nconfiguration（配置）\n\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\n\n\n\n\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n\n\n环境配置（environments）\nMybatis可以配置多个环境，每个SQLSessionFactory实例只能选择一种环境。\nMybatis的默认事务管理器是JDBC，默认数据源类型为POOLED。\n\n属性（properties）\n可以通过properties属性实现引用配置文件（db.properties）\n\n这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。\n\n编写配置文件（db.properties）\ndriver = com.mysql.cj.jdbc.Driverurl = jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=trueusername = rootpassword = 1031\n\n核心配置文件中引入外部配置文件（优先使用）\n&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;1031&quot;/&gt;&lt;/properties&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;\n\n类型别名（typeAliases）\n\n类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。\n\n mybatis-config.xml\n &lt;typeAliases&gt;    &lt;!--可以给实体类起别名--&gt;    &lt;typeAlias type=&quot;com.zhg.pojo.User&quot; alias=&quot;User&quot;/&gt;    &lt;!--扫描包，默认别名为类名（首字母小写）--&gt;    &lt;package name=&quot;com.zhg.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\nUserMapper.xml\n &lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;    select * from user;&lt;/select&gt;\n\n可以在实体类前加注解@Alias(“XXX”)起别名\n\n设置（settings）\n\n\n\n\n\n设置名\n描述\n有效值\n默认值\n\n\n\ncacheEnabled\n全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。\ntrue | false\ntrue\n\n\nlazyLoadingEnabled\n延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。\ntrue | false\nfalse\n\n\nmapUnderscoreToCamelCase\n是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。\ntrue | false\nfalse\n\n\nlogImpl\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\n未设置\n\n\n\n其他配置\n\n类型处理器（typeHandlers）\n对象工厂（objectFactory）\nplugins插件\nmybatis-generator-core\nmybatis-plus\n通用mapper\n\n\n\n\n映射器（mappers）\n&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;com/zhg/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;com.zhg.dao.UserMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;com.zhg.dao&quot;/&gt;&lt;/mappers&gt;\n\n注意点：\n\n接口和Mapper配置文件必须同名\n接口和Mapper配置文件必须在同一包下\n\n\n\n4.2 生命周期和作用域生命周期和作用域错误的使用会导致非常严重的并发问题\nSqlSessionFactoryBuilder：一旦创建SqlSessionFactory就不在需要\nSqlSessionFactory（线程池）：一旦被创建就应该在运行期间一直存在\n5 结果映射解决实体类属性名和数据库表字段名不一致的问题\nUserMapper.xml\n&lt;!--结果集映射--&gt;&lt;resultMap id = &quot;userResultMap&quot; type = &quot;User&quot;&gt;\t&lt;!--column对应数据库中的字段，property对应实体类中的属性--&gt;    &lt;!--    &lt;result column = &quot;id&quot; property = &quot;id&quot;/&gt;    &lt;result column = &quot;name&quot; property = &quot;name&quot;/&gt;\t--&gt;\t&lt;result column = &quot;pwd&quot; property = &quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    select * from user where id = #&#123;id&#125;;&lt;/select&gt;\n\n6 日志6.1 日志工厂通过在核心配置文件中的settings中设置logImpl的值来设定在Mybatis中所用日志的具体实现\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING \n &lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n\n6.2 LOG4J\nLog4j是Apache的一个开源项目，通过使用Log4j，我们可以\n\n控制日志信息输送的目的地是控制台、文件、GUI组件；\n控制每一条日志的输出格式；\n通过定义每一条日志信息的级别，更加细致地控制日志的生成过程；\n通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n\n\n导入log4j的jar包\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\nlog4j.properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/zhg.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n设置log4j为日志的实现\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt;\n\n\n\nlog4j的简单使用\n\n在使用log4j的类中，导入包org.apache.log4j.Logger\n\n日志对象，参数为当前类的class\nstatic Logger logger = Logger.getLogger(UserDaoTest.class);\n\n日志级别\nlogger.info(&quot;info&quot;);logger.debug(&quot;debug&quot;);logger.error(&quot;error&quot;);\n\n\n\n7 分页7.1 limit分页SELECT * FROM user LIMIT startIndex,pageSize;\n\n接口\n// 分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n\nMapper.xml\n&lt;select id = &quot;getUserBylimit&quot; parameterType = &quot;map&quot; resultMap = &quot;useMap&quot;&gt;    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;\n\n测试\n@Testpublic void getUserByLimit()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();    map.put(&quot;startIndex&quot;,1);    map.put(&quot;pageSize&quot;,2);        List&lt;User&gt; userList = mapper.getUserByLimit(map);    for(User user:userList)&#123;        System.out.println(user);    &#125;        sqlSession.close();&#125;\n\n\n\n7.2 RowBounds分页\n接口\n// 分页2List&lt;User&gt; getUserRowBounds();mapper.xml\n\n&lt;!--分页--&gt;&lt;select id = &quot;getUserByRowBounds&quot; resultMap = &quot;userMap&quot;&gt;    select * from mybatis.user&lt;/select&gt;\n\n测试\n@Testpublic void getUserByRowBounds()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();        // RowBounds实现    RowBounds rowBounds = new RowBounds(1,2);        // 通过Java代码层面实现分页    List&lt;User&gt; userList = sqlSession.selectList(&quot;com.zhg.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);    for(User user:userList)&#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n7.3 分页插件PageHelper：https://pagehelper.github.io/\n8 使用注解开发面向接口编程，根本原因：解耦，使定义与实现的分离\n\n在接口方法上添加注解\npublic interface UserMapper &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt; getUserList();&#125;\n\n在核心配置文件中绑定接口\n&lt;mappers&gt;    &lt;mapper class=&quot;com.zhg.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;\n\n测试\n@Testpublic void test()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getUserList();    for (User user : users) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n本质：反射机制实现\n底层：动态代理\n使用注解实现CRUD\n\n添加注解\n// 方法存在多个参数时，参数前必须加上注解@Param()@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User getUserById(@Param(&quot;id&quot;) int id);@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)int addUser(User user);\n\n测试\nSqlSession sqlSession = MybatisUtils.getSqlSession(); // sqlSessionFactory.openSession(true) 开启自动提交事务UserMapper mapper = sqlSession.getMapper(UserMapper.class);User user = mapper.getUserById(1);System.out.println(user);mapper.addUser(new User(5,&quot;Hello&quot;,&quot;123456&quot;));sqlSession.close();\n\n\n\n@Param()注解\n\n基本类型的参数或者String类型，需要加上\n引用类型不需要加\n如果只有一个基本类型，可以忽略，但建议加上\n\n9 Lombok\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n\n在IDEA中安装Lombok插件\n\n在项目中导入lombok的jar包\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;\n\n在实体类上加注解\n@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@varexperimental @var@UtilityClass\n\n常用注解：\n@Data：无参构造，get，set，toString，hashcode，equals\n@AllArgsConstructor：有参构造\n@NoArgsConstructor：无参构造\n@ToString\n@EqualsAndHashCode\n\n\n10 多对一处理数据库创建表，学生和老师是多对一的关系\nCREATE TABLE `teacher` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;); CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);\n\n学生实体类：\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    int id;    String name;    Teacher teacher;&#125;\n\n10.1 按照查询嵌套处理StudentMapper.xml\n&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;    select * from student;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;    &lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;teacher&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;teacher&quot; resultType=&quot;Teacher&quot;&gt;    select * from teacher where id = #&#123;id&#125;;&lt;/select&gt;\n\n10.2 按照结果嵌套处理StudentMapper.xml\n&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;    select s.id sid,s.name sname,t.name tname    from student s,teacher t    where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;\n\n11 一对多处理一个老师拥有多个学生\n老师实体类\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Teacher &#123;    int id;    String name;    List&lt;Student&gt; students;&#125;\n\n11.1 按照结果嵌套处理TeacherMapper.xml\n&lt;select id=&quot;getTeacher&quot; resultMap=&quot;Teacher&quot;&gt;    select s.id sid,s.name sname,t.id tid,t.name tname    from student s,teacher t    where s.tid = t.id and t.id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;Teacher&quot; type=&quot;Teacher&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;tid&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt;    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;sid&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n\n11.2 按照查询嵌套处理&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent&quot;&gt;    select * from teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;    &lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentsByTeacherId&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTeacherId&quot; resultType=&quot;Student&quot;&gt;    select * from student where tid = #&#123;tid&#125;;&lt;/select&gt;\n\n小结：\n\n关联 - association【多对一】\n集合 - collection【一对多】\njavaType &amp; ofType\njavaType：属性的类型\nofType：集合的泛型\n\n\n\n12 动态SQL动态SQL：根据不同条件生成不同的SQL语句\n\n动态 SQL 是 MyBatis 的强大特性之一。利用动态 SQL，可以彻底摆脱拼接 SQL 语句的痛苦。如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\n\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n创建数据库表blog\nCREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8\n\n创建实体类Blog\nimport lombok.Data;import java.util.Date;@Datapublic class Blog &#123;    String id;    String title;    String author;    Date createTime; // 属性名和字段名不一致    int views;&#125;\n\n属性名和字段名不一致，需要在核心配置文件中添加&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;，在**Mapper.xm文件的select语句中返回ResultType时，返回字段会自动转换成驼峰命名，与实体类中的属性相对应。\n12.1 条件查询与更新根据提交数据查询与更新博客\n&lt;!--if--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog where 1 = 1    &lt;if test=&quot;title != null&quot;&gt;        and title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;&lt;!--where--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;if test=&quot;title != null&quot;&gt;        \ttitle = #&#123;title&#125;    \t&lt;/if&gt;    \t&lt;if test=&quot;author != null&quot;&gt;        \tand author = #&#123;author&#125;    \t&lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!--choose,只执行一个分支--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;choose&gt;            &lt;when test = &quot;title != null&quot;&gt;                title = #&#123;title&#125;            &lt;/when&gt;            &lt;when test = &quot;author != null&quot;&gt;                author = #&#123;author&#125;            &lt;/when&gt;            &lt;otherwise&gt;                views = #&#123;views&#125;            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!--set--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot; &gt;    update blog    &lt;set&gt;        &lt;if test=&quot;title != null&quot;&gt;        \ttitle = #&#123;title&#125;    \t&lt;/if&gt;    \t&lt;if test=&quot;author != null&quot;&gt;        \tand author = #&#123;author&#125;    \t&lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;;&lt;/update&gt;\n\n12.2 SQL片段提取重复SQL语句，方便复用！\n&lt;sql id = &quot;if&quot;&gt;\t&lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;include refid = &quot;if&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;\n\n12.3 集合遍历查询多个特定条件的记录\n&lt;select id=&quot;queryBlog&quot;  parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\tSELECT * FROM blog    &lt;where&gt;        &lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;        \tid = #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n13 缓存13.1 简介缓存，即存在内存中的临时数据。将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上数据库查询，而是从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n缓存减少了和数据库的交互次数，减少系统开销，提高系统效率。\n经常查询且不经常改变的数据，可以使用缓存！\n13.2 Mybatis缓存MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 \n默认情况下，只启用了本地的会话缓存（一级缓存，SQLSession级别缓存），它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存（namespace级别缓存），只需要在SQL 映射文件中添加一行&lt;cache/&gt;。为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过Cache接口自定义二级缓存。\n一级缓存一级缓存也叫本地缓存：SqlSession\n与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要获取相同的数据，直接从缓存拿，不需要重新查询数据库。\n缓存失效的情况：\n\n增删改操作\n手动清理缓存sqlSession.clearCache()\n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，即获得连接到关闭连接这个时间段。\n二级缓存二级缓存也叫全局缓存：namespace\n一级缓存作用域太低了，所以诞生了二级缓存\n工作机制：\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中。如果当前会话关闭了，这个会话对应的一级缓存就没了。但我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中，新的会话中查询信息时可以从二级缓存中获取内容。\n步骤：\n\n开启全局缓存\n&lt;!--显式开启全局缓存--&gt;&lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;\n\n在要使用二级缓存的Mapper中开启\n&lt;cache  eviction=&quot;FIFO&quot;  flushInterval=&quot;60000&quot;  size=&quot;512&quot;  readOnly=&quot;true&quot;/&gt;\n\n\n\n问题：二级缓存配置中没有加上readOnly=&quot;true&quot;，出现异常Caused by: java.io.NotSerializableException:com.zhg.pojo.User\n解决：需要将实体类序列化！public class User implements Serializable&#123;...&#125;\n小结：只要开启了二级缓存，在同一个Mapper下就有效。所有数据都会先放在一级缓存中，只有当会话提交或关闭时，才会转存到二级缓存中。\n自定义缓存\nEhCache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存，Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器，缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。\n\n\n导入jar包\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n配置文件ehcache.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;         updateCheck=&quot;false&quot;&gt;    &lt;!--       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：       user.home – 用户主目录       user.dir  – 用户当前工作目录       java.io.tmpdir – 默认临时文件路径     --&gt;    &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot;/&gt;    &lt;!--       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。     --&gt;    &lt;!--      name:缓存名称。      maxElementsInMemory:缓存最大数目      maxElementsOnDisk：硬盘最大缓存个数。      eternal:对象是否永久有效，一但设置了，timeout将不起作用。      overflowToDisk:是否保存到磁盘，当系统当机时      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。      clearOnFlush：内存数量最大时是否清除。      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。      FIFO，first in first out，这个是大家最熟的，先进先出。      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。   --&gt;    &lt;defaultCache            eternal=&quot;false&quot;            maxElementsInMemory=&quot;10000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;259200&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;      &lt;cache            name=&quot;cloud_user&quot;            eternal=&quot;false&quot;            maxElementsInMemory=&quot;5000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;1800&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;  &lt;/ehcache&gt;\n\nMapper.xml中指定使用的缓存实现\n&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n\n\n\n商业项目中常使用Redis数据库（键值对）来做缓存！\n","tags":["Java","Mybatis","SSM框架"]},{"title":"LeetCode 1122.数组的相对排序","url":"/2020/11/14/LeetCode1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","content":"题目描述：\n给你两个数组，arr1 和 arr2，\narr2 中的元素各不相同arr2 中的每个元素都出现在 arr1 中对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。\n示例：\n输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19]\n提示：\narr1.length, arr2.length &lt;= 10000 &lt;= arr1[i], arr2[i] &lt;= 1000arr2 中的元素 arr2[i] 各不相同arr2 中的每个元素 arr2[i] 都出现在 arr1 中\n我的解法：\n思路：迭代两个数组，将数组arr1中出现在数组arr2的元素前置，再将未出现在数组arr2的元素按升序排列。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        int m = arr1.length, n = arr2.length;        int flag = 0;        for(int i = 0; i &lt; n; i++)&#123;            for(int j = 0; j &lt; m; j++)&#123;                if(arr1[j] == arr2[i])&#123;                    if(flag != j)&#123;                        int tmp = arr1[flag];                        arr1[flag] = arr1[j];                        arr1[j] = tmp;                     &#125;                    flag++;                &#125;            &#125;        &#125;        Arrays.sort(arr1,flag,m);        return arr1;    &#125;&#125;\n\n官方解法一：自定义排序\n思路：使用排序并自定义比较函数。对于比较函数的元素x和y有没有出现在数组arr2中分情况考虑。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for(int num : arr1) list.add(num);        for(int i = 0; i &lt; arr2.length; i++) map.put(arr2[i], i);        Collections.sort(list, (x, y) -&gt; &#123;            if(map.containsKey(x) || map.containsKey(y)) return map.getOrDefault(x, 1001) - map.getOrDefault(y, 1001); // arr2[i] &lt;= 1000            return x - y;        &#125;);        for(int i = 0; i &lt; arr1.length; i++) arr1[i] = list.get(i);        return arr1;    &#125;&#125;\n\n官方解法二：计数排序\n思路：构造数组记录值等于下标 i 出现在数组arr1中的频次frequency[i]，再遍历数组arr2，将遍历到的元素 x 加入答案 并将frequency[x]清零。最后再遍历数组frequency，将frequency[x]不为0的元素x加入答案。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        int upper = 0;        for (int x : arr1) &#123;            upper = Math.max(upper, x);        &#125;        int[] frequency = new int[upper + 1];        for (int x : arr1) &#123;            ++frequency[x];        &#125;        int[] ans = new int[arr1.length];        int index = 0;        for (int x : arr2) &#123;            for (int i = 0; i &lt; frequency[x]; ++i) &#123;                ans[index++] = x;            &#125;            frequency[x] = 0;        &#125;        for (int x = 0; x &lt;= upper; ++x) &#123;            for (int i = 0; i &lt; frequency[x]; ++i) &#123;                ans[index++] = x;            &#125;        &#125;        return ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/relative-sort-array\n","tags":["算法","LeetCode","数组","排序"]},{"title":"POI和EasyExcel","url":"/2020/11/15/POI%E5%92%8CEasyExcel/","content":"POI和EasyExcel应用场景：\n\n将数据导出为Excel表格\n将Excel表格数据录入到数据库\n\n操作Excel表格目前比较流行的是Apache POI和阿里巴巴的EasyExcel\nApache POI\nApache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。\n\n官网：http://poi.apache.org/\n基本功能：\nHSSF － 提供读写Microsoft Excel格式档案的功能。（03）XSSF － 提供读写Microsoft Excel OOXML格式档案的功能。（07）HWPF － 提供读写Microsoft Word格式档案的功能。HSLF － 提供读写Microsoft PowerPoint格式档案的功能。HDGF － 提供读写Microsoft Visio格式档案的功能。\n导入依赖\n&lt;!-- xls(03) --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi&lt;/artifactId&gt;    &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- xls(07) --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;    &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日期格式化工具 --&gt;&lt;!-- https://mvnrepository.com/artifact/joda-time/joda-time --&gt;&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.10.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- test --&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;\n\nPOI-Excel写工作簿 → 工作表 → 行 → 列\n03版本\n@Testpublic void testWrite03() throws IOException &#123;    // 1.创建一个工作簿    Workbook workbook = new HSSFWorkbook();    // 2.创建一个工作表    Sheet sheet = workbook.createSheet(&quot;打卡记录03&quot;);    // 3.创建一个行    // 第一行    Row row1 = sheet.createRow(0);    // 4.创建一个单元格    Cell cell11 = row1.createCell(0);    cell11.setCellValue(&quot;姓名&quot;);    Cell cell12 = row1.createCell(1);    cell12.setCellValue(&quot;XXX&quot;);    // 第二行    Row row2 = sheet.createRow(1);    // 4.创建一个单元格    Cell cell21 = row2.createCell(0);    cell21.setCellValue(&quot;打卡时间&quot;);    Cell cell22 = row2.createCell(1);    String time = new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;);    cell22.setCellValue(time);    // 生成一张表（IO流）    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;打卡记录03.xls&quot;);    // 输出    workbook.write(fileOutputStream);    // 关闭流    fileOutputStream.close();    System.out.println(&quot;打卡记录03.xls生成完毕！&quot;);&#125;\n\n07版本\n@Testpublic void testWrite07() throws IOException &#123;    // 1.创建一个工作簿    Workbook workbook = new XSSFWorkbook();    // 2.创建一个工作表    Sheet sheet = workbook.createSheet(&quot;打卡记录07&quot;);    // 3.创建一个行    // 第一行    Row row1 = sheet.createRow(0);    // 4.创建一个单元格    Cell cell11 = row1.createCell(0);    cell11.setCellValue(&quot;姓名&quot;);    Cell cell12 = row1.createCell(1);    cell12.setCellValue(&quot;XXX&quot;);    // 第二行    Row row2 = sheet.createRow(1);    // 4.创建一个单元格    Cell cell21 = row2.createCell(0);    cell21.setCellValue(&quot;打卡时间&quot;);    Cell cell22 = row2.createCell(1);    String time = new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;);    cell22.setCellValue(time);    // 生成一张表（IO流）    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;打卡记录07.xlsx&quot;);    // 输出    workbook.write(fileOutputStream);    // 关闭流    fileOutputStream.close();    System.out.println(&quot;打卡记录07.xlsx生成完毕！&quot;);&#125;\n\n\n03版的xls最多只能容纳65536行数据\n\n07版的xlsx则没有限制，但耗时长\n\n\n可以使用SXSSFWorkbook读写大数据量的Excel表格，且耗时比XSSFWorkbook短，不过在使用SXSSFWorkbook读写Excel表格时会生成临时文件，处理结束时需加上((SXSSFWorkbook) workbook).dispose()将其清理。\n官方解释：实现”BigGridDemo”策略的流式XSSFWorkbook版本允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。但是注意，如果广泛使用例如合并区域，注释这类功能，将可能消耗大量内存。\nPOI-Excel读03版本\n@Testpublic void testRead03() throws IOException &#123;    // 获取文件流    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;打卡记录03.xls&quot;);    // 1.创建一个工作簿    Workbook workbook = new HSSFWorkbook(fileInputStream);    // 2.得到表    Sheet sheet = workbook.getSheetAt(0);    // 3.得到行    Row row = sheet.getRow(1);    // 4.得到列    Cell cell = row.getCell(1);    // 读取值的时候一定要注意类型！    System.out.println(cell.getStringCellValue());    fileInputStream.close();&#125;\n\n07版本\n@Testpublic void testRead07() throws IOException &#123;    // 获取文件流    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;打卡记录07.xlsx&quot;);    // 1.创建一个工作簿    Workbook workbook = new XSSFWorkbook(fileInputStream);    // 2.得到表    Sheet sheet = workbook.getSheetAt(0);    // 3.得到行    Row row = sheet.getRow(1);    // 4.得到列    Cell cell = row.getCell(1);    // 读取值的时候一定要注意类型！    System.out.println(cell.getStringCellValue());    fileInputStream.close();&#125;\n\n读取不同类型的数据类型\n@Testpublic void testCellType() throws Exception&#123;    // 获取文件流，读取工作簿    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;明细表.xls&quot;);    Workbook workbook = new HSSFWorkbook(fileInputStream);    Sheet sheet = workbook.getSheetAt(0);    // 获取标题内容    Row rowTitle = sheet.getRow(0);    if(rowTitle!=null)&#123;        int cellCount = rowTitle.getPhysicalNumberOfCells();        for(int cellNum = 0; cellNum &lt; cellCount; cellNum++)&#123;            Cell cell = rowTitle.getCell(cellNum);            if(cell != null)&#123;                String cellValue = cell.getStringCellValue();                System.out.print(cellValue + &quot; | &quot;);            &#125;        &#125;        System.out.println();    &#125;    // 获取表中内容    int rowCount = sheet.getPhysicalNumberOfRows();    for(int rowNum = 1; rowNum &lt; rowCount; rowNum++)&#123;        Row rowData = sheet.getRow(rowNum);        if(rowData!=null)&#123;            int cellCount = rowTitle.getPhysicalNumberOfCells();            for(int cellNum = 0; cellNum &lt; cellCount; cellNum++)&#123;                System.out.print(&quot;[&quot;+(rowNum+1)+&quot;-&quot;+(cellNum+1)+&quot;] &quot;);                Cell cell = rowData.getCell(cellNum);                // 匹配列的数据类型                if(cell != null)&#123;                    int cellType = cell.getCellType();                    String cellValue = &quot;&quot;;                    switch(cellType)&#123;                        case HSSFCell.CELL_TYPE_STRING:                            System.out.print(&quot;String - &quot;);                            cellValue = cell.getStringCellValue();                            break;                        case HSSFCell.CELL_TYPE_BOOLEAN:                            System.out.print(&quot;Boolean - &quot;);                            cellValue = String.valueOf(cell.getBooleanCellValue());                            break;                        case HSSFCell.CELL_TYPE_BLANK:                            System.out.print(&quot;Blank&quot;);                            break;                        case HSSFCell.CELL_TYPE_NUMERIC:                            System.out.print(&quot;Numeric - &quot;);                            if(HSSFDateUtil.isCellDateFormatted(cell))&#123;                                System.out.print(&quot;Date - &quot;);                                Date date = cell.getDateCellValue();                                cellValue = new DateTime(date).toString(&quot;yyyy-MM-dd&quot;);                            &#125;else &#123;                                System.out.print(&quot;Number - &quot;);                                cell.setCellType(HSSFCell.CELL_TYPE_STRING); // 防止数字过长，转化为字符串类型                                cellValue = cell.toString();                            &#125;                            break;                        case HSSFCell.CELL_TYPE_ERROR:                            System.out.println(&quot;Error&quot;);                            break;                    &#125;                    System.out.println(cellValue);                &#125;            &#125;        &#125;    &#125;    fileInputStream.close();&#125;\n\n计算公式\n@Testpublic void testFormula() throws IOException &#123;    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;公式.xls&quot;);    Workbook workbook = new HSSFWorkbook(fileInputStream);    Sheet sheet = workbook.getSheetAt(0);    Row row = sheet.getRow(1);    Cell cell = row.getCell(1);    // 拿到计算公式eval    FormulaEvaluator FormulaEvaluator = new HSSFFormulaEvaluator((HSSFWorkbook)workbook);        // 输出单元格的内容    int cellType = cell.getCellType();    switch(cellType)&#123;        case Cell.CELL_TYPE_FORMULA:            String formula = cell.getCellFormula();            System.out.println(formula);            // 计算            CellValue evaluate = FormulaEvaluator.evaluate(cell);            String cellValue = evaluate.formatAsString();            System.out.println(cellValue);            break;    &#125;    fileInputStream.close();&#125;\n\nEasyExcel\nEasyExcel重写了POI对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。\n\n官网：https://github.com/alibaba/easyexcel/\nEasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行一行读取数据，逐个解析。\n\n官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n导入依赖\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;    &lt;version&gt;2.2.6&lt;/version&gt;&lt;/dependency&gt;\n\nEasyExcel操作写入操作：固定类格式进行写入\nhttps://www.yuque.com/easyexcel/doc/write\n读取操作：根据监听器设置规则进行读取\nhttps://www.yuque.com/easyexcel/doc/read\n","tags":["Java","Excel"]},{"title":"LeetCode 222.完全二叉树的节点个数","url":"/2020/11/24/LeetCode222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","content":"题目描述：\n给出一个完全二叉树，求出该树的节点个数。\n示例：\n输入: [1,2,3,4,5,6]输出: 6\n解法一：简单递归\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null)&#123;            return 0;        &#125;        return countNodes(root.left) + countNodes(root.right) + 1;    &#125;&#125;\n\n但是解法一考虑到完全二叉树的性质。\n解法二：二分查找+位运算\n思路：首先求出二叉树高度，再根据二叉树高度算出节点个数范围，二分查找范围内中间节点，根据位运算判断中间节点是否存在。\n\nclass Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125;        int level = 0;        TreeNode node = root;        while (node.left != null) &#123;            level++;            node = node.left;        &#125;        int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1; // 2^n 可以写成 1&lt;&lt;n        while (low &lt; high) &#123;            int mid = (high - low + 1) / 2 + low;            if (exists(root, level, mid)) &#123;                low = mid;            &#125; else &#123;                high = mid - 1;            &#125;        &#125;        return low;    &#125;    public boolean exists(TreeNode root, int level, int k) &#123;        int bits = 1 &lt;&lt; (level - 1);        TreeNode node = root;        while (node != null &amp;&amp; bits &gt; 0) &#123;            if ((bits &amp; k) == 0) &#123;                node = node.left;            &#125; else &#123;                node = node.right;            &#125;            bits &gt;&gt;= 1;        &#125;        return node != null;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/\n","tags":["算法","LeetCode","位运算","二叉树","二分查找"]},{"title":"Spring5教程","url":"/2020/11/24/Spring5%E6%95%99%E7%A8%8B/","content":"1 Spring框架简介雏形：interface21框架\n创始人：Rod Johnson\n目标：解决企业级应用开发的复杂性，简化Java开发。\n文档地址：https://docs.spring.io/spring-framework/docs/current/reference/html/core.htmlhttps://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/\n下载地址：https://repo.spring.io/release/org/springframework/spring/\nGitHub：https://github.com/spring-projects/spring-framework\n&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n优点：开源免费，轻量级，非入侵式，支持事务处理，Java框架整合\n最大特性：控制反转（IOC），面向切面编程（AOP）\n总结：Spring是一个轻量级的控制反转和面向切面编程的框架\nSpring七大模块：\n\nSpring Boot\n\n快速开发的脚手架\n基于Spring Boot可以快速开发单个微服务\n约定大于配置\n\nSpring Cloud\n\n基于Spring Boot实现的\n\n弊端：”配置地狱“\n2 IOC理论推导2.1 IOC原型问题：需要根据用户需求修改源代码\n解决方法：使用set实现动态值注入\nprivate UserDao userDao;// 利用set进行动态实现值的注入public void setUserDao(UserDao userDao)&#123;    this.userDao = userDao;&#125;\n\n变化：程序主动创建对象 → 被动接受对象\n2.2 IOC本质控制反转IoC是一种设计思想，DI（依赖注入）是实现IoC的一种方法。面向对象编程中，对象的创建与对象间的依赖关系完全编写在程序中，由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是获得依赖对象的方式反转了。\n采用XML方式配置Bean的时候，Bean的定义是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入。\n3 HelloSpring创建类\npublic class Hello &#123;    String str;    public String getStr() &#123;        return str;    &#125;    public void setStr(String str) &#123;        this.str = str;    &#125;    @Override    public String toString() &#123;        return &quot;Hello&#123;&quot; +                &quot;str=&#x27;&quot; + str + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nSpring配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--bean：对象 id：变量名 class：类 property：类的属性 value：属性的值（基本数据类型） ref：引用其他创建的bean--&gt;    &lt;bean id=&quot;hello&quot; class=&quot;com.zhg.pojo.Hello&quot;&gt;        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试\nimport com.zhg.pojo.Hello;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123;    public static void main(String[] args) &#123;        // 获取Spring的上下文对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Hello hello = (Hello) context.getBean(&quot;hello&quot;);        System.out.println(hello.toString());    &#125;&#125;\n\n总结：\n\nSpring容器可以创建对象并设置对象属性的值\n依赖注入是利用类的set方法实现的\n\n4 IOC创建对象的方式\n使用无参构造创建对象（默认）\n\n使用有参构造创建对象\n\n参数下标\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n参数类型\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n参数名\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n\n\n\n\n总结：在配置文件加载的时候，Spring容器中管理的对象就已经初始化了！\n5 Spring配置5.1 别名&lt;!--可以通过别名获取到对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;&gt;&lt;/alias&gt;\n\n5.2 bean的配置&lt;!--\tid：bean的唯一标识，相当于对象名\tclass：包名+类型\tname：也是别名，可以同时取多个别名--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; name=&quot;user2 u2,u3;u4&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n5.3 importimport一般用于团队开发使用，可以将多个配置文件导入合并为一个。\napplicationContext.xml\n&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt;\n\n6 依赖注入6.1 构造器注入上文已经说过（4 IOC创建对象的方式）\n6.2 Set方式注入依赖注入\n\n依赖：bean对象的创建依赖于容器\n注入：bean对象的所有属性由容器来注入\n\nStudent实体类\npublic class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbys;    private Map&lt;String,String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    ...&#125;\n\napplicationContext.xml\n&lt;bean id=&quot;address&quot; class=&quot;com.zhg.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;...&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.zhg.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt;    &lt;!--数组注入--&gt;    &lt;property name=&quot;books&quot;&gt;    \t&lt;array&gt;            &lt;value&gt;book1&lt;/value&gt;            &lt;value&gt;book2&lt;/value&gt;            &lt;value&gt;book3&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name=&quot;hobbys&quot;&gt;    \t&lt;list&gt;            &lt;value&gt;hobby1&lt;/value&gt;            &lt;value&gt;hobby2&lt;/value&gt;            &lt;value&gt;hobby3&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--Map注入--&gt;    &lt;property name=&quot;card&quot;&gt;    \t&lt;map&gt;            &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;games&quot;&gt;    \t&lt;set&gt;            &lt;value&gt;hobby1&lt;/value&gt;            &lt;value&gt;hobby2&lt;/value&gt;            &lt;value&gt;hobby3&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!--null值注入--&gt;    &lt;property name=&quot;wife&quot;&gt;    \t&lt;null&gt;&lt;/null&gt;    &lt;/property&gt;    &lt;!--属性注入--&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;        \t&lt;prop key=&quot;pk1&quot;&gt;pv1&lt;/prop&gt;        \t&lt;prop key=&quot;pk2&quot;&gt;pv2&lt;/prop&gt;        \t&lt;prop key=&quot;pk3&quot;&gt;pv3&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n6.3 其他方式注入p命名空间注入&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;    &lt;/bean&gt;    &lt;bean name=&quot;john-modern&quot;        class=&quot;com.example.Person&quot;        p:name=&quot;John Doe&quot;        p:spouse-ref=&quot;jane&quot;/&gt;    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nc命名空间注入&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;    &lt;!-- traditional declaration with optional argument names --&gt;    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;        &lt;constructor-arg name=&quot;email&quot; value=&quot;[email protected]&quot;/&gt;    &lt;/bean&gt;    &lt;!-- c-namespace declaration with argument names --&gt;    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;[email protected]&quot;/&gt;&lt;/beans&gt;\n\n注意点：p命名空间和c命名空间不能直接使用，需要导入xml约束\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n\n6.4 bean的作用域\n\n\nScope\nDescription\n\n\n\nsingleton\n(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.\n\n\nprototype\nScopes a single bean definition to any number of object instances.\n\n\nrequest\nScopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nsession\nScopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\napplication\nScopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nwebsocket\nScopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\n单例模式（默认）Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，每次获取到的对象都是同一个对象。\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;XXX&quot; scope=&quot;singleton&quot;/&gt;\n\n原型模式Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; scope=&quot;prototype&quot;/&gt;\n\n其他\n其余的request、session、application等只能在Web开发中使用！\n7 Bean的自动装配\n自动装配是使用spring满足bean依赖的一种方法\nspring会在应用上下文中为某个bean寻找其依赖的bean\n\nSpring中bean有三种装配机制，分别是：\n\n在xml中显式配置；\n在java中显式配置；\n隐式的bean发现机制和自动装配。\n\nbeans.xml显示配置\n&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n7.1 byName自动装配&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; autowire=&quot;byName&quot;&gt;   &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n当一个bean节点带有 autowire byName的属性时。\n\n将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。\n去spring容器中寻找是否有此字符串名称id的对象。\n如果有，就取出注入；如果没有，就报空指针异常。\n\n7.2 byType自动装配&lt;bean class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; autowire=&quot;byType&quot;&gt;   &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n使用autowire byType需要保证：同一类型的对象，在spring容器中唯一！\n7.3 注解自动装配jdk1.5开始支持注解，spring2.5开始全面支持注解。\n准备工作：利用注解的方式注入属性。\n\n在spring配置文件中引入context文件头\n\n开启属性注解支持！\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n@Autowired\n@Autowired是按类型自动转配的，不支持id匹配；\n\n可以直接在类的属性名上使用，也可以在set方法上使用；\n\n可以不写set方法；\n\n需要导入spring-aop的包！\n\n\n@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat;\n\n@Qualifier\n@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配；\n@Qualifier不能单独使用。\n\nbeans.xml\n&lt;bean id=&quot;dog1&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;/&gt;\n\n实体类属性上添加注解\npublic class User &#123;\t@Autowired    @Qualifier(value = &quot;cat2&quot;)    private Cat cat;    @Autowired    @Qualifier(value = &quot;dog2&quot;)    private Dog dog;&#125;\n\n@Resource\n@Resource如有指定的name属性，先按该属性进行byName方式查找装配；\n其次再进行默认的byName方式进行装配；\n如果以上都不成功，则按byType的方式自动装配。\n都不成功，则报异常。\n\nbeans.xml\n&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;/&gt;\n\n实体类属性上添加注解\npublic class User &#123;   //如果允许对象为null，设置required = false,默认为true   @Resource(name = &quot;cat2&quot;)   private Cat cat;   @Resource   private Dog dog;   private String str;&#125;\n\n小结\n@Autowired与@Resource异同：\n\n@Autowired与@Resource都可以用来装配bean。都可以写在属性上，或写在setter方法上。\n\n@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n\n@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n\n\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n8 使用注解开发在spring4之后，想要使用注解形式，必须得要引入aop的包\n；在配置文件当中，还得要引入一个context约束。\n\nbean的实现\nbeans.xml配置扫描哪些包下的注解\n&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.zhg.pojo&quot;/&gt;\n\n在指定包下编写类，增加注解\n@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;   public String name = &quot;XXX&quot;;&#125;\n\n属性注入\n可以不用提供set方法，直接在直接名上添加@Value(“值”)\n@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;   @Value(&quot;XXX&quot;)   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;   public String name;&#125;\n\n如果提供了set方法，也可在set方法上添加@Value(“值”)\n\n衍生注解\n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。写上这些注解，就相当于将这个类交给Spring管理装配了！\n\n@Controller：web层\n@Service：service层\n@Repository：dao层\n\n\n自动装配\n@AutoWired，@Qualified，@Resource，详见上文。\n\n作用域\n@Scope(“singleton/prototype”)\n\n\n小结\nXML与注解比较\n\nXML可以适用任何场景 ，结构清晰，维护方便\n注解不是自己提供的类使用不了，开发简单方便\n\nxml与注解整合开发 （推荐最佳实践）\n\nxml管理bean\n注解完成属性注入\n使用过程中， 可以不用扫描，扫描是为了类上的注解\n\n&lt;context:annotation-config/&gt;作用：\n\n进行注解驱动注册，从而使注解生效\n用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册\n如果不扫描包，就需要手动配置bean\n如果不加注解驱动，则注入的值为null！\n\n基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。\nDog实体类\n@Component  //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123;   public String name = &quot;dog&quot;;&#125;\n\nMyConfig配置类\n@Configuration  //代表这是一个配置类public class MyConfig &#123;   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！   public Dog dog()&#123;       return new Dog();  &#125;&#125;\n\n测试\n@Testpublic void test()&#123;   ApplicationContext applicationContext =           new AnnotationConfigApplicationContext(MyConfig.class);   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);   System.out.println(dog.name);&#125;\n\n9 代理模式代理模式是Spring AOP的底层\n代理模式的分类：\n\n静态代理\n动态代理\n\n9.1 静态代理角色分析：\n\n抽象角色：一般使用接口或抽象类来解决\n真实角色：被代理的角色\n代理角色：代理真实角色，一般会做一些附属操作\n客户：访问代理对象的人\n\n代理模式的好处：\n\n可以使真实角色的操作更加纯粹，不用关注一些公共的业务\n公共业务交给代理角色，实现了业务的分工\n公共业务发生扩展的时候，方便集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低。\n\n9.2 动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是直接写好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口——JDK动态代理\n基于类：cglib\nJava字节码实现：JAVAssist\n\n\n\n需要了解两个类：Proxy，InvocationHandler\n【InvocationHandler：调用处理程序】\nInvocationHandler是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。\nObject invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。\n\n【Proxy  : 代理】\nProxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理对象的超类。\n//生成代理类//public static Object newProxyInstance(Classloader loader,类&lt;&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException//loader - 类加载器来定义代理类//interfaces - 代理类实现的接口列表//h - 调度方法调用的调用处理程序public Object getProxy()&#123;   return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);&#125;\n\n代码实现：\nRent - 抽象角色\n//抽象角色：租房public interface Rent &#123;   public void rent();&#125;\n\nHost  - 真实角色\n//真实角色：房东，房东要出租房子public class Host implements Rent&#123;   public void rent() &#123;       System.out.println(&quot;房屋出租&quot;);  &#125;&#125;\n\nProxyInvocationHandler - 代理角色\npublic class ProxyInvocationHandler implements InvocationHandler &#123;   private Rent rent;   public void setRent(Rent rent) &#123;       this.rent = rent;  &#125;   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色   public Object getProxy()&#123;       return Proxy.newProxyInstance(this.getClass().getClassLoader(),               rent.getClass().getInterfaces(),this);  &#125;   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.   // 处理代理实例上的方法调用并返回结果   @Override   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;       seeHouse();       //核心：本质利用反射实现！       Object result = method.invoke(rent, args);       fare();       return result;  &#125;   //看房   public void seeHouse()&#123;       System.out.println(&quot;带房客看房&quot;);  &#125;   //收中介费   public void fare()&#123;       System.out.println(&quot;收中介费&quot;);  &#125;&#125;\n\nClient - 租客\n//租客public class Client &#123;   public static void main(String[] args) &#123;       //真实角色       Host host = new Host();       //代理实例的调用处理程序       ProxyInvocationHandler pih = new ProxyInvocationHandler();       pih.setRent(host); //将真实角色放置进去！       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！       proxy.rent();  &#125;&#125;\n\n核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！\n动态代理的好处：\n\n可以使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 ；\n公共的业务由代理来完成 ，实现了业务的分工 ；\n公共业务发生扩展时变得更加集中和方便 ；\n一个动态代理 , 一般代理某一类业务；\n一个动态代理可以代理多个类，代理的是接口。\n\n10 AOPAOP（Aspect Oriented Programming），即面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\nAOP的相关概念：\n\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….\n切面（ASPECT）：横切关注点，被模块化的特殊对象。即，它是一个类。\n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。\n目标（Target）：被通知对象。\n代理（Proxy）：向目标对象应用通知之后创建的对象。\n切入点（PointCut）：切面通知 执行的“地点”的定义。\n连接点（JointPoint）：与切入点匹配的执行点。\n\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice。\n\n使用Spring实现Aop\n使用AOP织入，需要导入一个依赖包！\n&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n业务接口和实现类\npublic interface UserService &#123;   public void add();   public void delete();   public void update();   public void search();&#125;public class UserServiceImpl implements UserService&#123;   @Override   public void add() &#123;       System.out.println(&quot;增加用户&quot;);  &#125;   @Override   public void delete() &#123;       System.out.println(&quot;删除用户&quot;);  &#125;   @Override   public void update() &#123;       System.out.println(&quot;更新用户&quot;);  &#125;   @Override   public void search() &#123;       System.out.println(&quot;查询用户&quot;);  &#125;&#125;\n\n10.1 Spring API实现增强类：前置增强和后置增强\npublic class Log implements MethodBeforeAdvice &#123;   //method : 要执行的目标对象的方法   //objects : 被调用的方法的参数   //Object : 目标对象   @Override   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);  &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123;   //returnValue 返回值   //method被调用的方法   //args 被调用的方法的对象的参数   //target 被调用的目标对象   @Override   public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable &#123;       System.out.println(&quot;执行了&quot; + target.getClass().getName()       +&quot;的&quot;+method.getName()+&quot;方法,&quot;       +&quot;返回值：&quot;+returnValue);  &#125;&#125;\n\nspring的文件中注册bean , 并实现aop切入实现 , 注意导入约束 。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;   &lt;!--注册bean--&gt;   &lt;bean id=&quot;userService&quot; class=&quot;com.zhg.service.UserServiceImpl&quot;/&gt;   &lt;bean id=&quot;log&quot; class=&quot;com.zhg.log.Log&quot;/&gt;   &lt;bean id=&quot;afterLog&quot; class=&quot;com.zhg.log.AfterLog&quot;/&gt;   &lt;!--aop的配置--&gt;   &lt;aop:config&gt;       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;   &lt;/aop:config&gt;&lt;/beans&gt;\n\n测试\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;); // 接口！！！       userService.search();  &#125;&#125;\n\nSpring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来，实现公共业务的重复利用 。领域业务更纯粹，程序猿专注领域业务，其本质还是动态代理。\n10.2 自定义类实现自定义切入类\npublic class DiyPointcut &#123;   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   &#125;\n\nspring配置\n&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.zhg.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt;   &lt;!--第二种方式：使用AOP的标签实现--&gt;   &lt;aop:aspect ref=&quot;diy&quot;&gt;       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n测试：\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;);       userService.add();  &#125;&#125;\n\n10.3 注解实现注解实现的增强类\npackage com.zhg.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123;   @Before(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   @After(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   @Around(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void around(ProceedingJoinPoint jp) throws Throwable &#123;       System.out.println(&quot;环绕前&quot;);       System.out.println(&quot;签名:&quot;+jp.getSignature());       //执行目标方法proceed       Object proceed = jp.proceed();       System.out.println(&quot;环绕后&quot;);       System.out.println(proceed);  &#125;&#125;\n\nSpring配置文件中注册bean并增加支持注解的配置\n&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.zhg.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt;\n\n&lt;aop:aspectj-autoproxy/&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。其中有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当该属性为true时，表示使用CGLib动态代理技术织入增强。\n11 整合MyBatismaven导入相关jar包\n&lt;!--MyBatis和MySQL--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;   &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring相关--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectJ AOP 织入器--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-spring整合包--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;   &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--其他--&gt;&lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;\n\nmaven静态资源过滤配置\n&lt;build&gt;   &lt;resources&gt;       &lt;resource&gt;           &lt;directory&gt;src/main/java&lt;/directory&gt;           &lt;includes&gt;               &lt;include&gt;**/*.properties&lt;/include&gt;               &lt;include&gt;**/*.xml&lt;/include&gt;           &lt;/includes&gt;           &lt;filtering&gt;true&lt;/filtering&gt;       &lt;/resource&gt;   &lt;/resources&gt;&lt;/build&gt;\n\nmybatis-spring文档地址：http://mybatis.org/spring/zh/index.html\n11.1 整合实现一要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。\n\n使用SqlSessionFactoryBean创建SqlSessionFactory\n&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;   &lt;!--关联Mybatis--&gt;   &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/zhg/dao/*.xml&quot;/&gt;&lt;/bean&gt;\n\n配置数据源替换mybaits的数据源\n&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;   &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;\n\n注册sqlSessionTemplate\n&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;   &lt;!--利用构造器注入--&gt;   &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n增加Dao接口的实现类\npublic class UserDaoImpl implements UserMapper &#123;   //sqlSession不用我们自己创建了，Spring来管理   private SqlSessionTemplate sqlSession;   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;       this.sqlSession = sqlSession;  &#125;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = sqlSession.getMapper(UserMapper.class);       return mapper.selectUser();  &#125; &#125;\n\n注册bean实现\n&lt;bean id=&quot;userDao&quot; class=&quot;com.zhg.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\n测试\n@Testpublic void test()&#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);    List&lt;User&gt; user = mapper.selectUser();    System.out.println(user);&#125;\n\n\n\nmybatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;typeAliases&gt;       &lt;package name=&quot;com.zhg.pojo&quot;/&gt;   &lt;/typeAliases&gt;&lt;/configuration&gt;\n\n11.2 整合实现二第二种整合实现方法，mybatis-spring需要1.2.3版以上。\ndao继承Support类，直接利用 getSqlSession() 获得，然后直接注入SqlSessionFactory。比起方式1，不需要管理SqlSessionTemplate , 而且对事务的支持更加友好。\n将上文的UserDaoImpl修改一下\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);       return mapper.selectUser();  &#125;&#125;\n\n修改bean的配置\n&lt;bean id=&quot;userDao&quot; class=&quot;com.zhg.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;\n\n12 声明式事务事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用，用来确保数据的完整性和一致性。\n事务满足四个属性ACID（原子性，一致性，隔离性，持久性）\nSpring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式事务管理（AOP）。\n头文件tx**约束导入\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n事务管理器\n&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;\n\n事务的通知（Advice）配置\n&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;   &lt;tx:attributes&gt;       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;   &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n配置AOP\n&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt;   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.zhg.dao.*.*(..))&quot;/&gt;   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt;\n\n事务传播行为（propagation）是指多个事务方法相互调用时，事务在这些方法间的传播方式。Spring 支持 7 种事务传播行为（Transaction Propagation Behavior）：\n\n\n\n传播行为\n描述\n\n\n\nPROPAGATION_REQUIRED\n如果没有，就开启一个事务；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）\n\n\nRROPAGATION_REQUIRES_NEW\n如果没有，就开启一个事务；如果有，就将当前事务挂起。（方法A所在的事务就会挂起，方法B会起一个新的事务，等待方法B的事务完成以后，方法A才继续执行）\n\n\nPROPAGATION_NESTED\n如果没有，就开启一个事务；如果有，就在当前事务中嵌套其他事务\n\n\nPROPAGATION_SUPPORTS\n如果没有，就以非事务方式执行；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）\n\n\nPROPAGATION_NOT_SUPPORTED\n如果没有，就以非事务方式执行；如果有，就将当前事务挂起，（方法A所在的事务就会挂起，而方法B以非事务的状态运行完，再继续方法A的事务）\n\n\nPROPAGATION_NEVER\n如果没有，就以非事务方式执行；如果有，就抛出异常。\n\n\nPROPAGATION_MANDATORY\n如果没有，就抛出异常；如果有，就使用当前事务\n\n\n","tags":["Java","SSM框架","Spring"]},{"title":"Vue入门","url":"/2020/12/09/Vue%E5%85%A5%E9%97%A8/","content":"HTML+CSS+JS 视图：给用户看，刷新后台给的数据\n网络通信：axios\n页面跳转：vue-router\n状态管理：vuex\nVue-UI：ICE\n官网：https://cn.vuejs.org/\nVM：数据双向绑定\n虚拟DOM：利用内存\nVue集大成者：MVVM+DOM\nvue-element-admin：https://panjiachen.github.io/vue-element-admin-site/zh/\nVue下载地址\n开发版本：\nhttps://vuejs.org/js/vue.js\nhttps://vuejs.org/js/vue.min.js\nCDN：\nhttps://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\nhttps://cdn.bootcss.com/vue/2.5.16/vue.min.js\n1 Vue基础语法v-bind attribute 被称为指令，指令带有前缀v-\n条件：v-if\n循环：v-for\n事件：v-on\n组件：Vue.component\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app-7&quot;&gt;        &lt;ol&gt;            &lt;!--              现在我们为每个 todo-item 提供 todo 对象              todo 对象是变量，即其内容可以是动态的。            --&gt;            &lt;todo-item                    v-for=&quot;item in groceryList&quot;                    v-bind:todo=&quot;item&quot;                    v-bind:key=&quot;item.id&quot;            &gt;&lt;/todo-item&gt;        &lt;/ol&gt;    &lt;/div&gt;    &lt;script&gt;        Vue.component(&#x27;todo-item&#x27;, &#123;            props: [&#x27;todo&#x27;],            template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;        &#125;)            var app7 = new Vue(&#123;            el: &#x27;#app-7&#x27;,            data: &#123;                groceryList: [                    &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                    &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                    &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;                ]            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n2 网络通信JQuery，Ajax\nAxios 文档地址：http://www.axios-js.com/zh-cn/docs/\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;vue&quot;&gt;        &lt;div&gt;&#123;&#123;info.name&#125;&#125;&lt;/div&gt;        &lt;div&gt;&#123;&#123;info.address.street&#125;&#125;&lt;/div&gt;        &lt;a v-bind:href=&quot;info.url&quot;&gt;点我&lt;/a&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue(&#123;            el: &#x27;#vue&#x27;,            data()&#123;                return &#123;                    info: &#123;                        name: null,                        address: &#123;                            country: null,                            city: null,                            street: null                        &#125;,                        url: null                    &#125;                &#125;            &#125;,            mounted()&#123;                axios                    .get(&#x27;data.json&#x27;)                    .then(response =&gt; (this.info = response.data))            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\ndata.json\n&#123;  &quot;name&quot;:&quot;XXX&quot;,  &quot;url&quot;: &quot;http://baidu.com&quot;,  &quot;page&quot;: &quot;1&quot;,  &quot;isNonProfit&quot;:&quot;true&quot;,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;含光门&quot;,    &quot;city&quot;:&quot;陕西西安&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;,  &quot;links&quot;: [    &#123;      &quot;name&quot;: &quot;B站&quot;,      &quot;url&quot;: &quot;https://www.bilibili.com/&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;4399&quot;,      &quot;url&quot;: &quot;https://www.4399.com/&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;百度&quot;,      &quot;url&quot;: &quot;https://www.baidu.com/&quot;    &#125;  ]&#125;\n\n3 计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，应当使用计算属性。\n计算属性缓存 vs 方法\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;example&quot;&gt;        &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessageF() &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Timestamp now:&quot;&#123;&#123; nowF() &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Computed timestamp now:&quot;&#123;&#123; now &#125;&#125;&quot;&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue(&#123;            el: &#x27;#example&#x27;,            data: &#123;                message: &#x27;Hello&#x27;            &#125;,            // 在组件中            methods: &#123;                reversedMessageF: function () &#123;                    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;,                nowF: function () &#123;                    return Date.now()                &#125;            &#125;,            computed: &#123;                // 计算属性的 getter                reversedMessage: function () &#123;                    // `this` 指向 vm 实例                    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;,                now: function () &#123;                    return Date.now()                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。每当触发重新渲染时，调用方法将总会再次执行函数。\n为什么需要缓存？假设有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。可能有其他的计算属性依赖于 A。如果没有缓存，将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n4 插槽slotVue 实现了一套内容分发的 API，将 &lt;slot&gt; 元素作为承载分发内容的出口。可以把 slot 理解成一个占位符，当在子组件定义好一个 slot 标签，父组件传值时就会替换该标签内容。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;list&gt;        &lt;h1&gt;该数据不会被显示&lt;/h1&gt;        &lt;listname slot=&quot;listname&quot; v-bind:tit=&quot;tit&quot;&gt;&lt;/listname&gt;        &lt;item slot=&quot;item&quot; v-for=&quot;item in groceryList&quot; v-bind:item=&quot;item&quot;&gt;&lt;/item&gt;    &lt;/list&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;list&#x27;, &#123;        template: &#x27;&lt;div&gt;\\                    &lt;slot name=&quot;listname&quot;&gt;&lt;/slot&gt;\\                    &lt;ul&gt;\\                        &lt;slot name=&quot;item&quot;&gt;&lt;/slot&gt;\\                    &lt;/ul&gt;\\                    &lt;/div&gt;&#x27;    &#125;);    Vue.component(&#x27;item&#x27;, &#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&#x27;    &#125;)    Vue.component(&#x27;listname&#x27;, &#123;        props: [&#x27;tit&#x27;],        template: &#x27;&lt;p&gt;&#123;&#123; tit &#125;&#125;&lt;/p&gt;&#x27;    &#125;);    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            groceryList: [                &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;            ],            tit: &#x27;购物清单&#x27;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n如果&lt;list&gt;的template中没有包含一个&lt;slot&gt;元素,则该组件起始标签和结束标签之间的任何内容都会被抛弃。\n5 自定义事件组件内方法要操作Vue实例中的数据，可以在Vue实例中创建方法操作数据，通过HTML视图将实例中的方法赋给一个中间值（自定义事件），在组件内可以通过.$emit(eventName, […args])调用自定义事件。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;list&gt;        &lt;listname slot=&quot;listname&quot; :tit=&quot;tit&quot;&gt;&lt;/listname&gt;        &lt;item slot=&quot;item&quot; v-for=&quot;item in groceryList&quot; :item=&quot;item&quot; @remove=&quot;removeItem(item.id)&quot;&gt;&lt;/item&gt;    &lt;/list&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;list&#x27;, &#123;        template: `&lt;div&gt;                    &lt;slot name=&quot;listname&quot;&gt;&lt;/slot&gt;                    &lt;ul&gt;                        &lt;slot name=&quot;item&quot;&gt;&lt;/slot&gt;                    &lt;/ul&gt;                    &lt;/div&gt;`    &#125;);    Vue.component(&#x27;item&#x27;, &#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123;item.id&#125;&#125;---&#123;&#123; item.text &#125;&#125; &lt;button @click=&quot;rm&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            rm:function (index) &#123;                this.$emit(&#x27;remove&#x27;,index);            &#125;        &#125;    &#125;)    Vue.component(&#x27;listname&#x27;, &#123;        props: [&#x27;tit&#x27;],        template: &#x27;&lt;p&gt;&#123;&#123; tit &#125;&#125;&lt;/p&gt;&#x27;    &#125;);    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            groceryList: [                &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                &#123; id: 2, text: &#x27;其它&#x27; &#125;            ],            tit: &#x27;购物清单&#x27;        &#125;,        methods:&#123;            removeItem:function (index) &#123;                console.log(&quot;删除了&quot;+this.groceryList[index]);                this.groceryList.splice(index,1);            &#125;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n6 Vue-CliVue-cli 是一个官方提供的脚手架，用于快速生成一个Vue的项目模板。\n主要功能：\n\n统一的目录结构\n本地调试\n热部署\n单元测试\n集成打包上线\n\n需要提前下载安装Node.js以及淘宝镜像加速器（cnpm）\nnpm install cnpm -g# 或者npm install cnpm -g --registry=https://registry.npm.taobao.org\n\n项目搭建：在Vue项目文件夹下创建一个基于webpack模板的vue应用程序\n# myvue是项目名vue init webpack myvue\n\n然后一路选no即可；\n初始化并运行项目：\ncd myvuenpm install # 可使用cnpm加快速度npm run dev\n\n7 WebpackWebpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。\n安装webpack\nnpm install webpack -gnpm install webpack-cli -g\n\n使用webpack\n\n新建项目并在项目下创建modules文件夹，用于放置JS模块等资源文件；\n项目目录\n\n\n在modules文件夹下创建模块文件（hello.js，main.js）；\nhello.js\n//exports暴露一个方法exports.sayHi = function()&#123;    document.write(&quot;&lt;h1&gt;Webpack test&lt;/h1&gt;&quot;)&#125;\n\nmain.js\n//require导入一个模块var hello = require(&quot;./hello&quot;);hello.sayHi();\n\n在项目目录下创建webpack.config.js配置文件，使用webpack命令打包；\nwebpack.config.js\nmodule.exports = &#123;    entry:&#x27;./modules/main.js&#x27;,    output:&#123;        filename:&#x27;./js/bundle.js&#x27;    &#125;&#125;\n\nwebpack打包\n\n\n在项目目录下创建HTML页面（index.html）,导入webpack打包后的js文件。\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--前端的模块化开发--&gt;&lt;script src=&quot;dist/js/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n8 Vue-Router\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。\n\nVue-Router包含的功能有：\n\n嵌套的路由/视图表\n模块化的、基于组件的路由配置\n路由参数、查询、通配符\n基于 Vue.js 过渡系统的视图过渡效果\n细粒度的导航控制\n带有自动激活的 CSS class 的链接\nHTML5 历史模式或 hash 模式，在 IE9 中自动降级\n自定义的滚动条行为\n\n使用步骤：\n\n使用vue-cli搭建一个基于webpack模板的vue应用程序；\n\n新建components目录，存放编写的组件（Content.vue）；\nContent.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;内容页&lt;&#x2F;h1&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Content&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n在项目目录下使用cnpm install vue-router --save-dev命令安装vue-router；\n\n\n在src目录下新建一个文件夹router，专门存放路由；\nindex.js\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;//导入组件import Content from &#x27;../components/Content&#x27;//安装路由Vue.use(Router);//配置路由export default new Router(&#123;  routes:[    &#123;      path:&#x27;/content&#x27;,      component:Content    &#125;  ]&#125;)\n\n在main.js文件中导入并配置路由；\nmain.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import VueRouter from &#x27;vue-router&#x27;import  router from &#x27;./router&#x27;Vue.config.productionTip = false//显示声明使用VueRouterVue.use(VueRouter);new Vue(&#123;  el: &#x27;#app&#x27;,  //配置路由  router,  components: &#123; App &#125;,  template: &#x27;&lt;App/&gt;&#x27;&#125;)\n\n在App.vue中使用路由。\nApp.vue\n&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h1&gt;Hi&lt;&#x2F;h1&gt;    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容页&lt;&#x2F;router-link&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;,&#125;&lt;&#x2F;script&gt;&lt;style&gt;#app &#123;  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;&#x2F;style&gt;\n\n\n\n参数传递\n前端URL提交数据：\n&lt;!-- 命名的路由 --&gt;&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;this.$router.push(&quot;&#x2F;user&#x2F;&quot;+this.form.userid);\n\n参数传递路由配置（接受参数）：\nroutes:[    &#123;        path:&#x27;/user/:userId&#x27;，        name:&#x27;user&#x27;,        component:User,        props:true    &#125;]\n\n前端展示数据：\n&lt;template&gt;\t&#123;&#123;$router.params.userId&#125;&#125;\t&#123;&#123;userId&#125;&#125; &lt;&#x2F;template&gt;&lt;sript&gt;\texports default&#123;    \tprops:[&#39;userId&#39;],    \tname:&quot;User&quot;    \t    &#125;&lt;&#x2F;sript&gt;\n\n路由模式\n路由模式有两种：\n\nhash：路径带”#“（http://localhost/#/login）\nhistory：路径不带”#“（http://localhost/login）\n\n修改配置路由\nexport default new Router(    &#123;        mode:&#x27;history&#x27;,        routes:[                    ]    &#125;);\n\n\n\n重定向\nroutes:[    &#123;        path:&#x27;/goHome&#x27;，        redirect:&#x27;/main&#x27;    &#125;]\n\n404\nroutes:[    ...,    &#123;        path:*，        redirect:&#x27;/NotFound&#x27;    &#125;]\n\n嵌套路由：URL 中各段动态路径也按某种结构对应嵌套的各层组件。\n/user/foo/profile                     /user/foo/posts+------------------+                  +-----------------+| User             |                  | User            || +--------------+ |                  | +-------------+ || | Profile      | |  +------------&gt;  | | Posts       | || |              | |                  | |             | || +--------------+ |                  | +-------------+ |+------------------+                  +-----------------+\n\n配置嵌套路由（children属性）\nexport default new Router(&#123;   routes: [    &#123; path: &#x27;/user/:id&#x27;, component: User,      children: [        &#123;          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中          path: &#x27;profile&#x27;,          component: UserProfile        &#125;,        &#123;          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中          path: &#x27;posts&#x27;,          component: UserPosts        &#125;      ]    &#125;  ]&#125;);\n\n9 ElementUIElementUI是由饿了么开发的一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。\n测试：\n\n使用vue-cli搭建一个基于webpack模板的vue应用程序（vue init webpack 项目名）；\n\n安装依赖，安装需要的插件（vue-router, element-ui, sass-loader, node-sass）；\ncd 项目名cnpm install vue-router --save-devcnpm i element-ui -Scnpm install #安装依赖cnpm install sass-loader node-sass --save-devnpm run dev\n\n新建views目录，存放编写的视图（Main.vue，Login.vue）；\nLogin.vue\n&lt;template&gt;  &lt;div&gt;      &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;        &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;        &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;          &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;          &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;        &lt;&#x2F;el-form-item&gt;      &lt;&#x2F;el-form&gt;    &lt;el-dialog      title&#x3D;&quot;温馨提示&quot;      :visible.sync&#x3D;&quot;dialogVisible&quot;      width&#x3D;&quot;30%&quot;      :before-close&#x3D;&quot;handleClose&quot;&gt;      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;      &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export  default &#123;        name:&quot;Login&quot;,        data()&#123;            return &#123;                form:&#123;                    username: &#39;&#39;,                    password: &#39;&#39;                &#125;,                &#x2F;&#x2F;表单验证，需要再el-form-item 元素中增加prop属性                rules:&#123;                    username:[            &#123;required:true,message:&#39;账号不能为空&#39;,trigger:&#39;blur&#39;&#125;          ],            password:[            &#123;required: true,message: &#39;密码不能为空&#39;,trigger:&#39;blur&#39;&#125;          ]        &#125;,            &#x2F;&#x2F;对话框显示和隐藏            dialogVisible:false        &#125;        &#125;,        methods:&#123;            handleClose: function () &#123; console.log(&quot;Handle Close，空函数&quot;); &#125;,            onSubmit(formName) &#123;                &#x2F;&#x2F;为表单绑定验证功能                this.$refs[formName].validate((valid) &#x3D;&gt;&#123;                    if (valid)&#123;                        &#x2F;&#x2F;使用 vue-router路由到指定页面，该方式称之为编程式导航                        this.$router.push(&quot;&#x2F;main&quot;);                    &#125; else &#123;                        this.dialogVisible &#x3D; true;                        return false;                    &#125;                &#125;);            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;  .login-box&#123;    border: 1px solid #DCDFE6;    width: 350px;    margin:180px auto;    padding:35px 35px 15px 35px;    border-radius: 5px;    -webkit-border-radius: 5px;    -moz-border-radius: 5px;    box-shadow:0 0 25px #909399;  &#125;  .login-title&#123;    text-align:center;    margin:0 auto 40px auto;    color:#303133;  &#125;&lt;&#x2F;style&gt;\n\nMain.vue\n&lt;template&gt;    &lt;h1&gt;首页&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Main&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n新建router目录，存放配置的路由（index.js）;\nindex.js\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Main from &#x27;../views/Main&#x27;import Login from &#x27;../views/Login&#x27;Vue.use(Router);export default new Router(&#123;  routes:[    &#123;      path:&#x27;/main&#x27;,      component:Main    &#125;,    &#123;      path:&#x27;/login&#x27;,      component:Login    &#125;,  ]&#125;);\n\n在main.js文件中导入并配置路由。\nmain.js\n// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(router)Vue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123;  el: &#x27;#app&#x27;,  router,  render: h =&gt; h(App) //ElementUI&#125;)\n\n注意：遇到问题，可以考虑将sass降级：sass-loader:&quot;7.0.3&quot;，node-sass:&quot;4.7.2&quot;！\n\n\n10 路由钩子Vue的生命周期以及钩子函数\n\n路由钩子\nbeforeRouterEnter：进入路由前执行\nbeforeRouterEnter：进入路由后执行\nexport default&#123;\tprops:[&#39;id&#39;],\tname:&quot;UserProfile&quot;,\tbeforeRouteEnter:(to,from,next)&#x3D;&gt;&#123;\t\tconsole.log(&quot;准备进入个人信息页&quot;);\t\tnext();\t&#125;,\tbeforeRouterLeave:(to,from,next)&#x3D;&gt;&#123;\t\tconsole.log(&quot;准备离开个人信息页&quot;);\t\tnext();\t&#125;&#125;\n\n参数说明：\n\nto：路由将要跳转的路径信息\nfrom：路径跳转前的路径信息\nnext：路由的控制参数\nnext() 跳入下一页面\nnext(‘/path’) 改变路由的跳转方向，使其跳到另一路由\nnext(false) 返回原来的页面\nnext((vm)=&gt;{})仅在beforeRouterEnter中可用，vm是组件实例\n\n\n\n在钩子函数中使用异步请求\n安装并引用Axios\n入口文件main.js中\nimport Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios)\n\n使用路由钩子获取数据\n&lt;script&gt;    export  default &#123;        name:&quot;Login&quot;,        beforeRouteEnter:(to,from,next)&#x3D;&gt;&#123;            console.log(&quot;准备进入个人信息页&quot;);            next(vm&#x3D;&gt;&#123;                vm.getData();            &#125;);        &#125;,        beforeRouterLeave:(to,from,next)&#x3D;&gt;&#123;            console.log(&quot;准备离开个人信息页&quot;);            next();        &#125;,        methods:&#123;            getData:function()&#123;                this.axios(&#123;                    method:&#39;get&#39;,                    url:&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;                &#125;).then(function(response)&#123;                    console.log(response)                &#125;);            &#125;                  &#125;    &#125;&lt;&#x2F;script&gt;\n\n","tags":["前端","Vue"]},{"title":"LeetCode 62.不同路径","url":"/2020/12/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","content":"题目描述：\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n示例：\n输入：m = 3, n = 7输出：28\n解法一：动态规划\n思路： f(i,j) 表示从左上角走到 (i,j) 的路径数量，转移方程为 f(i,j)=f(i-1,j)+f(i,j-1) ，初始条件为 f(i,0)=f(0,j)=1 。\nclass Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[][] f = new int[m][n];        for (int i = 0; i &lt; m; ++i) &#123;            f[i][0] = 1;        &#125;        for (int j = 0; j &lt; n; ++j) &#123;            f[0][j] = 1;        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                f[i][j] = f[i - 1][j] + f[i][j - 1];            &#125;        &#125;        return f[m - 1][n - 1];    &#125;&#125;\n\n解法二：组合数学\n思路：从左上角到右下角过程中需要移动 m+n-2 次，其中有 m-1 次向下移动， n-1 次向右移动。问题相当于从 m+n-2  次移动次数中选择 m-1 次向下移动（或者 n-1次向右移动）。\nclass Solution &#123;    public int uniquePaths(int m, int n) &#123;        long ans = 1;        for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;            ans = ans * x / y;        &#125;        return (int) ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/unique-paths\n","tags":["算法","LeetCode","动态规划","数学"]},{"title":"SpringMVC教程","url":"/2020/12/10/SpringMVC%E6%95%99%E7%A8%8B/","content":"SpringMVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。\nSpringMVC的特点：\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\n\n文档地址：https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#spring-webhttps://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/mvc.html\n1 SpringMVC执行原理Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\nSpringMVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\n\n当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n2 第一个MVC程序\nMaven导入依赖\n&lt;dependencies&gt;   &lt;dependency&gt;       &lt;groupId&gt;junit&lt;/groupId&gt;       &lt;artifactId&gt;junit&lt;/artifactId&gt;       &lt;version&gt;4.12&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework&lt;/groupId&gt;       &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;       &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;       &lt;version&gt;2.5&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;       &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;       &lt;version&gt;2.2&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;jstl&lt;/artifactId&gt;       &lt;version&gt;1.2&lt;/version&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;\n\n编写SpringMVC的配置文件springmvc-servlet.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;        &lt;!--前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!--后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置web.xml，注册DispatcherServlet\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--1.注册DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--启动级别-1--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n编写操作业务Controller （实现Controller接口）\npackage com.zhg.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123;    @Override    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        //ModelAndView 模型和视图        ModelAndView mv = new ModelAndView();        //封装对象，放在ModelAndView中。Model        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;);        //封装要跳转的视图，放在ModelAndView中        mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp        return mv;    &#125;&#125;\n\n在SpringMVC的配置文件中注册bean\n&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.zhg.controller.HelloController&quot;/&gt;\n\n编写跳转的jsp页面\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n\n\n遇到问题：访问出现404\n解决方案：添加发布项目中缺少的lib依赖\n使用注解开发\nMaven导入依赖\n\n\n编写SpringMVC的配置文件springmvc-servlet.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;    &lt;context:component-scan base-package=&quot;com.zhg.controller&quot;/&gt;    &lt;!--使SpringMVC不处理静态资源--&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--自动完成DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter两个实例的注入--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;        &lt;!--前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!--后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置web.xml，注册DispatcherServlet\n\n\n\n编写操作业务Controller （注解）\npackage com.zhg.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVAnnotation!&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n\n\n\n\n编写跳转的jsp页面\n\n3 RESTful风格RESTful是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应添加、 删除、修改、查询操作。\n在Spring MVC中可以使用  @PathVariable 注解，将方法参数的值对应绑定到一个URI模板变量上。\n//映射访问路径@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123;   String result = p1+p2;   //Spring MVC会自动实例化一个Model对象用于向视图中传值   model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);   //返回视图位置   return &quot;test&quot;;&#125;\n\nURL：http://localhost:8080/commit?p1=1&amp;p2=2 → http://localhost:8080/commit/1/2\n使用路径变量的好处：\n\n使路径变得更加简洁；\n获得参数更加方便，框架会自动进行类型转换；\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。\n\n使用method属性指定请求类型（如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等），可以收窄请求范围。\n//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.POST) //相当于组合注解@PostMapping(&quot;/hello&quot;)//其他组合注解：@GetMapping，@PostMapping，@PutMapping，@DeleteMapping，@PatchMappingpublic String index2(Model model)&#123;   model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);   return &quot;test&quot;;&#125;\n\n所有的地址栏请求默认都会是 HTTP GET 类型的。\n4 重定向和转发通过SpringMVC来实现转发和重定向（无需视图解析器）\n@Controllerpublic class ResultSpringMVC &#123;   @RequestMapping(&quot;/rsm/t1&quot;)   public String test1()&#123;       //转发       return &quot;/index.jsp&quot;;  &#125;   @RequestMapping(&quot;/rsm/t2&quot;)   public String test2()&#123;       //转发二       return &quot;forward:/index.jsp&quot;;  &#125;   @RequestMapping(&quot;/rsm/t3&quot;)   public String test3()&#123;       //重定向       return &quot;redirect:/index.jsp&quot;;       //可以重定向到另外一个请求实现       //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求  &#125;&#125;\n\n5 数据处理5.1 处理页面提交数据提交数据：http://localhost:8080/hello?username=XXX\n处理方法：\n//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123;   System.out.println(name);   return &quot;hello&quot;;&#125;\n\n后台输出：XXX\n提交对象要求提交的表单域和对象的属性名一致  , 参数使用对象即可\n实体类\npublic class User &#123;   private int id;   private String name;   private int age;   //构造   //get/set   //tostring()&#125;\n\n2、提交数据：http://localhost:8080/mvc04/user?name=XXX&amp;id=1&amp;age=15\n3、处理方法：\n@RequestMapping(&quot;/user&quot;)public String user(User user)&#123; //前端传递的参数名和对象名必须一致   System.out.println(user);   return &quot;hello&quot;;&#125;\n\n后台输出：User { id=1, name=’XXX’, age=15 }\n5.2 数据显示到前端\n通过ModelAndView\npublic class ControllerTest1 implements Controller &#123;   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;       //返回一个模型视图对象       ModelAndView mv = new ModelAndView();       mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);       mv.setViewName(&quot;test&quot;);       return mv;  &#125;&#125;\n\n通过ModelMap\n@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;   //封装要显示到视图中的数据   //相当于req.setAttribute(&quot;name&quot;,name);   model.addAttribute(&quot;name&quot;,name);   System.out.println(name);   return &quot;hello&quot;;&#125;\n\n通过Model\n@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;   //封装要显示到视图中的数据   //相当于req.setAttribute(&quot;name&quot;,name);   model.addAttribute(&quot;msg&quot;,name);   System.out.println(name);   return &quot;test&quot;;&#125;\n\n\n\n对比：\n\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；\n\nModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；\n\nModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。\n\n\n6 乱码问题乱码问题可以通过过滤器解决 , 而SpringMVC也提供了一个过滤器 , 可以在web.xml中配置。\n&lt;filter&gt;   &lt;filter-name&gt;encoding&lt;/filter-name&gt;   &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;   &lt;init-param&gt;       &lt;param-name&gt;encoding&lt;/param-name&gt;       &lt;param-value&gt;utf-8&lt;/param-value&gt;   &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;   &lt;filter-name&gt;encoding&lt;/filter-name&gt;   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n其他处理方法：\n\n修改tomcat配置文件（设置编码）\n&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;          connectionTimeout=&quot;20000&quot;          redirectPort=&quot;8443&quot; /&gt;\n\n自定义过滤器\nimport javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123;   @Override   public void destroy() &#123;  &#125;   @Override   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;       //处理response的字符编码       HttpServletResponse myResponse=(HttpServletResponse) response;       myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);       // 转型为与协议相关对象       HttpServletRequest httpServletRequest = (HttpServletRequest) request;       // 对request包装增强       HttpServletRequest myrequest = new MyRequest(httpServletRequest);       chain.doFilter(myrequest, response);  &#125;   @Override   public void init(FilterConfig filterConfig) throws ServletException &#123;  &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123;   private HttpServletRequest request;   //是否编码的标记   private boolean hasEncode;   //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰   public MyRequest(HttpServletRequest request) &#123;       super(request);// super必须写       this.request = request;  &#125;   // 对需要增强方法 进行覆盖   @Override   public Map getParameterMap() &#123;       // 先获得请求方式       String method = request.getMethod();       if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;           // post请求           try &#123;               // 处理post乱码               request.setCharacterEncoding(&quot;utf-8&quot;);               return request.getParameterMap();          &#125; catch (UnsupportedEncodingException e) &#123;               e.printStackTrace();          &#125;      &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;           // get请求           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();           if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次               for (String parameterName : parameterMap.keySet()) &#123;                   String[] values = parameterMap.get(parameterName);                   if (values != null) &#123;                       for (int i = 0; i &lt; values.length; i++) &#123;                           try &#123;                               // 处理get乱码                               values[i] = new String(values[i]                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);                          &#125; catch (UnsupportedEncodingException e) &#123;                               e.printStackTrace();                          &#125;                      &#125;                  &#125;              &#125;               hasEncode = true;          &#125;           return parameterMap;      &#125;       return super.getParameterMap();  &#125;   //取一个值   @Override   public String getParameter(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       if (values == null) &#123;           return null;      &#125;       return values[0]; // 取回参数的第一个值  &#125;   //取所有值   @Override   public String[] getParameterValues(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       return values;  &#125;&#125;\n\n\n\n7 JSON\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写的同时，也易于机器解析和生成，并有效地提升网络传输效率，目前使用特别广泛。\n\nJSON 键值对是用来保存 JavaScript 对象的一种方式，任何JavaScript 支持的类型都可以通过 JSON 来表示，格式&#123;&quot;key&quot;: &quot;value&quot;&#125;。\nJSON和JavaScript对象互转\n//将JSON字符串转换为JavaScript对象var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;//将JavaScript对象转换为JSON字符串var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;\n\nController返回JSON数据Jackson导入依赖并配置SpringMVC需要的配置\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.11.3&lt;/version&gt;&lt;/dependency&gt;\n\nUser实体类\npackage com.zhg.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;   private String name;   private int age;   private String sex;   &#125;\n\nUserController\n@Controller//可以在类上直接使用@RestController，相当于在该类下所有的方法上都添加了@ResponseBodypublic class UserController &#123;    @RequestMapping(&quot;/json1&quot;)    @ResponseBody //不跳转页面，而是返回字符串到当前页面    public String json1() throws JsonProcessingException &#123;        //创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper = new ObjectMapper();        //创建一个对象        User user = new User(&quot;user&quot;, 18, &quot;男&quot;);        //将对象解析成为json格式        String str = mapper.writeValueAsString(user);        //由于@ResponseBody注解，这里会将str转成json格式返回。        return str;    &#125;        //输出集合    @RequestMapping(&quot;/json2&quot;)    @ResponseBody     public String json2() throws JsonProcessingException &#123;        //创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper = new ObjectMapper();        //创建多个对象        User user1 = new User(&quot;user1&quot;, 18, &quot;男&quot;);        User user2 = new User(&quot;user2&quot;, 18, &quot;男&quot;);        User user3 = new User(&quot;user3&quot;, 18, &quot;男&quot;);        User user4 = new User(&quot;user4&quot;, 18, &quot;男&quot;);        List&lt;User&gt; list = new ArrayList&lt;User&gt;();        list.add(user1);        list.add(user2);        list.add(user3);        list.add(user4);        //将我们的对象解析成为json格式        String str = mapper.writeValueAsString(list);        return str;    &#125;        //输出时间（时间戳）    @RequestMapping(&quot;/json3&quot;)    @ResponseBody    public String json3() throws JsonProcessingException &#123;        ObjectMapper mapper = new ObjectMapper();        //创建时间一个对象，java.util.Date        Date date = new Date();        //将我们的对象解析成为json格式        String str = mapper.writeValueAsString(date);         return str;    &#125;    //输出时间（自定义时间格式）    @RequestMapping(&quot;/json4&quot;)    @ResponseBody    public String json3() throws JsonProcessingException &#123;        ObjectMapper mapper = new ObjectMapper();        //不使用时间戳的方式        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        //自定义日期格式对象        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        //指定日期格式        mapper.setDateFormat(sdf);        Date date = new Date();        String str = mapper.writeValueAsString(date);        return str;    &#125;    &#125;\n\n乱码问题\n通过@RequestMaping的produces属性设置编码格式为utf-8，返回的类型为json\n//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)\n\n通过Spring配置统一解决乱码问题\n&lt;mvc:annotation-driven&gt;   &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;       &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;           &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;       &lt;/bean&gt;       &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;           &lt;property name=&quot;objectMapper&quot;&gt;               &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                   &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;               &lt;/bean&gt;           &lt;/property&gt;       &lt;/bean&gt;   &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n\n抽取为JSON工具类\nimport com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123;      public static String getJson(Object object) &#123;       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);  &#125;   public static String getJson(Object object,String dateFormat) &#123;       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try &#123;           return mapper.writeValueAsString(object);      &#125; catch (JsonProcessingException e) &#123;           e.printStackTrace();      &#125;       return null;  &#125;&#125;\n\nFastjsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt;\n\nfastjson 三个主要的类：\n\nJSONObject代表json对象（实现Map接口）\n\nJSONArray代表json对象数组（List接口）\n\nJSON代表JSONObject和JSONArray的转化\n\n\nimport com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.zhg.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123;   public static void main(String[] args) &#123;       User user1 = new User(&quot;user1&quot;, 18, &quot;男&quot;);       User user2 = new User(&quot;user2&quot;, 18, &quot;男&quot;);       User user3 = new User(&quot;user3&quot;, 18, &quot;男&quot;);       User user4 = new User(&quot;user4&quot;, 18, &quot;男&quot;);       List&lt;User&gt; list = new ArrayList&lt;User&gt;();       list.add(user1);       list.add(user2);       list.add(user3);       list.add(user4);       System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);       String str1 = JSON.toJSONString(list);       System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);       String str2 = JSON.toJSONString(user1);       System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);       System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;);       User jp_user1=JSON.parseObject(str2,User.class);       System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);       System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;);       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);       System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));       System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;);       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);       System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);  &#125;&#125;\n\n8 整合SSM整合步骤：\n\n新建Maven项目，导入相关依赖并设置资源过滤；\n&lt;dependencies&gt;    &lt;!--Junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--数据库驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.mchange&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Servlet - JSP --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mybatis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;2.0.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n编写MyBatis配置文件；\n\ndatabase.properties（数据库配置文件）\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTCjdbc.username=rootjdbc.password=1031\n\nmybatis-config.xml（Mybatis配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;      &lt;typeAliases&gt;       &lt;package name=&quot;com.zhg.pojo&quot;/&gt;   &lt;/typeAliases&gt;   &lt;!--&lt;mappers&gt;       &lt;mapper resource=&quot;com/zhg/dao/BookMapper.xml&quot;/&gt;   &lt;/mappers&gt;--&gt;&lt;/configuration&gt;\n\n\n\n编写Spring配置文件；\n\nspring-dao.xml（Spring整合Mybatis配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 配置整合mybatis --&gt;   &lt;!-- 1.关联数据库文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;   &lt;!-- 2.数据库连接池 --&gt;   &lt;!--数据库连接池       dbcp 半自动化操作 不能自动连接       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）   --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;       &lt;!-- 配置连接池属性 --&gt;       &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;       &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;       &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;       &lt;!-- c3p0连接池的私有属性 --&gt;       &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;       &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;       &lt;!-- 关闭连接后不自动commit --&gt;       &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;       &lt;!-- 获取连接超时时间 --&gt;       &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;       &lt;!-- 当获取连接失败重试次数 --&gt;       &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;   &lt;/bean&gt;   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;       &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;    &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;&lt;!--    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;--&gt;&lt;!--        &amp;lt;!&amp;ndash; 注入sqlSessionFactory &amp;ndash;&amp;gt;--&gt;&lt;!--        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;--&gt;&lt;!--        &amp;lt;!&amp;ndash; 给出需要扫描Dao接口包 &amp;ndash;&amp;gt;--&gt;&lt;!--        &lt;property name=&quot;basePackage&quot; value=&quot;com.zhg.dao&quot;/&gt;--&gt;&lt;!--    &lt;/bean&gt;--&gt;    &lt;bean id=&quot;bookMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.zhg.dao.BookMapper&quot; /&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nspring-service.xml（Spring整合Service层配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;!-- 扫描service相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.zhg.service&quot; /&gt;   &lt;!--BookServiceImpl注入到IOC容器中--&gt;   &lt;!--&lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.zhg.service.BookServiceImpl&quot;&gt;       &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;   &lt;/bean&gt;--&gt;   &lt;!-- 配置事务管理器 --&gt;   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n编写SpringMVC配置文件；\n\nweb.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;&gt;   &lt;!--DispatcherServlet--&gt;   &lt;servlet&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;             &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;       &lt;/init-param&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;   &lt;/servlet&gt;   &lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;   &lt;!--encodingFilter--&gt;   &lt;filter&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;filter-class&gt;          org.springframework.web.filter.CharacterEncodingFilter       &lt;/filter-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;utf-8&lt;/param-value&gt;       &lt;/init-param&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;      &lt;!--Session过期时间--&gt;   &lt;session-config&gt;       &lt;session-timeout&gt;15&lt;/session-timeout&gt;   &lt;/session-config&gt;   &lt;/web-app&gt;\n\nspring-mvc.xml（SpringMVC配置文件）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;   &lt;!-- 配置SpringMVC --&gt;   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;   &lt;mvc:annotation-driven /&gt;   &lt;!-- 2.静态资源默认servlet配置--&gt;   &lt;mvc:default-servlet-handler/&gt;   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;   &lt;/bean&gt;   &lt;!-- 4.扫描web相关的bean --&gt;   &lt;context:component-scan base-package=&quot;com.zhg.controller&quot; /&gt;&lt;/beans&gt;\n\n\n\nSpring配置整合。\napplicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;   &lt;import resource=&quot;spring-dao.xml&quot;/&gt;   &lt;import resource=&quot;spring-service.xml&quot;/&gt;   &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;   &lt;/beans&gt;\n\n\n\n9 Ajax\nAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n利用AJAX可以实现：\n\n注册时，输入用户名自动检测用户是否已经存在；\n登陆时，提示用户名密码错误；\n删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除；\n……\n\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。jQuery 提供多个与 AJAX 有关的方法，其本质就是 XMLHttpRequest，对原生JS代码进行了封装，方便调用！\nAjaxController\n@Controllerpublic class AjaxController &#123;   @RequestMapping(&quot;/a1&quot;)   public void ajax1(String name , HttpServletResponse response) throws IOException &#123;       if (&quot;admin&quot;.equals(name))&#123;           response.getWriter().print(&quot;true&quot;);      &#125;else&#123;           response.getWriter().print(&quot;false&quot;);      &#125;  &#125;&#125;\n\nindex.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt;   &lt;title&gt;$Title$&lt;/title&gt;  &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;   &lt;script&gt;       function a1()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,               data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;,               success:function (data,status) &#123;                   alert(data);                   alert(status);              &#125;          &#125;);      &#125;   &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt;\n\n获取一个集合对象，展示到前端页面\nUserController\n@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123;   List&lt;User&gt; list = new ArrayList&lt;User&gt;();   list.add(new User(&quot;user1&quot;,3,&quot;男&quot;));   list.add(new User(&quot;user2&quot;,3,&quot;男&quot;));   list.add(new User(&quot;user3&quot;,3,&quot;男&quot;));   return list; //由于@RestController注解，将list转成json格式返回&#125;\n\nuser.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt;   &lt;tr&gt;       &lt;td&gt;姓名&lt;/td&gt;       &lt;td&gt;年龄&lt;/td&gt;       &lt;td&gt;性别&lt;/td&gt;   &lt;/tr&gt;   &lt;tbody id=&quot;content&quot;&gt;   &lt;/tbody&gt;&lt;/table&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;   $(function () &#123;       $(&quot;#btn&quot;).click(function () &#123;           $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;               console.log(data)               var html=&quot;&quot;;               for (var i = 0; i &lt;data.length ; i++) &#123;                   html+= &quot;&lt;tr&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;/tr&gt;&quot;              &#125;               $(&quot;#content&quot;).html(html);          &#125;);      &#125;)  &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注册提示效果\nRegisterController\n@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123;   String msg = &quot;&quot;;   //模拟数据库中存在数据   if (name!=null)&#123;       if (&quot;admin&quot;.equals(name))&#123;           msg = &quot;OK&quot;;      &#125;else &#123;           msg = &quot;用户名输入错误&quot;;      &#125;  &#125;   if (pwd!=null)&#123;       if (&quot;123456&quot;.equals(pwd))&#123;           msg = &quot;OK&quot;;      &#125;else &#123;           msg = &quot;密码输入有误&quot;;      &#125;  &#125;   return msg; //由于@RestController注解，将msg转成json格式返回&#125;\n\nlogin.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;ajax&lt;/title&gt;   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;   &lt;script&gt;       function a1()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,               data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;,               success:function (data) &#123;                   if (data.toString()==&#x27;OK&#x27;)&#123;                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                  &#125;else &#123;                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                  &#125;                   $(&quot;#userInfo&quot;).html(data);              &#125;          &#125;);      &#125;       function a2()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,               data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;,               success:function (data) &#123;                   if (data.toString()==&#x27;OK&#x27;)&#123;                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                  &#125;else &#123;                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                  &#125;                   $(&quot;#pwdInfo&quot;).html(data);              &#125;          &#125;);      &#125;   &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;  用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;   &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;   &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n10 拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。\n过滤器与拦截器的区别：拦截器是AOP思想的具体应用。\n过滤器\n\nservlet规范中的一部分，任何java web工程都可以使用\n在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截\n\n拦截器 \n\n拦截器是SpringMVC框架里的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的\n\n自定义拦截器\nimport org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123;   //在请求处理的方法之前执行   //如果返回true执行下一个拦截器   //如果返回false就不执行下一个拦截器   public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;       System.out.println(&quot;------------处理前------------&quot;);       return true;  &#125;   //在请求处理方法执行之后执行   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;       System.out.println(&quot;------------处理后------------&quot;);  &#125;   //在dispatcherServlet处理后执行,做清理工作.   public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;       System.out.println(&quot;------------清理------------&quot;);  &#125;&#125;\n\n配置拦截器\n&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;       &lt;!--/** 包括路径及其子路径--&gt;       &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;       &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;       &lt;mvc:mapping path=&quot;/**&quot;/&gt;       &lt;!--bean配置的就是拦截器--&gt;       &lt;bean class=&quot;com.zhg.interceptor.MyInterceptor&quot;/&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n验证用户是否登录\nUserController\nimport org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;   //跳转到登陆页面   @RequestMapping(&quot;/jumplogin&quot;)   public String jumpLogin() throws Exception &#123;       return &quot;login&quot;;  &#125;   //跳转到成功页面   @RequestMapping(&quot;/jumpSuccess&quot;)   public String jumpSuccess() throws Exception &#123;       return &quot;success&quot;;  &#125;   //登陆提交   @RequestMapping(&quot;/login&quot;)   public String login(HttpSession session, String username, String pwd) throws Exception &#123;       // 向session记录用户身份信息       System.out.println(&quot;接收前端===&quot;+username);       session.setAttribute(&quot;user&quot;, username);       return &quot;success&quot;;  &#125;   //退出登陆   @RequestMapping(&quot;logout&quot;)   public String logout(HttpSession session) throws Exception &#123;       // session 过期       session.invalidate();       return &quot;login&quot;;  &#125;&#125;\n\n用户登录拦截器\nimport org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class LoginInterceptor implements HandlerInterceptor &#123;   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;       // 如果是登陆页面则放行       System.out.println(&quot;uri: &quot; + request.getRequestURI());       if (request.getRequestURI().contains(&quot;login&quot;)) &#123;           return true;      &#125;       HttpSession session = request.getSession();       // 如果用户已登陆也放行       if(session.getAttribute(&quot;user&quot;) != null) &#123;           return true;      &#125;       // 用户没有登陆跳转到登陆页面       request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);       return false;  &#125;   public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;  &#125;      public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;  &#125;&#125;\n\nSpringMVC配置文件中的注册拦截器\n&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;       &lt;mvc:mapping path=&quot;/**&quot;/&gt;       &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.zhg.interceptor.LoginInterceptor&quot;/&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n11 文件上传下载如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver，而且必须将表单的method设置为POST，并将enctype设置为multipart/form-data（用户选择的文件以二进制数据发送给服务器）。\n表单中的enctype 属性：\n\napplication/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。\nmultipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。\ntext/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。\n\nSpring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。\n11.1 文件上传\n导入文件上传的jar包，commons-fileupload；\n&lt;!--文件上传--&gt;&lt;dependency&gt;   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;   &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt;   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;   &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;   &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n配置multipartResolver；\n&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;   &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;   &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;   &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;   &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt;\n\nCommonsMultipartFile 的 常用方法：\n\nString getOriginalFilename()：获取上传文件的原名\nInputStream getInputStream()：获取文件流\nvoid transferTo(File dest)：将上传文件保存到一个目录文件中\n\n\n编写上传文件的表单；\n&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt;\n\n编写上传文件的FileController。\nimport org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@Controllerpublic class FileController &#123;   //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象   //批量上传CommonsMultipartFile则为数组即可   @RequestMapping(&quot;/upload&quot;)   public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;       //获取文件名 : file.getOriginalFilename();       String uploadFileName = file.getOriginalFilename();       //如果文件名为空，直接回到首页！       if (&quot;&quot;.equals(uploadFileName))&#123;           return &quot;redirect:/index.jsp&quot;;      &#125;       System.out.println(&quot;上传文件名 : &quot;+uploadFileName);       //上传路径保存设置       String path = request.getServletContext().getRealPath(&quot;/upload&quot;);       //如果路径不存在，创建一个       File realPath = new File(path);       if (!realPath.exists())&#123;           realPath.mkdir();      &#125;       System.out.println(&quot;上传文件保存地址：&quot;+realPath);       InputStream is = file.getInputStream(); //文件输入流       OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流       //读取写出       int len=0;       byte[] buffer = new byte[1024];       while ((len=is.read(buffer))!=-1)&#123;           os.write(buffer,0,len);           os.flush();      &#125;       os.close();       is.close();       return &quot;redirect:/index.jsp&quot;;  &#125;    /** 采用file.Transto 来保存上传的文件*/    @RequestMapping(&quot;/upload2&quot;)    public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;        //上传路径保存设置        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);        File realPath = new File(path);        if (!realPath.exists())&#123;            realPath.mkdir();        &#125;        //上传文件地址        System.out.println(&quot;上传文件保存地址：&quot;+realPath);        //通过CommonsMultipartFile的方法直接写文件（注意这个时候）        file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));        return &quot;redirect:/index.jsp&quot;;    &#125;&#125;\n\n\n\n11.2 文件下载编写下载文件的Controller\n@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123;   //要下载的图片地址   String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);   String  fileName = &quot;基础语法.jpg&quot;;   //1、设置response 响应头   response.reset(); //设置页面不缓存,清空buffer   response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码   response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据   //设置响应头   response.setHeader(&quot;Content-Disposition&quot;,           &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));   File file = new File(path,fileName);   //2、 读取文件--输入流   InputStream input=new FileInputStream(file);   //3、 写出文件--输出流   OutputStream out = response.getOutputStream();   byte[] buff =new byte[1024];   int index=0;   //4、执行 写出操作   while((index= input.read(buff))!= -1)&#123;       out.write(buff, 0, index);       out.flush();  &#125;   out.close();   input.close();   return null;&#125;\n\n\n\n","tags":["Java","SSM框架","SpringMVC"]},{"title":"日期时间处理","url":"/2020/12/10/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/","content":"Java日期时间Date&amp;Calendar菜鸟教程 - Java日期时间：https://www.runoob.com/java/java-date-time.html\njava.util.Date：https://docs.oracle.com/javase/8/docs/api/java/util/Date.html\njava.text.SimpleDateFormat：https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\njava.util.Calendar：https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html\nDate类封装了当前的日期和时间，可以用来比较两个日期。\nimport java.util.Date;  public class DateDemo &#123;   public static void main(String args[]) &#123;       // 初始化 Date 对象       Date date = new Date();               // 使用 toString() 函数显示日期时间       System.out.println(date.toString());   &#125;&#125;// 通过getTime()，before() after() equals()，compareTo()三种方法比较时间\n\nSimpleDateFormat类可以将字符串和日期时间相互转化（格式化日期或解析字符串为时间）。\nimport  java.util.*;import java.text.*; // 通过sdf.format(date)格式化日期public class SDFDemo1 &#123;   public static void main(String args[]) &#123;       Date dNow = new Date( );      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd HH:mm:ss&quot;);       System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));   &#125;&#125;// 通过sdf.parse(string)解析字符串为时间public class SDFDemo2 &#123;    public static void main(String args[]) &#123;      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);        String input = args.length == 0 ? &quot;1818-11-11&quot; : args[0];        System.out.print(input + &quot; Parses as &quot;);        Date t;        try &#123;           t = ft.parse(input);           System.out.println(t);       &#125; catch (ParseException e) &#123;           System.out.println(&quot;Unparseable using &quot; + ft);       &#125;   &#125;&#125;\n\nCalendar类可以设置和获取日期数据的特定部分，在日期的这些部分加上或者减去值。\nimport java.util.Calendar;public class CalendarDemo &#123;    public static void main(String[] args) &#123;        // 初始值        Calendar cal = Calendar.getInstance(); //得到当前时间        cal.setTimeInMillis(0); //转换成格林威治时间,由于中国时区设置是GMT+8,所以打印格林威治时间得到的是1970-01-01 08:00:00.                // 获取值        int year = cal.get(Calendar.YEAR); //年        int month = cal.get(Calendar.MONTH) + 1; //月(必须要+1)        int date = cal.get(Calendar.DATE); //日        int hour = cal.get(Calendar.HOUR_OF_DAY); //时        int minute = cal.get(Calendar.MINUTE); //分        int second = cal.get(Calendar.SECOND); //秒        int day = cal.get(Calendar.DAY_OF_WEEK); //星期(Locale.ENGLISH情况下，周日是1)        // 设置值        cal.set(2013, 5, 4, 13, 44, 51); //年月日时分秒(月份0代表1月)        cal.set(Calendar.YEAR, 2014); //年        cal.set(Calendar.MONTH, 0); //月(月份0代表1月)        cal.set(Calendar.DATE, 11); //日        cal.set(Calendar.HOUR_OF_DAY, 15); //时        cal.set(Calendar.MINUTE, 33); //分        cal.set(Calendar.SECOND, 32); //秒                // 比较值        // before(),after(),equals(),compareTo()        String startTime = &quot;2012-12-12 12:45:39&quot;;          String endTime = &quot;2012-12-12 12:45:40&quot;;          SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);          Date startDate = sdf.parse(startTime);          Date endDate = sdf.parse(endTime);          Calendar start = Calendar.getInstance();          Calendar end = Calendar.getInstance();          start.setTime(startDate);          end.setTime(endDate);          if(start.before(end))&#123;              System.err.println(&quot;开始时间小于结束时间&quot;);          &#125;else if(start.after(end))&#123;              System.err.println(&quot;开始时间大于结束时间&quot;);          &#125;else if(start.equals(end))&#123;              System.err.println(&quot;开始时间等于结束时间&quot;);          &#125;          /*               * start &lt; end 返回-1               * start = end 返回0               * start &gt; end 返回1               */          int count = start.compareTo(end);          System.err.println(count);                // 运算值        cal.add(Calendar.YEAR, 1); //年        cal.add(Calendar.MONTH, 1); //月        cal.add(Calendar.DATE, 1); //日        cal.add(Calendar.HOUR_OF_DAY, -1); //时        cal.add(Calendar.MINUTE, 1); //分        cal.add(Calendar.SECOND, 1); //秒        cal.add(Calendar.DATE, 7); //周            &#125;&#125;\n\nDate/Time在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：\n\n非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。\n设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。\n时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。\n\nJava 8引入了新的API Date/Time，以解决较旧的java.util.Date和java.util.Calendar的问题，新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\njava.time：https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\n最常用的类是LocalDate，LocalTime和LocalDateTime。 顾名思义，它们代表观察者上下文中的本地日期/时间。这些类主要用于不需要在上下文中明确指定时区的情况。\nimport java.time.*;import java.time.temporal.ChronoUnit;import java.time.temporal.TemporalAdjusters;import java.util.Calendar;import java.util.Date;public class LocalDateTimeDemo &#123;    public static void main(String[] args) &#123;        // LocalDate        // 创建日期        LocalDate today = LocalDate.now(); // 获取当前日期的实例        LocalDate date1 = LocalDate.of(2015, 2, 20); // 通过年月日数值获取指定日期的实例        LocalDate date2 = LocalDate.parse(&quot;2015-02-20&quot;); // 通过字符串获取指定日期的实例        // 日期加减        LocalDate tomorrow = LocalDate.now().plusDays(1); // 天        LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS); // 指定时间单位        // 获取日期相关信息        DayOfWeek sunday = LocalDate.parse(&quot;2016-06-12&quot;).getDayOfWeek(); // 查询日期星期        int twelve = LocalDate.parse(&quot;2016-06-12&quot;).getDayOfMonth(); // 查询日期月份天数        boolean leapYear = LocalDate.now().isLeapYear(); // 判断日期年份是否是闰年        // 获取日期当天/当月最开始时刻        LocalDateTime beginningOfDay = LocalDate.parse(&quot;2016-06-12&quot;).atStartOfDay();        LocalDate firstDayOfMonth = LocalDate.parse(&quot;2016-06-12&quot;).with(TemporalAdjusters.firstDayOfMonth());        // LocalTime        // 创建时间        LocalTime now = LocalTime.now();        LocalTime time1 = LocalTime.parse(&quot;06:30&quot;);        LocalTime time2 = LocalTime.of(6, 30);        // 时间加减        LocalTime sevenThirty = LocalTime.parse(&quot;06:30&quot;).plus(1, ChronoUnit.HOURS);        // 获取时间相关信息        int six = LocalTime.parse(&quot;06:30&quot;).getHour();        boolean isBefore = LocalTime.parse(&quot;06:30&quot;).isBefore(LocalTime.parse(&quot;07:30&quot;)); // 比较时间先后        LocalTime maxTime = LocalTime.MAX;        // LocalDateTime        // 创建日期时间        LocalDateTime curDatetime = LocalDateTime.now();        LocalDateTime dateTime1 = LocalDateTime.of(2015, Month.FEBRUARY, 20, 06, 30);        LocalDateTime dateTime2 = LocalDateTime.parse(&quot;2015-02-20T06:30:00&quot;);        // 组合日期和时间        LocalDate date = LocalDate.of(2014,02,26);        LocalTime time = LocalTime.of(12,23,20);        LocalDateTime dt1 = LocalDateTime.of(date,time);        //LocalDate结合LocalTime成一个LocalDateTime        LocalDateTime dt2 = date.atTime(13,45,20);        //LocalDate结合LocalTime成一个LocalDateTime        LocalDateTime dt3 = date.atTime(time);        //LocalTime结合LocalDate成LocalDateTime        LocalDateTime dt4 = time.atDate(date);                // 日期时间加减        LocalDateTime nextDay = curDatetime.plusDays(1);        LocalDateTime preTime = curDatetime.minusHours(2);        // 将Date和Calendar转换为Instant再转换为LocalDateTime        Date date = new Date();        Calendar calendar = Calendar.getInstance();        LocalDateTime dateTimeC1 = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());        LocalDateTime dateTimeC2 = LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());        LocalDateTime dateTimeC3 = LocalDateTime.ofEpochSecond(1465817690, 0, ZoneOffset.UTC);                // DateTime格式化        // 格式化        LocalDateTime localDateTime = LocalDateTime.of(2015, Month.JANUARY, 25, 6, 30);        String localDateString1 = localDateTime.format(DateTimeFormatter.ISO_DATE); // ISO日期格式：2015-01-25        String localDateString2 = localDateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));        String localDateString3 = localDateTime.format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)); // SHORT:15-1-25 上午6:30 MEDIUM:2015-1-25 6:30:00 LONG:2015年1月25日 上午06时30分00秒    &#125;&#125;\n\n当需要处理时区特定的日期和时间时，Java 8提供了ZonedDateTime， ZoneId用于表示不同区域的标识符。使用时区的另一种方法是使用具有偏移量的日期时间OffsetDateTime。\nimport java.time.*;import java.util.Set;public class ZonedDateTimeDemo &#123;    public static void main(String[] args) &#123;        ZoneId zoneId = ZoneId.of(&quot;Europe/Paris&quot;); // 创建巴黎时区        Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds(); //获取所有时区的ZoneId        // 本地日期时间localDateTime转换成特定时区的zonedDateTime1        LocalDateTime localDateTime = LocalDateTime.now();        ZonedDateTime zonedDateTime1 = ZonedDateTime.of(localDateTime, zoneId);        // 解析字符串生成时区日期时间zonedDateTime2        ZonedDateTime zonedDateTime2 = ZonedDateTime.parse(&quot;2015-05-03T10:15:30+01:00[Europe/Paris]&quot;);                // 创建具有偏移量的日期时间OffsetDateTime        ZoneOffset offset = ZoneOffset.of(&quot;+02:00&quot;);        OffsetDateTime offSetByTwo = OffsetDateTime.of(localDateTime, offset);    &#125;\n\nPeriod类表示以年、月和日为单位的时间数量，广泛用于修改给定日期的值或获取两个日期之间的差异；Duration类表示以秒和纳米秒为单位的时间数量，与Period类似，Duration类用于处理时间。\nimport java.time.Duration;import java.time.LocalDate;import java.time.LocalTime;import java.time.Period;import java.time.temporal.ChronoUnit;public class PeriodDurationDemo &#123;    public static void main(String[] args) &#123;        // Period        // 创建两个本地日期        LocalDate initialDate = LocalDate.parse(&quot;2007-05-10&quot;);        LocalDate finalDate = initialDate.plus(Period.ofDays(5));        // 计算两个日期的差值        int five1 = Period.between(initialDate, finalDate).getDays();        long five2 = ChronoUnit.DAYS.between(initialDate, finalDate);        // Duration        // 创建两个本地时间        LocalTime initialTime = LocalTime.of(6, 30, 0);        LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));        // 计算两个时间的差值        long thirty1 = Duration.between(initialTime, finalTime).getSeconds();        long thirty2 = ChronoUnit.SECONDS.between(initialTime, finalTime);    &#125;&#125;\n\nJoda-TimeJodaTime 提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。（Joda-Time的作者（Stephen Colebourne）和Oracle的作者在JSR 310下共同领导，开发了Java SE 8软件包中java.time。）\nJoda-Time主要的特点包括：\n\n易于使用：Calendar让获取”正常的”的日期变得很困难，使它没办法提供简单的方法，而Joda-Time能够 直接进行访问域并且索引值1就是代表January。\n易于扩展：JDK支持多日历系统是通过Calendar的子类来实现，这样就显示的非常笨重而且事实 上要实现其它日历系统是很困难的。Joda-Time支持多日历系统是通过基于Chronology类的插件体系来实现。\n提供一组完整的功能：它打算提供 所有关系到date-time计算的功能．Joda-Time当前支持6种日历系统，而且在将来还会继续添加。有着比JDK Calendar更好的整体性能等等。\n\n文档地址：https://www.joda.org/joda-time/userguide.html\n导入Maven依赖\n&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;\n\n与java.time类似，Joda-Time有5个最常用的date-time类：Instant, DateTime, LocalDate, LocalTime, LocalDateTime，都是不可变的类。\nimport org.joda.time.DateTime;import org.joda.time.LocalDate;public class JodaTimeDemo &#123;    public static void main(String[] args) &#123;        DateTime today = new DateTime();        DateTime datetorrow = today.plusDays(1);        System.out.println(today.toString(&quot;yyyy-MM-dd&quot;));//2020-12-14        System.out.println(today.toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));//2020-12-14 17:19:39        System.out.println(datetorrow.toString(&quot;yyyy-MM-dd&quot;));//2020-12-15        System.out.println(&quot;......................&quot;);        //获得一个时间的副本，将day设置成自己制定的时间,不改变月份，只改变日期        DateTime d1 = today.withDayOfMonth(1);        System.out.println(d1.toString(&quot;yyyy-MM-dd&quot;));//2020-12-01        System.out.println(&quot;......................&quot;);        LocalDate localDate = new LocalDate();        System.out.println(localDate);//2020-12-14        System.out.println(&quot;........................&quot;);        //获取当前时间三个月后的月份的最后一天        localDate = localDate.plusMonths(3).dayOfMonth().withMaximumValue();        System.out.println(localDate);//2021-03-31        System.out.println(&quot;........................&quot;);        //计算二年前第三个月第一天的日期        DateTime dateTime = new DateTime();        DateTime dateTime2 = dateTime.minusYears(2).monthOfYear().setCopy(3).                dayOfMonth().withMinimumValue();        System.out.println(dateTime2.toString(&quot;yyyy-MM-dd&quot;));//2018-03-01    &#125;&#125;\n\nInterval表示两个 instant 之间的间隔，左闭右开，而java time 中没有提供类似l的 API，因为 JSR-310 标准中没有这个概念。\nDateTime dt1 = new DateTime();DateTime dt2 = new DateTime().plusDays(1);Interval interval = new Interval(dt1.toInstant(), dt2.toInstant());\n\nMySQL日期时间官网文档：https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html\nMySQL中重要的内建日期函数\n\n\n\n函数\n描述\n\n\n\nNOW()\n返回当前的日期和时间\n\n\nCURDATE()\n返回当前的日期\n\n\nCURTIME()\n返回当前的时间\n\n\nDATE()\n提取日期或日期/时间表达式的日期部分\n\n\nTIME()\n返回参数表达式中的时间部分\n\n\nEXTRACT()\n返回日期/时间的单独部分\n\n\nDATE_ADD()\n向日期添加指定的时间间隔\n\n\nDATE_SUB()\n从日期减去指定的时间间隔\n\n\nDATEDIFF()\n返回两个日期之间的天数\n\n\nDATE_FORMAT()\n用不同的格式显示日期/时间\n\n\nDAY()\nDAYOFMONTH() 的别名\n\n\nDAYNAME()\n返回某天在用星期中的名称\n\n\nDAYOFMONTH()\n返回某天是当月的第几天 （1-31）\n\n\nDAYOFWEEK()\n返回某天是该星期的第几天\n\n\nDAYOFYEAR()\n返回某天是一年中的第几天（1-366）\n\n\nLAST_DAY()\n返回参数日期所在月份的最后一天\n\n\nDATE_FORMAT()\n根据格式字符串对日期值进行格式化\n\n\n项目应用根据数据库员工出勤记录生成月报表统计每名员工的出勤率。\n出勤记录表tb_attendance-record\n\n出勤月报表示例\n\n\nAttendanceRecordMapper.java（接口）\n//查询某员工某月出勤数int countOneMonth(@Param(&quot;eid&quot;) int eid,@Param(&quot;month&quot;) String month);//查询某员工某月未迟到出勤数int countEarlyOneMonth(@Param(&quot;eid&quot;) int eid,@Param(&quot;month&quot;) String month,@Param(&quot;time&quot;) String time);\n\nAttendanceRecordMapper.xml\n&lt;select id=&quot;countOneMonth&quot; resultType=&quot;_int&quot;&gt;    select ifnull(t.count,0) from    report.tb_employee e    left join  (select count(1) count,e.id eid    from report.tb_employee e    join report.tb_attendance_record r    on e.id = r.employee_id    where date_format(r.attendance_date,&#x27;%Y-%m&#x27;) = #&#123;month&#125;    group by e.id) as t    on e.id = t.eid    where id = #&#123;eid&#125;&lt;/select&gt;&lt;select id=&quot;countEarlyOneMonth&quot; resultType=&quot;_int&quot;&gt;    select ifnull(t.count,0) from    report.tb_employee e    left join  (select count(1) count,e.id eid    from report.tb_employee e    join report.tb_attendance_record r    on e.id = r.employee_id    where date_format(r.attendance_date,&#x27;%Y-%m&#x27;) = #&#123;month&#125; and time(r.accurate_time) &amp;lt; #&#123;time&#125;    group by e.id) as t    on e.id = t.eid    where id = #&#123;eid&#125;&lt;/select&gt;\n\nAttendanceRecordService（接口）\n//获取月出勤记录List&lt;Map&lt;String,String&gt;&gt; getMonthList(String month);//获取月出勤迟到记录List&lt;Map&lt;String,String&gt;&gt; getMonthLateList(String month, String time);\n\nAttendanceRecordServiceImpl（实现类）\n@Overridepublic List&lt;Map&lt;String, String&gt;&gt; getMonthList(String month) &#123;    List&lt;Employee&gt; employees = employeeMapper.getAll();    ArrayList&lt;Map&lt;String, String&gt;&gt; records = new ArrayList&lt;&gt;();    for (Employee employee : employees) &#123;        Map&lt;String, String&gt; record = new LinkedHashMap&lt;&gt;();        int id = employee.getId();        record.put(&quot;id&quot;,String.valueOf(id));        String name = employee.getName();        record.put(&quot;name&quot;,name);        int attendance = attendanceRecordMapper.countOneMonth(employee.getId(),month);        int countDay = DateUtil.getCountDay(month);        double attendanceRate = (double)(Math.round(attendance * 1.0 / countDay * 100) / 100.0);        record.put(&quot;attendanceRate&quot;,String.valueOf(attendanceRate));        record.put(&quot;attendanceDay&quot;,String.valueOf(attendance));        record.put(&quot;absenceDay&quot;,String.valueOf(countDay - attendance));        records.add(record);    &#125;    return records;&#125;@Overridepublic List&lt;Map&lt;String, String&gt;&gt; getMonthLateList(String month, String time) &#123;    List&lt;Employee&gt; employees = employeeMapper.getAll();    ArrayList&lt;Map&lt;String, String&gt;&gt; records = new ArrayList&lt;&gt;();    for (Employee employee : employees) &#123;        int lateDay = DateUtil.getCountDay(month) - attendanceRecordMapper.countEarlyOneMonth(employee.getId(),month,time);        if(lateDay &gt; 0)&#123;            Map&lt;String, String&gt; record = new LinkedHashMap&lt;&gt;();            int id = employee.getId();            record.put(&quot;id&quot;,String.valueOf(id));            record.put(&quot;name&quot;,String.valueOf(employee.getName()));            record.put(&quot;lateDay&quot;,String.valueOf(lateDay));            records.add(record);        &#125;    &#125;    return records;&#125;\n\nDateUtil.java\nimport java.text.SimpleDateFormat;import java.util.Calendar;public class DateUtil &#123;    public static Calendar getNextMonth(String month)&#123;        Calendar cal = Calendar.getInstance();        try &#123;            cal.setTime(new SimpleDateFormat(&quot;yyyy-MM&quot;).parse(month));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        cal.add(Calendar.MONTH, 1);        cal.set(Calendar.DAY_OF_MONTH,1);        return cal;    &#125;    public static int getMonthDay(String month)&#123;        Calendar cal = Calendar.getInstance();        try &#123;            cal.setTime(new SimpleDateFormat(&quot;yyyy-MM&quot;).parse(month));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        //获取某月最大天数        int monthDay = cal.getActualMaximum(Calendar.DAY_OF_MONTH);        return monthDay;    &#125;    public static int getCountDay(String month)&#123;        Calendar today = Calendar.getInstance();        Calendar nextMonth = DateUtil.getNextMonth(month);        int countDay = DateUtil.getMonthDay(month);        if(today.compareTo(nextMonth) == -1)&#123;            countDay = Calendar.getInstance().get(Calendar.DAY_OF_MONTH);        &#125;        return countDay;    &#125;&#125;\n\n","tags":["Java","JavaSE","MySQL"]},{"title":"LeetCode 389.找不同","url":"/2020/12/18/LeetCode389-%E6%89%BE%E4%B8%8D%E5%90%8C/","content":"题目描述：\n给定两个字符串 s 和 t，它们只包含小写字母。\n字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。\n请找出在 t 中被添加的字母。\n示例：\n输入：s = “abcd”, t = “abcde”输出：”e”\n解法一：计数\n思路：遍历字符串 s 和 t，对其中字符的计数值加1 / 减1，被添加的字符的计数值为 -1。\n解法二：求和\n思路：分别求出字符串 s 和 t 中每个字符的ASCII码值的和，两者的差值即为添加字符的ASCII码。\n解法三：位运算\n异或的性质：\n\n交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b\n任何数于0异或为任何数 0 ^ n =&gt; n\n相同的数异或为0: n ^ n =&gt; 0\n\n思路：对两个字符串每个字符进行异或，找出求字符串中出现奇数次的字符。\nclass Solution &#123;    public char findTheDifference(String s, String t) &#123;        int ret = 0;        for (int i = 0; i &lt; s.length(); ++i) &#123;            ret ^= s.charAt(i);        &#125;        for (int i = 0; i &lt; t.length(); ++i) &#123;            ret ^= t.charAt(i);        &#125;        return (char) ret;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/find-the-difference/\n","tags":["算法","LeetCode","位运算"]},{"title":"SpringBoot教程","url":"/2021/03/20/SpringBoot%E6%95%99%E7%A8%8B/","content":"1 简介Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像Maven整合了所有的jar包，Spring Boot整合了所有的框架 。\n所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，由于原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。\nSpring Boot的主要优点：\n\n为所有Spring开发者更快的入门\n开箱即用，提供各种默认配置来简化项目配置\n内嵌式容器简化Web项目\n没有冗余代码生成和XML配置的要求\n\n2 第一个SpringBoot程序官方提供了一个快速生成的网站，IDEA集成了这个网站，可以在官网（https://start.spring.io/）直接下载后导入IDEA开发；一般都是直接使用IDEA创建一个SpringBoot项目。\n1、在主程序的同级目录下，新建一个controller包；\n2、在包中新建一个HelloController类；\nimport org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;Hello World&quot;;    &#125;&#125;\n\n3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回（控制台输出了 Tomcat 访问的端口号）。\n3 运行原理启动器 spring-boot-starter\nSpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 。\nspringboot-boot-starter-xxx：spring-boot的场景启动器\nspring-boot-starter-web：导入web模块正常运行所依赖的组件\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n主启动类 XXXApplication\n//@SpringBootApplication 来标注一个主配置类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class XXXApplication &#123;   public static void main(String[] args) &#123;     //以为是启动了一个方法，没想到启动了一个服务      SpringApplication.run(SpringbootApplication.class, args);   &#125;&#125;\n\n@SpringBootApplication\nSprnig Boot项目的核心注解，目的是开启自动配置 ，运行标注类的main方法来启动SpringBoot应用。\n@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(    excludeFilters = &#123;@Filter(    type = FilterType.CUSTOM,    classes = &#123;TypeExcludeFilter.class&#125;), @Filter(    type = FilterType.CUSTOM,    classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;    // ......&#125;\n\n​    @ComponentScan\n​    自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中。\n​    @SpringBootConfiguration：SpringBoot的配置类\n// 点进去得到下面的 @Component@Configuration // 这是一个配置类public @interface SpringBootConfiguration &#123;&#125;@Component // 启动类本身也是Spring中的一个组件public @interface Configuration &#123;&#125;\n\n​    @EnableAutoConfiguration：开启自动配置\n​        @AutoConfigurationPackage ：自动配置包\n @Import(&#123;Registrar.class&#125;) // Spring底层注解@import ， 给容器中导入一个组件// Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描注册到Spring容器public @interface AutoConfigurationPackage &#123;&#125;\n\n​        @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 \n​        AutoConfigurationImportSelector ：自动配置导入选择器\n​        getCandidateConfigurations → loadFactoryNames → loadSpringFactories\n​        获取资源 “META-INF/spring.factories”（spring.factories 中有很多自动配置类，这就是自动配置根源所在），将读取到的资源遍历，封装成为一个Properties，返回启动自动导入配置文件的注解类：EnableAutoConfiguration\n结论：\n\nSpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，并将这些值作为自动配置类导入容器，自动配置类就生效，从而进行自动配置工作；\nSpringBoot会给容器中导入非常多的自动配置类 （xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件 ，免去了我们手动编写配置注入功能组件等的工作；\n整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中。\n\nSpringApplication.run分析\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication主要做了以下四件事情：\n\n推断应用的类型是普通的项目还是Web项目；\n\n查找并加载所有可用初始化器 ， 设置到initializers属性中；\n\n找出所有的应用程序监听器，设置到listeners属性中；\n\n推断并设置main方法的定义类，找到运行的主类。\n\n\n构造器：\npublic SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;    // ......    this.webApplicationType = WebApplicationType.deduceFromClasspath();    this.setInitializers(this.getSpringFactoriesInstances();    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));    this.mainApplicationClass = this.deduceMainApplicationClass();&#125;\n\nrun方法执行流程\n\n4 YAML配置SpringBoot使用一个全局的配置文件 ：application.properties(key=value) / application.yml(key: value)。该配置文件可以修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了。\n\nYAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写，在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）\n\n这种语言以数据作为中心，而不是以标记语言为重点！\n4.1 基础语法# 普通键值对k: v# 对象/Mapobj: \tk1: v1    k2: v2obj: &#123;k1: v1,k2: v2&#125;#数组/List/Setarr:\t- e1\t- e2\t- e3arr: [e1,e2,e3]\n\n注意：单引号中特殊字符最终会变成和普通字符一样输出！\n4.2 注入配置文件通过**@Value**给bean设置注入值（通过@Autowired注入）\n@Component //注册beanpublic class Dog &#123;    @Value(&quot;阿黄&quot;)    private String name;    @Value(&quot;18&quot;)    private Integer age;    //有参无参构造、get、set方法、toString()方法 &#125;\n\n\n\n复杂实体类Person\n@Component //注册bean到容器中public class Person &#123;    private String name;    private Integer age;    private Boolean happy;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;        //有参无参构造、get、set方法、toString()方法  &#125;\n\nyaml配置实体类属性\nperson:  name: XXX  age: 3  happy: false  birth: 2000/01/01  maps: &#123;k1: v1,k2: v2&#125;  lists:   - code   - girl   - music  dog:    name: 旺财    age: 1\n\n配置文件占位符\nperson:    name: XXX$&#123;random.uuid&#125; # 随机uuid    age: $&#123;random.int&#125;  # 随机int    happy: false    birth: 2000/01/01    maps: &#123;k1: v1,k2: v2&#125;    lists:      - code      - girl      - music    dog:      name: $&#123;person.hello:other&#125;_旺财      age: 1\n\n通过**@ConfigurationProperties**读取yaml配置实体属性\n/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123;    private String name;    private Integer age;    private Boolean happy;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;&#125;\n\nIDEA提示，SpringBoot配置处理器没有找到。可以导入配置文件处理器的Maven依赖。\n&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;  &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n\n\nproperties配置文件注入\n配置文件user.properties\nuser.name=XXXuser.age=18user.sex=男\n\n通过**@PropertySource**读取properties文件，使用@Value进行注入。\n@Component //注册bean@PropertySource(value = &quot;classpath:user.properties&quot;)public class User &#123;    //直接使用@value    @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值    private String name;    @Value(&quot;#&#123;9*2&#125;&quot;)  // #&#123;SpEL&#125; Spring表达式    private int age;    @Value(&quot;男&quot;)  // 字面量    private String sex;&#125;\n\n@Value VS @ConfigurationProperties\n\n@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加；\n\n松散绑定（yml中写的last-name，这个和lastName是一样的）： - 后面跟着的字母默认是大写的；\n\nJSR303数据校验：在字段是增加一层过滤器验证 ， 可以保证数据的合法性；\n\n复杂类型封装，yml中可以封装对象 ， 使用value则不支持。\n\n\n4.3 多配置选择application.properties\nspring.profiles.active=devserver.port=8080\n\napplication-dev.properties\nserver.port=8081\n\napplication-test.properties\nserver.port=8082\n\napplication.yml\nserver:\tport: 8081spring:\tprofiles:\t\tactive: dev---server:\tport: 8082spring:\tprofiles:dev\t---server:\tport: 8083spring:\tprofiles:test\n\n4.4 自动配置原理SpringBoot官方文档中有大量的配置。自动配置类根据当前不同的条件（@Conditional派生注解）判断，决定这个配置类是否生效，一旦这个配置类生效，这个配置类就会给容器中添加各种组件；\n这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类。\nxxxxAutoConfigurartion：自动配置类：给容器中添加组件\nxxxxProperties：封装配置文件中相关属性\n可以通过启用debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效。\n5 JSR303数据校验Springboot中可以用@validated来校验数据，保证数据的重要性。\n@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated  //数据校验public class Person &#123;    @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式    private String name;&#125;\n\n常见数据校验注解\n@NotNull(message=&quot;名字不能为空&quot;)private String userName;@Max(value=120,message=&quot;年龄最大不能查过120&quot;)private int age;@Email(message=&quot;邮箱格式错误&quot;)private String email;//空检查@Null       //验证对象是否为null@NotNull    //验证对象是否不为null, 无法查检长度为0的字符串@NotBlank   //检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty   //检查约束元素是否不为NULL或者是EMPTY，用于集合    //Booelan检查@AssertTrue     //验证 Boolean 对象是否为 true  @AssertFalse    //验证 Boolean 对象是否为 false      //长度检查@Size(min=, max=) //验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min=, max=) //string is between min and max included.//日期检查@Past       //验证 Date 和 Calendar 对象是否在当前时间之前  @Future     //验证 Date 和 Calendar 对象是否在当前时间之后  //除此以外，我们还可以自定义一些数据校验规则@Pattern    //验证 String 对象是否符合正则表达式的规则\n\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：\n优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件，互补配置。\n6 Web开发初步解决问题：\n导入静态资源\n首页\n模板引擎thymeleaf\n装配扩展SpringMVC\n则删改查\n拦截器\n国际化\n6.1 静态资源处理6.1.1 webjarsSpringBoot中，SpringMVC的web配置都在配置类WebMvcAutoConfiguration 里，其中有一个方法：addResourceHandlers。 （添加资源处理）\n@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    if (!this.resourceProperties.isAddMappings()) &#123;        // 已禁用默认资源处理        logger.debug(&quot;Default resource handling disabled&quot;);        return;    &#125;    // 缓存控制    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();    // webjars 配置    // 所有的 /webjars/** ，都需要去classpath:/META-INF/resources/webjars/找对应的资源    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    &#125;    // 静态资源配置    String staticPathPattern = this.mvcProperties.getStaticPathPattern();    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    &#125;&#125;\n\nWebjars本质就是以jar包的方式引入我们的静态资源 ， 使用Webjars，可以去https://www.webjars.org 搜索。\n&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;/groupId&gt;    &lt;artifactId&gt;jquery&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;\n\n只要是静态资源，SpringBoot就会去对应的路径寻找资源，这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js\n6.1.2 本地导入staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties。\n// 进入方法public String[] getStaticLocations() &#123;    return this.staticLocations;&#125;// 找到对应的值private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;// 找到路径private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;     &quot;classpath:/META-INF/resources/&quot;,  &quot;classpath:/resources/&quot;,     &quot;classpath:/static/&quot;,     &quot;classpath:/public/&quot; &#125;;\n\nResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。\n也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置。\n spring.resources.static-locations=classpath:/coding/,classpath:/zhg/\n\n6.2 首页处理@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,                                                           FormattingConversionService mvcConversionService,                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页        this.mvcProperties.getStaticPathPattern());    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));    return welcomePageHandlerMapping;&#125;// 点进去private Optional&lt;Resource&gt; getWelcomePage() &#123;    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());    // ::是java8 中新引入的运算符    // Class::function的时候function是属于Class的，应该是静态方法。    // this::function的funtion是属于这个对象的。    // 简而言之，就是一种语法糖而已，是一种简写    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;// 欢迎页就是一个location下的的 index.html 而已private Resource getIndexHtml(String location) &#123;    return this.resourceLoader.getResource(location + &quot;index.html&quot;);&#125;\n\n欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。\n与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。\n需要关闭默认图标并清除浏览器缓存！\n#关闭默认图标spring.mvc.favicon.enabled=false\n\n7 模板引擎Thymeleaf官方文档：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html\n&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-thymeleaf --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;\n\nThymeleaf的自动配置类：ThymeleafProperties\n@ConfigurationProperties(    prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123;    private static final Charset DEFAULT_ENCODING;    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; //默认前缀    public static final String DEFAULT_SUFFIX = &quot;.html&quot;; //默认后缀    private boolean checkTemplate = true;    private boolean checkTemplateLocation = true;    private String prefix = &quot;classpath:/templates/&quot;; //页面存放路径    private String suffix = &quot;.html&quot;;    private String mode = &quot;HTML&quot;;    private Charset encoding;&#125;\n\nThymeleaf语法基础可以使用任意th:attr替换html中的原生属性\n\n表达式\n\nSimple expressions:\nVariable Expressions: $&#123;...&#125;\nSelection Variable Expressions: *&#123;...&#125;\nMessage Expressions: #&#123;...&#125;\nLink URL Expressions: @&#123;...&#125;\nFragment Expressions: ~&#123;...&#125;\n\n\nLiterals\nText literals: &#39;one text&#39;, &#39;Another one!&#39;,…\nNumber literals: 0, 34, 3.0, 12.3,…\nBoolean literals: true, false\nNull literal: null\nLiteral tokens: one, sometext, main,…\n\n\nText operations:\nString concatenation: +\nLiteral substitutions: |The name is $&#123;name&#125;|\n\n\nArithmetic operations:\nBinary operators: +, -, *, /, %\nMinus sign (unary operator): -\n\n\nBoolean operations:\nBinary operators: and, or\nBoolean negation (unary operator): !, not\n\n\nComparisons and equality:\nComparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)\nEquality operators: ==, != (eq, ne)\n\n\nConditional operators:\nIf-then: (if) ? (then)\nIf-then-else: (if) ? (then) : (else)\nDefault: (value) ?: (defaultvalue)\n\n\nSpecial tokens:\nNo-Operation: _\n\n\n\nAll these features can be combined and nested:\n&#x27;User is of type &#x27; + ($&#123;user.isAdmin()&#125; ? &#x27;Administrator&#x27; : ($&#123;user.type&#125; ?: &#x27;Unknown&#x27;))\n\n测试\nController\n@RequestMapping(&quot;/t2&quot;)public String test2(Map&lt;String,Object&gt; map)&#123;    //存入数据    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);    map.put(&quot;users&quot;, Arrays.asList(&quot;u1&quot;,&quot;u2&quot;));    //classpath:/templates/test.html    return &quot;test&quot;;&#125;\n\ntest.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;狂神说&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--不转义--&gt;&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--遍历数据--&gt;&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;&lt;h4&gt;    &lt;!--行内写法：官网#12--&gt;    &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;\n\n8 SpringMVC扩展文档地址：https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-developing-web-applications.html\n8.1 自定义视图解析器WebMvcAutoConfiguration类中找到ContentNegotiatingViewResolver方法。\n@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);    return resolver;&#125;// 点进ContentNegotiatingViewResolver类，发现该类实现了ViewResolver接口（实现了ViewResolve接口的类可以看作视图解析器）@Nullable // 注解说明：@Nullable 即参数可为nullpublic View resolveViewName(String viewName, Locale locale) throws Exception &#123;    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());    if (requestedMediaTypes != null) &#123;        // 获取候选的视图对象        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);        // 选择一个最适合的视图对象，然后把这个对象返回        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);        if (bestView != null) &#123;            return bestView;        &#125;    &#125;    // .....&#125;\n\n结论：从beanFactory工具中获取容器中的所有视图解析器，ViewRescolver.class组合所有的视图解析器，在容器中去找最合适的视图解析器并返回。\n自定义视图解析器\npublic class MyMvcConfig implements WebMvcConfigurer&#123;    @Bean //放到bean中    public ViewResolver myViewResolver()&#123;        return new MyViewResolver();    &#125;    //静态内部类实现ViewResolver接口    private static class MyViewResolver implements ViewResolver&#123;        @Override        public View resolveViewName(String s, Locale locale) throws Exception &#123;            return null;        &#125;    &#125;&#125;\n\n8.2 格式化转换器WebMvcAutoConfiguration类中找到mvcConversionService方法。\n@Beanpublic FormattingConversionService mvcConversionService() &#123;    Format format = this.mvcProperties.getFormat();    WebConversionService conversionService = new WebConversionService((new DateTimeFormatters()).dateFormat(format.getDate()).timeFormat(format.getTime()).dateTimeFormat(format.getDateTime()));    this.addFormatters(conversionService);    return conversionService;&#125;\n\n发现mvcProperties，配置格式化（spring.mvc.format.date格式化日期）\n8.3 修改默认配置SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；如果有些组件可以存在多个，就将用户配置的和默认的组合起来！\n扩展使用SpringMVC需要编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解（@EnableWebMvc注解导入了类DelegatingWebMvcConfiguration）。\n//因为类型要求为WebMvcConfigurer，所以我们实现其接口//可以使用自定义类扩展MVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        // 浏览器发送/test ， 就会跳转到test页面；        registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;);    &#125;&#125;\n\n8.4 全面接管SpringMVC全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！只需在我们的配置类中要加一个@EnableWebMvc。如果我们全面接管了SpringMVC了，SpringBoot给我们配置的静态资源映射一定会无效。\n自动配置就失效原因分析\n// @EnableWebMvc注解导入了类DelegatingWebMvcConfiguration@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125;// 它继承了一个父类 WebMvcConfigurationSupportpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;  // ......&#125;// 而Webmvc自动配置类上有注解@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,    ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;    &#125;\n\n9 页面国际化\n先在IDEA设置File Encoding中统一设置properties的编码为UTF-8；\n\n编写配置文件；\n\nresources资源文件下新建一个i18n目录，存放国际化配置文件；\n\n先建立login.properties文件，再建立login_zh_CN.properties文件（发现IDEA自动识别了国际化操作，合并文件夹）；\n\n可以合并文件夹中新建一个文件，按照提示可以快捷输入地区（en_US）；\n\n编写三个配置文件。\n可以通过配置文件下方的Resource Bundle进行可视化配置。\nlogin.properties\nlogin.btn=登录login.password=密码login.remember=记住我login.tip=请登录login.username=用户名\n\nlogin_en_US.properties\nlogin.btn=Sign inlogin.password=Passwordlogin.remember=Remember melogin.tip=Please sign inlogin.username=Username\n\nlogin_zh_CN.properties\nlogin.btn=登录login.password=密码login.remember=记住我login.tip=请登录login.username=用户名\n\n\n\n配置messages的路径：spring.messages.basename=i18n.login；\n\n配置页面（Thymeleaf）国际化值（Thymeleaf的文档，找到message取值操作为：#{…}）；\n\n配置国际化解析。\n\n前端页面的跳转连接；\n&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;\n\n写一个自定义的处理的组件类LocaleResolver，可以在链接上携带区域信息;\nimport org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;//可以在链接上携带区域信息public class MyLocaleResolver implements LocaleResolver &#123;    //解析请求    @Override    public Locale resolveLocale(HttpServletRequest request) &#123;        String language = request.getParameter(&quot;l&quot;);        Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的        //如果请求链接不为空        if (!StringUtils.isEmpty(language))&#123;            //分割请求参数            String[] split = language.split(&quot;_&quot;);            //国家，地区            locale = new Locale(split[0],split[1]);        &#125;        return locale;    &#125;    @Override    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;    &#125;&#125;\n\n为了让我们的区域化信息能够生效，在自定义的MvcConofig下添加bean；\n@Beanpublic LocaleResolver localeResolver()&#123;    return new MyLocaleResolver();&#125;\n\n\n\n\n\n10 整合JDBC对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot底层都是采用Spring Data的方式进行统一处理各种数据库，Spring Data也是Spring中与Spring Boot、Spring Cloud等齐名的知名项目。\nSping Data官网：https://spring.io/projects/spring-data\n\n新建项目，引入相应模块（Spring Web，JDBC API，MySQL Driver）；\n\n编写yaml配置文件连接数据库；\nspring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver\n\n配置完，就可以直接去使用了，因为SpringBoot已经默认进行了自动配置。\n@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;    //DI注入数据源    @Autowired    DataSource dataSource;    @Test    public void contextLoads() throws SQLException &#123;        //看一下默认数据源        System.out.println(dataSource.getClass());        //获得连接        Connection connection =   dataSource.getConnection();        System.out.println(connection);        //关闭连接        connection.close();    &#125;&#125;\n\nSpring Boot 2.2.5 默认使用HikariDataSource 数据源，HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀。\n\n编写一个Controller，注入jdbcTemplate，编写测试方法进行访问测试。\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;/jdbc&quot;)public class JdbcController &#123;    /**     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接     */    @Autowired    JdbcTemplate jdbcTemplate;    //查询employee表中所有数据    //List 中的1个 Map 对应数据库的 1行数据    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值    @GetMapping(&quot;/list&quot;)    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;        String sql = &quot;select * from employee&quot;;        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);        return maps;    &#125;        //新增一个用户    @GetMapping(&quot;/add&quot;)    public String addUser()&#123;        //插入语句，注意时间问题        String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +                &quot; values (&#x27;狂神说&#x27;,&#x27;24736743@qq.com&#x27;,1,101,&#x27;&quot;+ new Date().toLocaleString() +&quot;&#x27;)&quot;;        jdbcTemplate.update(sql);        //查询        return &quot;addOk&quot;;    &#125;    //修改用户信息    @GetMapping(&quot;/update/&#123;id&#125;&quot;)    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;        //插入语句        String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id;        //数据        Object[] objects = new Object[2];        objects[0] = &quot;秦疆&quot;;        objects[1] = &quot;24736743@sina.com&quot;;        jdbcTemplate.update(sql,objects);        //查询        return &quot;updateOk&quot;;    &#125;    //删除用户    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;        //插入语句        String sql = &quot;delete from employee where id=?&quot;;        jdbcTemplate.update(sql,id);        //查询        return &quot;deleteOk&quot;;    &#125;    &#125;\n\n即使不使用第三方第数据库操作框架，如 MyBatis等，Spring本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。\nJdbcTemplate主要提供以下几类方法：\n\nexecute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\nupdate方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；\nquery方法及queryForXXX方法：用于执行查询相关语句；\ncall方法：用于执行存储过程、函数相关语句。\n\n\n\n11 整合DruidDruid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。\nGithub地址：https://github.com/alibaba/druid/\ncom.alibaba.druid.pool.DruidDataSource 基本配置参数\n\n\n\n配置\n缺省值\n说明\n\n\n\nname\n\n配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。  如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this)\n\n\njdbcUrl\n\n连接数据库的url，不同数据库不一样。例如：  mysql : jdbc:mysql://10.20.153.104:3306/druid2  oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto\n\n\nusername\n\n连接数据库的用户名\n\n\npassword\n\n连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\n\n\ndriverClassName\n根据url自动识别\n这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)\n\n\ninitialSize\n0\n初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时\n\n\nmaxActive\n8\n最大连接池数量\n\n\nmaxIdle\n8\n已经不再使用，配置了也没效果\n\n\nminIdle\n\n最小连接池数量\n\n\nmaxWait\n\n获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\n\n\npoolPreparedStatements\nfalse\n是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。\n\n\nmaxOpenPreparedStatements\n-1\n要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100\n\n\nvalidationQuery\n\n用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。\n\n\ntestOnBorrow\ntrue\n申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n\n\ntestOnReturn\nfalse\n归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\n\n\ntestWhileIdle\nfalse\n建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n\n\ntimeBetweenEvictionRunsMillis\n\n有两个含义：  1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n\n\nnumTestsPerEvictionRun\n\n不再使用，一个DruidDataSource只支持一个EvictionRun\n\n\nminEvictableIdleTimeMillis\n\n\n\n\nconnectionInitSqls\n\n物理连接初始化的时候执行的sql\n\n\nexceptionSorter\n根据dbType自动识别\n当数据库抛出一些不可恢复的异常时，抛弃连接\n\n\nfilters\n\n属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：  监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall\n\n\nproxyFilters\n\n类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系\n\n\n配置Druid数据源\n添加Druid数据源Maven依赖；\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;\n\n在yaml配置文件中切换数据源并设置数据源连接初始化大小、最大连接数、等待时间、最小连接数等；\nspring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource #自定义数据源    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n导入Log4j的Maven依赖；\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\n为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中。\nimport com.alibaba.druid.pool.DruidDataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class DruidConfig &#123;    /*       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中     */    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    @Bean    public DataSource druidDataSource() &#123;        return new DruidDataSource();    &#125;&#125;\n\n\n\n测试数据源连接。\n@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;    //DI注入数据源    @Autowired    DataSource dataSource;    @Test    public void contextLoads() throws SQLException &#123;        //看一下默认数据源        System.out.println(dataSource.getClass());        //获得连接        Connection connection =   dataSource.getConnection();        System.out.println(connection);        DruidDataSource druidDataSource = (DruidDataSource) dataSource;        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());        //关闭连接        connection.close();    &#125;&#125;\n\n配置Druid数据源监控Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看。\n\n设置 Druid 的后台管理页面（登录账号、密码……），配置后台管理。\n//配置 Druid 监控管理后台的Servlet；//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式@Beanpublic ServletRegistrationBean statViewServlet() &#123;    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet     // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号    initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码    //后台允许谁可以访问    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问    initParams.put(&quot;allow&quot;, &quot;&quot;);    //deny：Druid 后台拒绝谁访问    //initParams.put(&quot;deny&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问    //设置初始化参数    bean.setInitParameters(initParams);    return bean;&#125;\n\n配置 Druid web 监控 filter 过滤器。\n//配置 Druid 监控 之  web 监控的 filter//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计@Beanpublic FilterRegistrationBean webStatFilter() &#123;    FilterRegistrationBean bean = new FilterRegistrationBean();    bean.setFilter(new WebStatFilter());    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;);    bean.setInitParameters(initParams);    //&quot;/*&quot; 表示过滤所有请求    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));    return bean;&#125;\n\n\n\n12 整合Mybatis官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\n\n导入Mybatis所需的Maven依赖（maven配置资源过滤）；\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;...&lt;resources&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;        &lt;filtering&gt;true&lt;/filtering&gt;    &lt;/resource&gt;&lt;/resources&gt;\n\n配置数据库连接信息；\nspring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n整合Mybatis\nmybatis.type-aliases-package=com.zhg.pojomybatis.mapper-locations=classpath:mybatis/mapper/*.xml\n\n创建实体类；\nDepartement.java\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class Department &#123;    private Integer id;    private String departmentName;&#125;\n\n创建mapper目录以及对应的 Mapper接口；\nDepartmentMapper.java\n//@Mapper : 表示本类是一个 MyBatis 的 Mapper@Mapper@Repositorypublic interface DepartmentMapper &#123;    // 获取所有部门信息    List&lt;Department&gt; getDepartments();    // 通过id获得部门    Department getDepartment(Integer id);&#125;\n\n编写Mapper映射文件；\nDepartmentMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.DepartmentMapper&quot;&gt;    &lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt;       select * from department;    &lt;/select&gt;    &lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt;       select * from department where id = #&#123;id&#125;;    &lt;/select&gt;&lt;/mapper&gt;\n\n编写Controller进行测试。\nDepartmentController.java\n@RestControllerpublic class DepartmentController &#123;        @Autowired    DepartmentMapper departmentMapper;        // 查询全部部门    @GetMapping(&quot;/getDepartments&quot;)    public List&lt;Department&gt; getDepartments()&#123;        return departmentMapper.getDepartments();    &#125;    // 查询全部部门    @GetMapping(&quot;/getDepartment/&#123;id&#125;&quot;)    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id)&#123;        return departmentMapper.getDepartment(id);    &#125;    &#125;\n\n\n\n13 SpringSecurity两个框架：Shiro、SpringSecurity\n\n功能权限\n访问权限\n菜单权限\n…拦截器，过滤器：大量冗余\n\n思想：AOP\nSpring Security是一个功能强大、高度可定制的身份验证和访问控制框架，它也是SpringBoot底层安全模块默认的技术选型，专注于向Java应用程序提供身份验证和授权。\nSpringSecurity的两个主要目标是”认证“和”授权“（访问控制）。\n\nWebSecurityConfigurationAdapter：自定义Security策略\nAuthenticationManagerBuilder：自定义认证策略\n@EnableWebSecurity：开启WebSecurity模式\n\n官网：https://spring.io/projects/spring-security\n文档：https://docs.spring.io/spring-security/site/docs/5.2.0.RELEASE/reference/htmlsingle/\n使用 Spring Security 增加认证和授权的功能，实现访问控制。\n1 引入 Spring Security 模块\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2 编写 Spring Security 配置类\npackage com.zhg.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter&#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        // 定制请求的授权规则        // 首页所有人可以访问        http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()                .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)                .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)                .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);                // 开启自动配置的登录功能                // /login 请求来到登录页                // /login?error 重定向到这里表示登录失败                http.formLogin();    &#125;    //定义认证规则    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        //在内存中定义，也可以在jdbc中去拿....        //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。        //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密        //spring security 官方推荐的是使用bcrypt加密方式。        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;zhg&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);    &#125;&#125;\n\n13.1 注销1 开启自动配置的注销的功能；\n//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;   //....   //开启自动配置的注销的功能      // /logout 注销请求   http.logout();&#125;\n\n2 index.html 导航栏中增加注销按钮；\n&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销&lt;/a&gt;\n\n3 可以通过logoutSuccessUrl指定注销成功跳转的网页。\n// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页http.logout().logoutSuccessUrl(&quot;/&quot;);\n\n注：为防止csrf跨站请求伪造，可能会出现注销404，可以将请求改为post表单提交，或者在spring security中关闭csrf功能。\nhttp.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求http.logout().logoutSuccessUrl(&quot;/&quot;);\n\n13.2 权限控制结合thymeleaf中的sec:authorize=&quot;isAuthenticated()&quot;判断是否认证登录来显示不同的页面。\n1 导入Maven依赖；\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.thymeleaf.extras&#x2F;thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;&#x2F;artifactId&gt;   &lt;version&gt;3.0.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;\n\n2 修改前端页面；\n2.1 导入命名空间\n xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;\n\n2.2 修改导航栏，增加认证判断\n &lt;!--登录注销--&gt;&lt;div class=&quot;right menu&quot;&gt;   &lt;!--如果未登录--&gt;   &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录       &lt;/a&gt;   &lt;/div&gt;   &lt;!--如果已登录--&gt;   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;       &lt;a class=&quot;item&quot;&gt;           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;          用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;          角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;       &lt;/a&gt;   &lt;/div&gt;   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;       &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销       &lt;/a&gt;   &lt;/div&gt;&lt;/div&gt;\n\n2.3 修改主页，实现角色功能块\n&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt;   &lt;div class=&quot;ui raised segment&quot;&gt;       &lt;div class=&quot;ui&quot;&gt;           &lt;div class=&quot;content&quot;&gt;               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;               &lt;hr&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt;   &lt;div class=&quot;ui raised segment&quot;&gt;       &lt;div class=&quot;ui&quot;&gt;           &lt;div class=&quot;content&quot;&gt;               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;               &lt;hr&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt;   &lt;div class=&quot;ui raised segment&quot;&gt;       &lt;div class=&quot;ui&quot;&gt;           &lt;div class=&quot;content&quot;&gt;               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;               &lt;hr&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;&lt;/div&gt;\n\n13.3 记住我1 开启记住我功能；\n//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;//...   //记住我   http.rememberMe();&#125;\n\n2 浏览器中保存用户信息的cookie，默认保留14天；\n3 点击注销的时自动删除了这个 cookie；\n结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie。\n13.4 定制登录页1 通过loginpage指定登录页面 ；\nhttp.formLogin().loginPage(&quot;/toLogin&quot;);\n\n2 login.html 配置提交请求及方式，方式必须为post；\n&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;   &lt;div class=&quot;field&quot;&gt;       &lt;label&gt;Username&lt;/label&gt;       &lt;div class=&quot;ui left icon input&quot;&gt;           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;div class=&quot;field&quot;&gt;       &lt;label&gt;Password&lt;/label&gt;       &lt;div class=&quot;ui left icon input&quot;&gt;           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;&lt;/form&gt;\n\n3 配置接收登录的用户名和密码的参数；\nhttp.formLogin()  .usernameParameter(&quot;username&quot;)  .passwordParameter(&quot;password&quot;)  .loginPage(&quot;/toLogin&quot;)  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求\n\n4 登录页增加记住我的多选框；\n&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我\n\n5 后端验证处理。\n//定制记住我的参数！http.rememberMe().rememberMeParameter(&quot;remember&quot;);\n\n完整配置代码package com.zhg.config;importorg.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;importorg.springframework.security.config.annotation.web.configuration.EnableWebSecurity;importorg.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;   //定制请求的授权规则   @Override   protected void configure(HttpSecurity http) throws Exception &#123;       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！           // /login 请求来到登录页           // /login?error 重定向到这里表示登录失败       http.formLogin()          .usernameParameter(&quot;username&quot;)          .passwordParameter(&quot;password&quot;)          .loginPage(&quot;/toLogin&quot;)          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求       //开启自动配置的注销的功能           // /logout 注销请求           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求       http.logout().logoutSuccessUrl(&quot;/&quot;);       //记住我       http.rememberMe().rememberMeParameter(&quot;remember&quot;);  &#125;   //定义认证规则   @Override   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;       //在内存中定义，也可以在jdbc中去拿....       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密       //spring security 官方推荐的是使用bcrypt加密方式。       auth.inMemoryAuthentication().passwordEncoder(newBCryptPasswordEncoder())              .withUser(&quot;kuangshen&quot;).password(newBCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)              .and()              .withUser(&quot;root&quot;).password(newBCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)              .and()              .withUser(&quot;guest&quot;).password(newBCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);  &#125;&#125;\n\n14 ShiroApache Shiro是一个Java的安全（权限）框架，JavaSE和JavaEE环境中都可以使用，可以完成认证、授权、加密、会话管理、Web集成、缓存等。\n下载地址：http://shiro.apache.org/\n14.1 Shiro功能\n\nAuthentication：身份认证、登录，验证用户身份； \n\nAuthorization：授权，即权限验证，验证用户权限，即判断用户能否进行相应权限的操作；\n\nSession Manager：会话管理，存储会话中用户登录的所有信息；会话可以是普通的JavaSE环境，也可以是Web环境；\n\nCryptography：加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储； \n\nWeb Support：Web支持，可以非常容易的集成到Web环境； \n\nCaching：缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，可以提高效率； \n\nConcurrency：Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去 ；\n\nTesting：提供测试支持； \n\nRun As：允许一个用户假装为另一个用户（如果允许）的身份进行访问； \n\nRemember Me：记住我，不用重复登录。\n\n\n14.2 Shiro架构\nsubject： 应用代码直接交互的对象是Subject，是Shiro的对外API的核心， Subject代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，与Subject的所有交互都会委托给SecurityManager；\nSecurityManager：安全管理器，即所有与安全有关的操作都会与SercurityManager交互，并且它管理着所有的Subject，可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于 SpringMVC的DispatcherServlet的角色； \nRealm：Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager 要验证用户身份，那么它需要从Realm 获取相应的用户进行比较，来确定用户的身份是否合法；也需要从 Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把Realm看成 DataSource；\n14.3 整合Shiro\n导入Shiro和Spring整合的依赖；\n&lt;dependency&gt;\t&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\t&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\t&lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;\n\n编写Shiro配置类；\npackage com.zhg.config;import org.springframework.context.annotation.Configuration;//声明为配置类@Configurationpublic class ShiroConfig &#123;\t    //创建 ShiroFilterFactoryBean\t    //创建 DefaultWebSecurityManager\t    //创建 realm 对象&#125;\n\n创建自定义realm类；\npackage com.zhg.config;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;//自定义Realmpublic class UserRealm extends AuthorizingRealm &#123;\t//执行授权逻辑\t@Override\tprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;\t\tSystem.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);\t\treturn null;\t&#125;    //执行认证逻辑\t@Override\tprotected AuthenticationInfodoGetAuthenticationInfo(AuthenticationToken token) throwsAuthenticationException &#123;\t\tSystem.out.println(&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;);\t\treturn null;\t&#125;&#125;\n\n将realm类注册到Bean中；\npackage com.zhg.config;import org.springframework.context.annotation.Configuration;//声明为配置类@Configurationpublic class ShiroConfig &#123;\t    //创建 ShiroFilterFactoryBean\t    //创建 DefaultWebSecurityManager\t    //创建 realm 对象    @Bean\tpublic UserRealm userRealm()&#123;\t\treturn new UserRealm();\t&#125;&#125;\n\n创建DefaultWebSecurityManager；\n//创建 DefaultWebSecurityManager@Bean(name = &quot;securityManager&quot;)public DefaultWebSecurityManagergetDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;)UserRealm userRealm)&#123;\tDefaultWebSecurityManager securityManager = newDefaultWebSecurityManager();\t//关联Realm\tsecurityManager.setRealm(userRealm);\treturn securityManager;&#125;\n\n创建ShiroFilterFactoryBean。\n//创建 ShiroFilterFactoryBean@Beanpublic ShiroFilterFactoryBeangetShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;)DefaultWebSecurityManager securityManager)&#123;\tShiroFilterFactoryBean shiroFilterFactoryBean = newShiroFilterFactoryBean();\t//设置安全管理器\tshiroFilterFactoryBean.setSecurityManager(securityManager);\treturn shiroFilterFactoryBean;&#125;\n\n\n\n14.4 登录认证\n整合数据库，导入Mybatis相关依赖，配置Mybatis并编写UserService，实现queryUserByName（查询用户信息）；\n\n编写登录的Controller和登录页面；\nUserController\n//登录操作@RequestMapping(&quot;/login&quot;)public String login(String username,String password,Model model)&#123;\t//使用shiro，编写认证操作\t    //1. 获取Subject\tSubject subject = SecurityUtils.getSubject();\t//2. 封装用户的数据\tUsernamePasswordToken token = new UsernamePasswordToken(username,password);\t//3. 执行登录的方法，只要没有异常就代表登录成功！\ttry &#123;\t\tsubject.login(token); //登录成功！返回首页\t\treturn &quot;index&quot;;\t&#125; catch (UnknownAccountException e) &#123; //用户名不存在\t\tmodel.addAttribute(&quot;msg&quot;,&quot;用户名不存在&quot;);\t\treturn &quot;login&quot;;\t&#125; catch (IncorrectCredentialsException e) &#123; //密码错误\t\tmodel.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;);\t\treturn &quot;login&quot;;\t&#125;&#125;\n\n在 UserRealm 中编写用户认证的判断逻辑。\n//自定义Realmpublic class UserRealm extends AuthorizingRealm &#123;\t@Autowired\tUserService userService;    \t//执行授权逻辑\t@Override\tprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;\t\tSystem.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);\t\treturn null;\t&#125;    \t//执行认证逻辑\t@Override\tprotected AuthenticationInfodoGetAuthenticationInfo(AuthenticationToken token) throwsAuthenticationException &#123;\t\tSystem.out.println(&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;);        UsernamePasswordToken userToken = (UsernamePasswordToken)token;\t\t//真实连接数据库\t\tUser user =userService.queryUserByName(userToken.getUsername());        if (user==null)&#123;\t\t\t//用户名不存在\t\t\treturn null; //shiro底层就会抛出 UnknownAccountException\t\t&#125;\t\treturn new SimpleAuthenticationInfo(&quot;&quot;, user.getPwd(), &quot;&quot;);\t&#125;&#125;\n\n\n\n14.5 拦截和授权页面拦截\n\n添加Shiro的内置过滤器。\n@Beanpublic ShiroFilterFactoryBeangetShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;)DefaultWebSecurityManager securityManager)&#123;\tShiroFilterFactoryBean shiroFilterFactoryBean = newShiroFilterFactoryBean();\t//设置安全管理器\tshiroFilterFactoryBean.setSecurityManager(securityManager);    /*        添加Shiro内置过滤器，常用的有如下过滤器：        anon： 无需认证就可以访问        authc： 必须认证才可以访问        user： 如果使用了记住我功能就可以直接访问        perms: 拥有某个资源权限才可以访问        role： 拥有某个角色权限才可以访问    */    Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String, String&gt;();    //filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);\t//filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);    //授权过滤器\t//filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);\tfilterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);\t//修改到要跳转的login页面；\tshiroFilterFactoryBean.setLoginUrl(&quot;/toLogin&quot;);    return shiroFilterFactoryBean;&#125;\n\n\n\nShiro授权\n\n数据库用户表增加用户权限字段并修改实体类；\n\n将用户放在Principle中；\nreturn new SimpleAuthenticationInfo(user, user.getPwd(), &quot;&quot;);\n\n获取用户权限并授权；\n//执行授权逻辑@Overrideprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;    System.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);    //给资源进行授权    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();    //添加资源的授权字符串    //info.addStringPermission(&quot;user:add&quot;);    Subject subject = SecurityUtils.getSubject(); //获得当前对象    User currentUser = (User) subject.getPrincipal(); //拿到User对象    info.addStringPermission(currentUser.getPerms()); //设置权限    return info;&#125;\n\n请求权限拦截。\n//授权过滤器filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;);\n\n\n\n","tags":["Java","SpringBoot"]},{"title":"JVM探究","url":"/2021/04/24/JVM%E6%8E%A2%E7%A9%B6/","content":"\n面试常见问题：\nJVM的理解？Java8虚拟机变化更新？\nOOM？栈溢出？怎么分析？\nJVM常用调优参数？\n内存快照如何抓取？怎么分析Dump文件？\n类加载器的认识？\n\n1  JVM的位置   \n2 JVM的体系结构   \n3 类加载器   作用：加载Class文件\n   new 对象 （引用：栈 值：堆） \n   getClass class类\n   getClassLoader 类加载器\n\nBootstrapClassLoader（启动类加载器）\nc++编写，加载java核心库 java.*,构造ExtClassLoader和AppClassLoader。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作\n\nExtClassLoader （标准扩展类加载器）\njava编写，加载扩展库，如classpath中的jre ，javax.*或者 java.ext.dir 指定位置中的类，开发者可以直接使用标准扩展类加载器。\n\nAppClassLoader（系统类加载器）\njava编写，加载程序所在的目录，如user.dir所在的位置的class\n\nCustomClassLoader（用户自定义类加载器）\njava编写,用户自定义的类加载器,可加载指定路径的class文件\n\n\n4 双亲委派机制   当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。\n   \n   作用：\n\n防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。\n保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。\n\n5 沙箱安全机制   沙箱是指一个限制程序运行的环境。\n   沙箱机制就是将JAVA代码限定在JVM特定的运行环境中 ，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。\n   沙箱主要限制系统资源（CPU,内存,文件系统,网络）访问，不同级别的沙箱对这些资源访问的限制也可以不一样。\n   所有的java程序运行都可以指定沙箱，可以定制安全策略。\n   组成沙箱的基本组件：\n\n字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。\n\n类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用\n\n它防止恶意代码去干涉善意的代码；\n它守护了被信任的类库边界；\n它将代码归入保护域，确定了代码可以进行哪些操作。\n\n  虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。\n  类装载器采用的机制是双亲委派模式。\n\n从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；\n由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。\n\n\n存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。\n\n安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。\n\n安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：\n\n安全提供者\n消息摘要\n数字签名\n加密\n鉴别\n\n\n\n6 Native带了native关键字的方法会进入本地方法栈调用本地接口（JNI，底层C语言库），不受Java语法规则约束。\nJNI作用：扩展Java的使用，融合不同语言。\n7 PC寄存器程序计数器（Program Counter Register）：每个线程都有一个程序计数器，是指向方法区中的方法字节码（指令代码）的指针，使执行引擎读取下一条指令。\n8 方法区方法区被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。\n静态变量、常量、类信息（构造方法、接口定义）。运行时常量池存在方法区中；但是实例变量存在堆内存中，和方法区无关。\nstatic final Class 常量池 → 方法区\n9 栈栈内存，主管程序的运行，生命周期和线程同步；\n线程结束，栈内存也是释放，对于栈不存在垃圾回收问题。\n栈存储8大基本类型、对象引用和实例方法。\n运行原理：栈帧 \n10 三种JVM\nSun公司的HotSpot 是目前使用范围最广的Java虚拟机。\n\nBEA公司的JRockit（原来的 Bea JRockit）电脑软件，系列产品是一个全面的Java运行时解决方案组合。\n\nIBM公司的J9 VM 是一个高性能的企业级 Java 虚拟机。\n\n\n11 堆一个JVM只有一个堆，可以调整大小。\n堆中存放类、方法、常量、保存所有引用类型的真实对象。\n堆内存可以分为三个区域：\n\n新生代（Eden，Survive From，Survive To）\nMinor GC\n\n老年代（Old）\nFull GC\n\n永久代（Perm）：常驻内存，存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境或者类信息。该区域不存在垃圾回收，关闭JVM就会释放这个空间的内存。\nOOM可能原因：加载了大量的第三方jar包、Tomcat部署了太多的应用、大量动态生成的反射类，不断的被加载。\n\nJDK1.6之前：永久代，常量池是在方法区\nJDK1.7：永久代慢慢退化，去永久代，常量池在堆中\nJDK 1.8之后：无永久代，常量池在元空间\n\n\n\n12 堆内存调优默认情况下，JVM分配的总内存是电脑内存的1/4，而初始化内存是1/64。可以通过-Xms1024m -Xmx1024m -XX:PrintGCDetails进行堆内存调优。\n内存参数\n-Xms1024m （堆初始化内存）     X-Memory Startup\n-Xmx1024m （堆的最大内存）     X-Memory Maximum, 注意: 堆内存大小=年轻代(1/3)+老年代(2/3)\n-Xmn256m （堆-年轻代大小）     X-Memory New, 注意: 老年代大小=Xmx-年轻代, 年轻代占比\n-Xss256k （棧-最大深度大小）     X-Stack Size\n-XX:MetaspaceSize=?m （元空间默认大小） , 注意: 元空间默认大小取决于系统内存,实测64bit-16G电脑, 默认30M\n-XX:MaxMetaspaceSize=?m （元空间最大大小） , 注意: 只要不设置上限,只要电脑内存足够就会动态增加\n-XX:SurvivorRatio=? （默认值:8, 即新生代分区比例默认 8:2, 即 Eden:S1:S2=8:1:1, S1约定于S2)\n-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器） \n-XX:+PrintGCDetails （打印详细的GC日志）\n注意:jdk1.8已经移除了-XX:PermSize 和  -XX:MaxPermGen，取而代之的是 Metaspace\n元空间在堆中逻辑上存在，物理上不存在。\nOOM：\n\n尝试扩大堆内存看结果\n\n分析内存（专业工具）\n\n\nOOM故障排查：\n\n能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler\nDebug，一行行分析代码！\n\nMAT，Jprofiler作用：\n\n分析Dump文件，快速分析内存泄露；\n获得堆中的数据；\n获得大的对象\n\n13 GC（常用算法）Minor GC\nFull GC\n判断对象是否可以回收：引用计数法（循环引用）、可达性分析（根搜索算法）。\n-XX:MaxTenuringThreshold设定新生代进入老年代的年龄阈值。\n垃圾回收算法标记—清除算法标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。\n复制算法复制算法是将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。\n复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。\n标记—整理算法标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。\n分代收集算法分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。\n一般把 Java 堆分为新生代和老年代。在新生代中，大多数对象的生命周期都很短，因此选用复制算法。在老年代中，对象存活率高，因此选用标记—清除算法或标记—整理算法。\n14 JMMJMM（Java Memory Model）定义了Java 虚拟机（JVM）在计算机内存（RAM）中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\nvolatile → 共享对象可见性\nJava内存模型定义了以下八种操作来完成：\n\nlock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。\nunlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\nread（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\nload（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\nuse（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\nassign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\nstore（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。\nwrite（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。\n\nJava内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：\n\n如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。\n不允许read和load、store和write操作之一单独出现\n不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。\n不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。\n一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。\n一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现\n如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值\n如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。\n对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。\n\n","tags":["Java","JVM"]},{"title":"面试总结（Java+测开）","url":"/2021/04/14/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88Java-%E6%B5%8B%E5%BC%80%EF%BC%89/","content":"Java基础语法final关键字（***）\nfinal用于修饰类、成员变量和成员方法。\n\nfinal修饰的类：不能被继承（String、StringBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被重写（这里需要注意的是不能被重写，但是可以被重载），所以不能同时用abstract和final修饰类（abstract修饰的类是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；\nfinal修饰的方法：不能被重写，但是子类可以用父类中final修饰的方法；\nfinal修饰的成员变量：是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的。\n\nstatic关键字\nJAVA类在加载时类信息、全局变量和方法、静态变量、final修饰的变量会被存到方法区，局部变量存储在栈内存中，当实例化一个对象时就将非static修饰的方法和变量复制到堆内存中以便对象引用，线程则被加载到寄存器运行。\n所以static修饰的变量和方法是独立于对象而存在的，不产生副本，可以直接用类名来调用。（当然也可以通过对象和this来调用，局部变量不能用this调用）\n一.static修饰的变量static修饰的变量当且仅当类被加载时初始化。而非static变量在实例化对象时被初始化，产生多个副本，多个对象不互相影响。\n局部变量不能被static修饰\nstatic不改变变量和方法的作用域，其作用域只受四个访问修饰符的影响\n二.static修饰的方法被static修饰的方法内部不能调用非static的变量和方法，非static方法内部可以调用static变量的方法和变量。\n三.static修饰的代码块static修饰的代码块在且只在类被加载时执行一次。\n执行顺序：static代码块优于构造快优于构造方法。\nJava8性能优化（字符串拼接）\n字符串拼接常用到的几种方式如下：\n　　1、“+”拼接；\n　　2、concat拼接；\n　　3、StringBuilder（StringBuff）拼接。\n其中第一种方式拼接字符串在我的视眼中是最常见的，孰不知第一种方式是最不值得提倡的（性能消耗大，效率低），concat是由String类提供的封装类性能较“+”好很多，相较于前两者StringBuilder的速度基本可以忽略，快太多了。\nStringBuffer和StringBuilder的实现实现原理和操作基本上一致，主要差别是StringBuffer是由synchronized修饰，支持并发操作线程安全的类。而StringBuilder是不支持并发操作的，所以多线程时建议使用StringBuffer。单线程中StringBuilder的性能要好于StringBuffer。\nHashMap（***）\n数据结构：数组+链表（+红黑树）\n插入方式：头插→尾插\n冲突解决：拉链法 \nHashSet\n实现原理：HashSet是基于HashMap实现的，都是一个存放链表的数组。它不保证存储元素的迭代顺序，允许使用null元素，不允许有重复元素。当向HashSet中添加对象时，首先调用此对象所在类的hashCode()方法，计算次对象的哈希值，此哈希值决定了此对象在HashSet中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。因此，如果想实现自定义去重，需要重写model的hashcode方法和equals方法。\nHashSet和HashMap的区别：(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对；\n(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true。\n线程不安全\nHashMap的线程不安全体现在会造成死循环、数据丢失、数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖这样的问题。\nHashMap的线程不安全主要是发生在扩容函数中，即根源是在transfer函数中；\nJDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，1.8的源码中不存在transfer函数，因为JDK1.8直接在resize函数中完成了数据迁移。而且JDK1.8在进行元素插入时使用的是尾插法。\nConcurrentHashMap\n​        与HashMap不同，ConcurrentHashMap采用分段锁的思想实现并发操作，因此是线程安全的。ConcurrentHashMap由多个Segment组成（Segment的数量也是锁的并发度），每 个Segment均继承自ReentrantLock并单独加锁，所以每次进行加锁操作时锁住的都是一个 Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。 \n​        在ConcurrentHashMap中有个concurrencyLevel参数表示并行级别，默认是 16，也就是 说ConcurrentHashMap默认由 16个Segments组成，在这种情况下最多同时支持 16个线程并 发执行写操作，只要它们的操作分布在不同的Segment上即可。并行级别concurrencyLevel 可以在初始化时设置，一旦初始化就不可更改。ConcurrentHashMap的每个Segment内部的 数据结构都和HashMap相同。\n权限修饰符（可见性修饰符）\n\n\n\n修饰符\n类内访问\n包内访问\n子类访问\n不同包访问\n\n\n\npublic\n√\n√\n√\n√\n\n\nprotected\n√\n√\n√\n×\n\n\n默认\n√\n√\n×\n×\n\n\nprivate\n√\n×\n×\n×\n\n\n​    子类可以覆盖父类的 protected 方法，并把该方法的可见性改成 public。但是子类不能降低父类方法的可见性，即不能把父类的 public 方法的可见性改成 protected。\n序列化\n​        把对象转换成字节序列的过程称为对象的序列化，把字节序列恢复成对象的过程称为对象的反序列化。\n​        Serializable 接口的作用是标识一个对象是否可被序列化，只有当一个类实现了 Serializable 接口时，这个类的实例才是可序列化的。这个接口是标识接口，不包含任何数据域和方法。\n​        关键字 transient 的作用是指定数据域不被序列化。当一个数据域不能被序列化，或者不想对一个数据域序列化时，给这个数据域加上关键字 transient，在序列化的过程中将忽略这个数据域。\n多线程线程实现\n方式一：继承Thread类的方式\n\n创建一个继承于Thread类的子类\n重写Thread类中的run()：将此线程要执行的操作声明在run()\n创建Thread的子类的对象\n调用此对象的start():①启动线程 ②调用当前线程的run()方法\n\n方式二：实现Runnable接口的方式\n\n创建一个实现Runnable接口的类\n实现Runnable接口中的抽象方法：run():将创建的线程要执行的操作声明在此方法中\n创建Runnable接口实现类的对象\n将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象\n调用Thread类中的start():① 启动线程 ② 调用线程的run() —&gt;调用Runnable接口实现类的run()\n\n以下两种方式是jdk1.5新增的！\n方式三：实现Callable接口\n说明：\n\n与使用Runnable相比， Callable功能更强大些\n实现的call()方法相比run()方法，可以返回值\n方法可以抛出异常\n支持泛型的返回值\n需要借助FutureTask类，比如获取返回结果\n\n\nFuture接口可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。\nFutureTask是Futrue接口的唯一的实现类\nFutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值\n\n方式四：使用线程池\n说明：\n\n提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。\n\n好处：\n\n 提高响应速度（减少了创建新线程的时间）\n 降低资源消耗（重复利用线程池中线程，不需要每次都创建）\n 便于线程管理\n\nimport java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.FutureTask;import java.util.concurrent.ThreadPoolExecutor;//方式一class ThreadTest extends Thread &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);\t\t&#125;\t&#125;&#125;// 方式二class RunnableTest implements Runnable &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);\t\t&#125;\t&#125;&#125;// 方式三class CallableTest implements Callable&lt;Integer&gt; &#123;\t@Override\tpublic Integer call() throws Exception &#123;\t\tint sum = 0;\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);\t\t\tsum += i;\t\t&#125;\t\treturn sum;\t&#125;&#125;// 方式四class ThreadPool implements Runnable &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 10; i++) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);\t\t&#125;\t&#125;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\t// 继承Thread\t\tThreadTest thread = new ThreadTest();\t\tthread.setName(&quot;方式一&quot;);\t\tthread.start();\t\t// 实现Runnable\t\tRunnableTest runnableTest = new RunnableTest();\t\tThread thread2 = new Thread(runnableTest, &quot;方式二&quot;);\t\tthread2.start();\t\t// 实现Callable&lt;&gt; 有返回值\t\tCallableTest callableTest = new CallableTest();\t\tFutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callableTest);\t\tnew Thread(futureTask, &quot;方式三&quot;).start();\t\t// 返回值\t\ttry &#123;\t\t\tInteger integer = futureTask.get();\t\t\tSystem.out.println(&quot;返回值（sum）：&quot; + integer);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\t// 线程池\t\tExecutorService pool = Executors.newFixedThreadPool(10);\t\tThreadPoolExecutor executor = (ThreadPoolExecutor) pool;\t\t/*\t\t * 可以做一些操作:\t\t * corePoolSize：核心池的大小 \t\t * maximumPoolSize：最大线程数\t\t * keepAliveTime：线程没任务时最多保持多长时间后会终止\t\t */\t\texecutor.setCorePoolSize(5);\t\t// 开启线程\t\texecutor.execute(new ThreadPool());\t\texecutor.execute(new ThreadPool());\t\texecutor.execute(new ThreadPool());\t\texecutor.execute(new ThreadPool());\t&#125;&#125;\n\n\n\n线程池\n理解：线程池是一种线程的使用模式。创建若干个可执行的线程放入一个池（容器）中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程并不会被销毁，而是仍然在线程池中等待下一个任务。\n好处\n\n降低资源消耗。重复利用线程池中已经创建的线程，可以避免频繁地创建和销毁线程，从而减少资源消耗。\n\n提高响应速度。由于线程池中有已经创建的线程，因此当任务到达时，可以直接执行，不需要等待线程创建。\n\n提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n\n使用\n可以通过 ThreadPoolExecutor 类创建线程池。ThreadPoolExecutor 类有 4 个构造方法，其中最一般化的构造方法包含 7 个参数。\ncorePoolSize：核心线程数，定义了最少可以同时运行的线程数量，当有新的任务时就会创建一个线程执行任务，当线程池中的线程数量达到 corePoolSize 之后，到达的任务进入阻塞队列。\nmaximumPoolSize：最大线程数，定义了线程池中最多能创建的线程数量。\nkeepAliveTime：等待时间，当线程池中的线程数量大于 corePoolSize 时，如果一个线程的空闲时间达到 keepAliveTime 时则会终止，直到线程池中的线程数不超过 corePoolSize。\nunit：参数 keepAliveTime 的单位。\nworkQueue：阻塞队列，用来存储等待执行的任务。\nthreadFactory：创建线程的工厂。\nhandler：当拒绝处理任务时的策略。\n可以通过方法 execute 向线程池提交任务。该方法被调用时，线程池会做如下操作。\n\n如果正在运行的线程数量小于 corePoolSize，则创建核心线程运行这个任务。\n\n如果正在运行的线程数量大于或等于 corePoolSize，则将这个任务放入阻塞队列。\n\n如果阻塞队列满了，而且正在运行的线程数量小于 maximumPoolSize，则创建非核心线程运行这个任务。\n\n如果阻塞队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，则线程池抛出 RejectExecutionException 异常。\n\n\n上述操作中提到了两个概念，「核心线程」和「非核心线程」。核心线程和非核心线程的最大数目在创建线程池时被指定。核心线程和非核心线程的区别如下。\n向线程池提交任务时，首先创建核心线程运行任务，直到核心线程数到达上限，然后将任务放入阻塞队列。\n只有在核心线程数到达上限，且阻塞队列满的情况下，才会创建非核心线程运行任务。\nsynchronized\nsynchronized关键字用于为Java对象、方法、代码块提供线程安全的操作。\n synchronized属于独占式的悲观锁，同时属于可重入锁。\n在使用synchronized修饰对象时， 同一时刻只能有一个线程对该对象进行访问；在synchronized修饰方法、代码块时，同一 时刻只能有一个线程执行该方法体或代码块，其他线程只有等待当前线程执行完毕并释放锁资源后才能访问该对象或执行同步代码块。\n Java中的每个对象都有个monitor对象，加锁就是在竞争monitor对象。对代码块加锁 是通过在前后分别加上monitorenter和monitorexit指令实现的，对方法是否加锁是通过一个 标记位来判断的。 \n作用范围：\n ◎ synchronized作用于成员变量和非静态方法时，锁住的是对象的实例，即this对象。 \n◎ synchronized作用于静态方法时，锁住的是Class实例，因为静态方法属于Class而不 属于对象。\n ◎ synchronized作用于一个代码块时，锁住的是所有代码块中配置的对象。 \n静态方法 / 非静态方法\n1.Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。\n情况1：同一个对象在两个线程中分别访问该对象的两个同步方法\n结果：会产生互斥。\n解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。\n情况2：不同对象在两个线程中调用同一个同步方法\n结果：不会产生互斥。\n解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，\n2.Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。\n情况1：用类直接在两个线程中调用两个不同的同步方法\n结果：会产生互斥。\n解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。\n注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。\n情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法\n结果：会产生互斥。\n解释：因为是一个对象调用，同上。\n情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法\n结果：不会产生互斥。\n解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。\n锁\n(synchronized、juc 提供的锁如 ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore等)\n公平锁/非公平锁 (重要)\n可重入锁\n独享锁/共享锁 (重要)\n互斥锁/读写锁\n乐观锁/悲观锁 (重要)\n偏向锁/轻量级锁/重量级锁 (重要)\n自旋锁\n乐观锁 / 悲观锁乐观锁与悲观锁区别在于看待并发同步的角度。悲观锁对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。\n乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。\n乐观锁适用于写比较少的情况下（多读场景），一般多写的场景下用悲观锁就比较合适，一 般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能。\n锁升级\n偏向锁/轻量级锁/重量级锁\n这三种锁是指锁的状态，并且是针对Synchronized。\n偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。\n重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下 去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。 重量级锁会让其他申请的线程进入阻塞，性能降低。\n自旋锁\n自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样 的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。\n乐观锁（**）\n​        乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁，但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法。具体过程为：比较当前版本号与上一次的版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读、比较、写操作。\n​         Java中的乐观锁大部分是通过CAS（Compare And Swap，比较和交换）操作实现的， CAS是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。\nvolatile / synchronized\n\nvolatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\nvolatile仅能使用在变量级别；synchronized则可以使用在代码块、方法和类级别的\nvolatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。\nvolatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。\n\nJVMJVM体系结构\nJava 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。\n\n注：\n\n程序计数器是唯一不会出现 OutOfMemoryError 的内存区域。\n\n虚拟机栈描述的是 Java 方法执行的内存模型。当一个方法被执行时会创建栈帧存入栈内，栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。\n\n虚拟机栈可能出现的两种异常是 StackOverflowError 和 OutOfMemoryError。\n\n如果虚拟机栈不可以动态扩展，当线程请求的栈深度大于虚拟机所允许的深度时，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展，当无法申请到足够的内存时，将抛出 OutOfMemoryError 异常。\n\n堆是 Java 虚拟机管理的内存中最大的一块，其目的是存放对象实例，几乎所有的对象实例都在堆中分配内存。\n\n静态变量存放在方法区。\n\n\n内存泄露\n原因\n内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。\nJava内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：\n1、静态集合类引起内存泄漏：\n像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。\n2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。\n3、监听器\n在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。\n4、各种连接\n比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。\n5、内部类和外部模块的引用\n内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：\npublic void registerMsg(Object b);\n这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。\n6、单例模式\n不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。\n垃圾回收\n内存分配\n​        Java 堆可以分成新生代和老年代，新生代又可以细分成 Eden 区、From Survivor 区、To Survivor 区等。对于不同的对象，有相应的内存分配规则。\n\n\n对象优先在 Eden 区分配大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。\n\n大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间分配给大对象。\n将大对象直接在老年代中分配的目的是避免在 Eden 区和 Survivor 区之间出现大量内存复制。\n\n长期存活的对象进入老年代虚拟机采用分代收集的思想管理内存，因此需要识别每个对象应该放在新生代还是老年代。虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过第一次 Minor GC 之后仍然存活，将进入 Survivor 区，同时对象年龄变为 1，对象在 Survivor 区每经过一次 Minor GC 且存活，年龄就增加 1，增加到一定阈值时则进入老年代（阈值默认为 15）。\n\n动态对象年龄判定为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。\n\n\n回收策略\nMinor GC 和 Full GCMinor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会频繁执行，一般回收速度也比较快。\nFull GC 也称 Major GC，指发生在老年代的垃圾回收操作。出现了 Full GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。\n参数调优\n内存参数\n-Xms1024m （堆初始化内存）     X-Memory Startup\n-Xmx1024m （堆的最大内存）     X-Memory Maximum, 注意: 堆内存大小=年轻代(1/3)+老年代(2/3)\n-Xmn256m （堆-年轻代大小）     X-Memory New, 注意: 老年代大小=Xmx-年轻代, 年轻代占比\n-Xss256k （棧-最大深度大小）     X-Stack Size\n-XX:MetaspaceSize=?m （元空间默认大小） , 注意: 元空间默认大小取决于系统内存,实测64bit-16G电脑, 默认30M\n-XX:MaxMetaspaceSize=?m （元空间最大大小） , 注意: 只要不设置上限,只要电脑内存足够就会动态增加\n-XX:SurvivorRatio=? （默认值:8, 即新生代分区比例默认 8:2, 即 Eden:S1:S2=8:1:1, S1约定于S2)\n-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器） \n-XX:+PrintGCDetails （打印详细的GC日志）\n注意:jdk1.8已经移除了-XX:PermSize 和  -XX:MaxPermGen，取而代之的是 Metaspace\n设计模式单例模式\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n优点：\n\n在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n避免对资源的多重占用（比如写文件操作）。\n\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n应用场景：\n\n要求生产唯一序列号。\nWEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n饿汉式\npublic class Singleton &#123;      private static Singleton instance = new Singleton();      private Singleton ()&#123;&#125;      public static Singleton getInstance() &#123;      return instance;      &#125;  &#125;\n\nDCL懒汉式\npublic class Singleton &#123;      private volatile static Singleton singleton; // volatile保证没有指令重排     private Singleton ()&#123;&#125;      public static Singleton getSingleton() &#123;      if (singleton == null) &#123;          synchronized (Singleton.class) &#123;          if (singleton == null) &#123;              singleton = new Singleton(); // 不是一个原子性操作，存在指令重排：1.分配内存空间 2.执行构造方法，初始化对象 3.对象指向空间         \t&#125;          &#125;      &#125;      return singleton;      &#125;  &#125;\n\n静态内部类\npublic class Singleton &#123;    // 静态内部类    private static class SingletonHolder &#123;      \tprivate static final Singleton INSTANCE = new Singleton();      &#125;          private Singleton ()&#123;&#125;      public static final Singleton getInstance() &#123;      return SingletonHolder.INSTANCE;      &#125;  &#125;\n\n反射破坏单例，但枚举能够避免单例模式被破坏（枚举类型反编译，发现枚举类型是有参构造）\n//反射public static void main(String[] args) throws Exception&#123;    Singleton instance = Singleton.getInstance();    Constructor&lt;Singleton&gt; declaredConstructor = Singleton.class.getDeclaredConstructor(null);    declaredConstructor.setAccessible(true);    Singleton instance2 = declaredConstructor.newInstance();    System.out.println(instance==instance2); // false&#125;public enum EnumSingleton &#123;      INSTANCE;      public EnumSingleton getInstance() &#123;        return INSTANCE;    &#125;  &#125;// Constructor&lt;Singleton&gt; declaredConstructor = SingletonEnum.class.getDeclaredConstructor(String.class,int.class); → Exception: Cannot reflectively create enum objects\n\n\n\n工厂模式\n工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。通过工厂模式实现了创建者和调用者的分离。\n优点： \n\n一个调用者想创建一个对象，只要知道其名称就可以了。 \n扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 \n屏蔽产品的具体实现，调用者只关心产品的接口。\n\n缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n应用场景：\n\nJDK中的Calendar的getInstance方法\nJDBC中的Connection对象的获取\nSpring中IOC容器创建管理bean对象\n反射中Class对象的newInstance方法\n\n简单工厂模式（Simple Factory），常用！\n\n动态代理\n\n动态代理和静态代理角色一样\n\n动态代理的代理类是动态生成的，不是直接写好的\n\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n\n基于接口——JDK动态代理\n\n基于类：cglib\n​        CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。\n​        CGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。我们知道Java中有一个动态代理也是做这个事情的，那我们为什么不直接使用Java动态代理，而要使用CGLIB呢？答案是CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。\n\nJava字节码实现：JAVAssist\n\n\n\n\n需要了解两个类：Proxy，InvocationHandler\n【InvocationHandler：调用处理程序】\nInvocationHandler是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。\nObject invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。\n\n【Proxy  : 代理】\nProxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理对象的超类。\n//生成代理类//public static Object newProxyInstance(Classloader loader,类&lt;&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException//loader - 类加载器来定义代理类//interfaces - 代理类实现的接口列表//h - 调度方法调用的调用处理程序public Object getProxy()&#123;   return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);&#125;\n\n代码实现：\nRent - 抽象角色\n//抽象角色：租房public interface Rent &#123;   public void rent();&#125;\n\nHost  - 真实角色\n//真实角色：房东，房东要出租房子public class Host implements Rent&#123;   public void rent() &#123;       System.out.println(&quot;房屋出租&quot;);  &#125;&#125;\n\nProxyInvocationHandler - 代理角色\npublic class ProxyInvocationHandler implements InvocationHandler &#123;   private Rent rent;   public void setRent(Rent rent) &#123;       this.rent = rent;  &#125;   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色   public Object getProxy()&#123;       return Proxy.newProxyInstance(this.getClass().getClassLoader(),               rent.getClass().getInterfaces(),this);  &#125;   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.   // 处理代理实例上的方法调用并返回结果   @Override   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;       seeHouse();       //核心：本质利用反射实现！       Object result = method.invoke(rent, args);       fare();       return result;  &#125;   //看房   public void seeHouse()&#123;       System.out.println(&quot;带房客看房&quot;);  &#125;   //收中介费   public void fare()&#123;       System.out.println(&quot;收中介费&quot;);  &#125;&#125;\n\nClient - 租客\n//租客public class Client &#123;   public static void main(String[] args) &#123;       //真实角色       Host host = new Host();       //代理实例的调用处理程序       ProxyInvocationHandler pih = new ProxyInvocationHandler();       pih.setRent(host); //将真实角色放置进去！       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！       proxy.rent();  &#125;&#125;\n\n核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！\n动态代理的好处：\n\n可以使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 ；\n公共的业务由代理来完成 ，实现了业务的分工 ；\n公共业务发生扩展时变得更加集中和方便 ；\n一个动态代理 , 一般代理某一类业务；\n一个动态代理可以代理多个类，代理的是接口。\n\nMVCMVC\nMVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。\n\nModel（模型）代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。\nView（视图）代表模型包含的数据的可视化。\nController（控制器）控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。\n\nSpring中Bean的作用域\nSpring IOC容器创建一个Bean实例时，可以为Bean指定实例的作用域，作用域包括singleton（单例模式）、prototype（原型模式）、request（HTTP请求）、session（会话）、global-session（全局会话）。\nSession / Cookie\nCookie 和 Session都是用来跟踪浏览器用户身份的会话方式。\nCookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态\nCookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将Cookie 信息加密然后使用到的时候再去服务器端解密。\nCookie的缺点：\n(1) 每个特定域名下的cookie数量有限：\nIE6或IE6-(IE6以下版本)：最多20个cookie\nIE7或IE7+(IE7以上版本)：最多50个cookie\nFF:最多50个cookie\nOpera:最多30个cookie\nChrome和safari没有硬性限制\n当超过单个域名限制之后，再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会清理近期最少使用的cookie，FF会随机清理cookie；\n(2) 存储量太小，只有4KB；\n(3) 每次HTTP请求都会发送到服务端，影响获取资源的效率；\n(4) 需要自己封装获取、设置、删除cookie的方法；\n表单重复提交\n​        表单重复提交会造成数据重复，增加服务器负载，严重甚至会造成服务器宕机。因此有效防止表单重复提交有一定的必要性。\n解决方案\n\n利用JavaScript防止表单重复提交\n对按钮进行控制：在第一次点提交的时候将button设置为disable。\n做状态位进行标识：设置一个标志位了来判断是不是第一次提交。\n\n\n利用Session防止表单重复提交\n令牌（Token）：在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。\n\n\n\nSpringBoot / SpringMVC\nspring boot就是一个大框架里面包含了许许多多的东西，其中spring就是最核心的内容之一，当然也就包含spring mvc。\nspring mvc 只是spring 处理web层请求的一个模块。\nSpringMVC 执行流程\n\n1、 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。6、DispatcherServlet将模型数据填充到视图中7、DispatcherServlet将结果响应给用户\nAOP\n概念\nJoinpoint（连接点）：程序执行时的某个特定的点，在Spring中就是某一个方法的执行 。Pointcut（切点）：说的通俗点，spring中AOP的切点就是指一些方法的集合，而这些方法是需要被增强、被代理的。一般都是按照一定的约定规则来表示的，如正则表达式等。切点是由一类连接点组成。Advice（通知)：还是说的通俗点，就是在指定切点上要干些什么。Advice定义横切逻辑，Spring中支持5种类型的Advice。Advisor（通知器)：其实就是切点和通知的结合 。\n实现\n1.经典的基于代理的AOP（CGLIB动态代理）\n2.@AspectJ注解驱动的切面（注解实现）\n@Aspectpublic class AnnotationPointcut &#123;   @Before(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   @After(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   @Around(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void around(ProceedingJoinPoint jp) throws Throwable &#123;       System.out.println(&quot;环绕前&quot;);       System.out.println(&quot;签名:&quot;+jp.getSignature());       //执行目标方法proceed       Object proceed = jp.proceed();       System.out.println(&quot;环绕后&quot;);       System.out.println(proceed);  &#125;&#125;\n\n3.纯POJO切面（实现Spring 增强类的接口）\n&lt;!--aop的配置--&gt;&lt;aop:config&gt;    &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;    &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;    &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;    &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;&lt;/aop:config&gt;\n\n4.注入式AspectJ切面（自定义切入类）\n&lt;!--aop的配置--&gt;&lt;aop:config&gt;   &lt;!--第二种方式：使用AOP的标签实现--&gt;   &lt;aop:aspect ref=&quot;diy&quot;&gt;       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n\n\nJavaScript中let和var区别\n1、作用域不同\nvar是函数作用域，let是块作用域。\n在函数中声明了var，整个函数内都是有效的，比如说在for循环内定义的一个var变量，实际上其在for循环以外也是可以访问的\n而let由于是块作用域，所以如果在块作用域内定义的变量，比如说在for循环内，在其外面是不可被访问的，所以for循环推荐用let\n2、let不能在定义之前访问该变量，但是var可以。\nlet必须先声明，在使用。而var先使用后声明也行，只不过直接使用但没有定义的时候，其值是undefined。var有一个变量提升的过程，当整个函数作用域被创建的时候，实际上var定义的变量都会被创建，并且如果此时没有初始化的话，则默认为初始化一个undefined\n3、let不能被重新定义，但是var是可以的\n分布式Redis\n​        Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：\n\n基于内存运行，性能高效\n支持分布式，理论上可以无限扩展\nkey-value存储系统\n开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API\n\n​        相比于其他数据库类型，Redis具备的特点是：\n\nC/S通讯模型\n单进程单线程模型\n丰富的数据类型\n操作具有原子性\n持久化\n高并发读写\n支持lua脚本\n\n​        Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。\n数据结构\n​        Redis提供的数据类型主要分为5种自有类型和一种自定义类型，这5种自有类型包括：字符串类型、哈希类型、列表类型、集合类型和顺序集合类型。\n\n字符串（String）类型：\n它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。\n\n哈希（Hash）类型：\n该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。\n\n列表（List）类型：该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。\n\n集合（Set）类型：Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。\n\n顺序集合（Zset）类型：ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。\n\n\n\n持久化方法\n​        由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。\nRDB的优点：简称“3更”\n\n体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件\n\n恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存\n\n性能更高:父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。\n\n\n缺点：\n\n故障丢失:因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。\n\n耐久性差:相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。\n\n\nAOF的优点：\n\n数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，咱们也最多丢失一秒数据\n\n自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。\n\n\n缺点：\n\n性能相对较差：它的操作模式决定了它会对redis的性能有所损耗\n\n体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。\n\n恢复速度更慢：\n\n\n过期策略\n三种过期策略：定时删除、惰性删除、定期删除。\nRedis采用的过期策略：惰性删除+定期删除\n\n惰性删除流程\n在进行get或setnx等操作时，先检查key是否过期，\n若过期，删除key，然后执行相应操作；\n若没过期，直接执行相应操作。\n\n\n定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）\n遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）\n检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）\n如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历\n随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key\n判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。\n\n\n\n\n\n\n\n分布式锁\n为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。\n具备条件：\n\n在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；\n\n高可用的获取锁与释放锁；\n\n高性能的获取锁与释放锁；\n\n具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）；\n\n具备锁失效机制，防止死锁具备非阻塞锁特性，即没有获取到锁将直接返\n回获取锁失败。\n\n\n实现方式：\n\n基于数据库实现分布式锁；\n​        基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。\n\n基于缓存（Redis等）实现；\n实现思想：\n（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。\n（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。\n\n基于Zookeeper实现。\nZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：\n（1）创建一个目录mylock；（2）线程A想获取锁就在mylock目录下创建临时顺序节点；（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。\n缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。\n\n\nElasticSearch\n官网：https://www.elastic.co/cn/products/elasticsearch\nElasticsearch是一个采用Restful API标准的高扩展性和高可用性的实时数据分析的全文搜索工具。\n优势：\n\n弹性、高可用\n\n可预见，可信\n\n简单透明\n\n\n与关系数据库的对比\n\n\n\n关系型数据库（MySQL）\n非关系型数据库\n\n\n\n数据库database\n索引 index\n\n\n表 table\n类型 type\n\n\n数据行 row\n文档 document\n\n\n数据列 column\n字段 field\n\n\n小结：\n\nElasticSearch其实就是非关系型数据库，非关系型数据库是相对关系型数据库而言的。\n\n非关系型数据库存储的是非结构化的数据，非结构化数据包括文本、图片、音频。\n\n结构化的数据就是数字符号，数字符号得用关系型数据库去存储，也就是我们常用的mysql、oracle、db2。\n\n\n网络TCP / UDP\n用户数据报协议 UDP是面向无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信。\n传输控制协议 TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条 TCP 连接只能是点对点的（一对一）。\n TCP应用场景：\n效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、 排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。\nUDP应用场景：\n效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。\nUDP为何快？\n不需要建立连接对于收到的数据，不用给出确认没有超时重发机制没有流量控制和拥塞控制\nIP数据包结构\nIP协议提供不可靠无连接的数据报传输服务，IP层提供的服务是通过IP层对数据报的封装与拆封来实现的。IP数据报的格式分为报头区和数据区两大部分，其中报头区是为了正确传输高层数据而加的各种控制信息，数据区包括高层协议需要传输的数据。\n\nIP 协议主要有以下几个作用：\n寻址和路由：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。\n三次挥手，四次握手\n\n三次握手\n三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。\n四次挥手\nCLOSE-WAIT状态问题：\n客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN 连接释放报文。\nTIME-WAIT 状态问题：\n客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一 个新的连接不会出现旧的连接请求报文。\n通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。\nHTTP / HTTPS（**）\n\nHTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。\n\nHTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。\n\nHTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。\n\nHTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。\n\n\nHTTPS运作过程\nHTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：\n① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；\n② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它的密钥组件一同发送给客户端。\n③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。\n④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。\n⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。\n⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。\n⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。\n⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。\n当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。\nSSL协议作用\n​        SSL能使用户/服务器应用之间的通信不被攻击者窃听，并且始终对服务器进行认证，还可选择对用户进行认证。SSL协议要求建立在可靠的传输层协议（TCP）之上。SSL协议的优势在于它是与应用层协议独立无关的，高层的应用层协议（例如：HTTP，FTP，TELNET等）能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。\n常见状态码\nHTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。HTTP 状态码共有 5 种类型：\n分类    分类描述1XX    指示信息–表示请求正在处理2XX    成功–表示请求已被成功处理完毕3XX    重定向–要完成的请求需要进行附加操作4XX    客户端错误–请求有语法错误或者请求无法实现，服务器无法处理请求5XX    服务器端错误–服务器处理请求出现错误\n常见的状态码： 200、301、302、403、404、500、503\n状态码    描述200 请求被成功处理301 永久性重定向302 临时性重定向304 未修改。告诉客户端可以复用缓存。400 请求出错：由于语法格式 / 参数有误，服务器无法理解。401 未授权：当前请求需要用户验证。403 没有访问权限（服务器已经理解请求，但是拒绝执行它）。404 没有对应资源（一般是输入的url并不合法）。405 不允许此方法（get/post/put/delete/请求用混淆了）。406 不可接受，请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。407 需要代理身份验证，与401响应类似，只不过客户端必须在代理服务器上进行身份验证。412 前提条件失败：在服务器上测试前提条件时，部分请求标题字段中所给定的前提条件估计为FALSE。客户机将前提条件放置在当前资源元信息（标题字段数据）中，以防止所请求的方法被误用到其他资源。414 Request-URI 太长500 服务器内部错误（一般是服务器代码错误）。501 未实现，Web 服务器不支持实现此请求所需的功能。502 网关出错，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应。503 服务器停机，由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常。504 网关超时，充当网关或代理的服务器，未及时从远端服务器获取请求\n特殊的IP地址\n一、0.0.0.0\n严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。\n二、255.255.255.255\n限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。\n三、127.0.0.1\n本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包。\n四、224.0.0.1\n组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP(Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。\n五、169.254.X.X\n如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。\n六、10.X.X.X、172.16.X.X～172.31.X.X、192.168.X.X\n私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。\n操作系统进程调度算法\na）先来先去服务\nb）时间片轮转法\nc）短作业优先\nd）高响应比优先调度算法（既考虑作业等待时间又考虑作业运行时间）\ne）多级反馈队列调度算法（既能使高优先级的作业得到响应又能使短作业迅速完成）\nf）优先级调度\n进程 / 线程（**）\na）进程是资源分配的最小单位，线程是任务执行的最小单位。\nb）进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。\nc）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC）进行。不过如何处理好同步与互斥是编写多线程程序的难点。\nd）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。\n分页 / 分段\n分段和分页其实都是一种对地址的划分或者映射的方式。 两者的区别主要有以下几点：\n1)页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要（也是对用户透明的）。段是信息的逻辑单位，它含有一组其意义相对完整的信息（比如数据段、代码段和堆栈段等）。分段的目的是为了能更好的满足用户的需要（用户也是可以使用的）。\n2)页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。\n3)分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符（线性地址的16进制表示），即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名（比如数据段、代码段和堆栈段等），又需给出段内地址。\n4)页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限。\n死锁\n解决方法\n死锁预防： 破坏导致死锁必要条件中的任意一个就可以预防死锁。例如：\n（1） 破坏保持和等待条件： 一次性申请所有资源，之后不再申请资源，如果不满足资源条件则得不到资源分配。\n（2） 破坏不可剥夺条件： 当一个进程获得某个不可剥夺的资源时，提出新的资源申请，若不满足，则释放所有资源。\n（3） 破坏循环等待条件： 按某一顺序申请资源，释放资源则反序释放。\n死锁避免： 进程在每次申请资源时判断这些操作是否安全。（银行家算法，系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。）\n死锁检测： 判断系统是否属于死锁的状态，如果是，则执行死锁解除策略。\n死锁解除： 将某进程所占资源进行强制回收，然后分配给其他进程。（与死锁检测结合使用的）\nLinuxLinux常用命令（**）\npwd：显示当前所在位置\nsudo + 其他命令：以系统管理者的身份执行指令\ngrep：要搜索的字符串 要搜索的文件 –color （高亮）\nps - ef/ps aux：查看当前系统正在运行进程\n查看特定的进程（查看包括redis的进程）： ps aux|grep redis / pgrep redis -a\nkill -9 进程pid ： 杀死进程（-9 表示强制终止）\nfind 目录 参数 ：find /home -name “*.txt”  \nls 或者 ll ：查看目录信息（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）\nfree : 显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存\ntar -zcvf 打包压缩后的文件名 要打包压缩的文件 : 打包并压缩文件，一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 .tar.gz\ntar -xvf 压缩文件 - C 解压的位置 : 解压压缩包\nwget : 是从远程下载的工具\nnetstat：显示网络状态。netstat –apn | grep 8080，查看程序端口占用情况。\nvmstat : 虚拟内存性能监控、CPU 监控。\ntop : 常用来监控Linux的系统状况，比如CPU、内存的使用，显示系统上正在运行的进程。\nload average：系统负载，就是进程队列的长度。当这个值&gt;cpu核心数的时候就说明有进程在等待处理了，是负载过重。\n创建新进程在Linux的下是由父进程来完成的，创建完成的新进程是子进程。\n新进程的地址空间有两种可能性：\n子进程是父进程的复制品（除了PID和task_struct是子进程自己的，其余的都从父进程复制而来）子进程装入另一个程序。在Linux下的fork函数用于创建一个新的进程，使用fork函数来创建一个进程时，子进程只是完全复制父进程的资源。这样得到的子进程和父进程是独立的，具有良好的并发性。但是进程间通信需要专门的机制。\nfork函数调用一次，会返回两个函数值，对于父进程而言，返回的是子进程的PID（因为一个父进程可能有多个子进程，并且没有一个函数可以使父进程获取其所有的子进程ID），对于子进程返回值是0（这样就能区分父子进程，子进程是可以通过getppid来获取父进程的ID），如果进程创建失败，那么返回给父进程-1。\n现在的Linux操作系统采用了copy-on-write技术（COW），即：如果父进程和子进程中任意一个尝试修改某些区域的值，那么内核会为修改区域的那部分内存制作一个副本，一般都是虚拟内存的一页。否则不进行复制操作，比如在fork的子进程中只是调用exec函数来执行另外一个可执行文件，那么事实上就没有必要复制父进程的资源，这样会造成大量的开销浪费。\nfork()函数创建的子进程和父进程的执行顺序理论上是不确定的（因为取决于OS的调度策略）。\n总结一下：fork函数创建的子进程是父进程的复制，子进程和父进程并发执行\n数据库关系型 / 非关系型数据库\n1 关系型数据库\n\n关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。优点：1、易于维护：都是使用表结构，格式一致；2、使用方便：SQL语言通用，可用于复杂查询；3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。缺点：1、读写性能比较差，尤其是海量数据的高效率读写；2、固定的表结构，灵活度稍欠；3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。\n2 非关系型数据库\n\n非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。优点：1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；3、高扩展性；4、成本低：nosql数据库部署简单，基本都是开源软件。\n缺点：1、不提供sql支持，学习和使用成本较高；2、无事务处理；3、数据结构相对复杂，复杂查询方面稍欠。\n查询语句\n查询同时选修了选修课1和选修课2的学生学号：\nselect Sno from sc where Cno in (‘课1’,’课2’) group by Sno having count(*)=2\n数据库设计三大范式\n第一范式确保每列保持原子性；\n第二范式确保每列都和主键相关，消除非主属性对码的部分依赖；\n第三范式确保每列都和主键直接相关，消除非主属性对码的传递依赖。\n注：没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。\n具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 订单和订单项、相册浏览次数和照片的浏览次数。\n索引\n目的：使查询数据效率快。\n分类\n\n聚集索引（主键索引）：所有行数都会按照主键索引进行排序。\n 非聚集索引：就是给普通字段加上索引。\n 联合索引：就是好几个字段组成的索引，称为联合索引。\n\n不走索引的情况\n\nlike语句中%在前面的不走索引，在后面的走索引；\n\n用索引列进行计算的，不走索引；\n\n对索引列用函数了，不走索引；\n\n索引列用了!= 不走索引。\n\n\nB+树\nB+树就是为了解决数据量大的时候存储在外存储器时候，查找效率低的问题。\nB+树的特点：\n\n中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。\n所有的中间节点在子节点中要么是最大的元素要么是最小的元素 。\n叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。\n\nB+树的优势：\n\n单个节点可以存储更多的数据，减少I/O的次数。\n查找性能更稳定，因为都是要查找到叶子结点。\n叶子结点形成了有序链表，便于查询。\n\n重复数据加索引\n\na、非聚簇索引存储了对主键的引用，如果select字段不在非聚簇索引内，就需要跳到主键索引（上图中从右边的索引树跳到左边的索引树），再获取select字段值\nb、如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢\nc、如果where值重复率高的字段，select用了limit，只查较少数据，也就是跳的次数很少的情况下，还是可以建索引的（后来想想也没必要，limit限制了数量，全表扫描也很快，除非字段值是排序的，必须扫描完前面的所有值）\nd、如果没有3这个前提，则不建议在值重复率高的字段上建索引，因为查询效率低，还需要维护索引\n4种隔离级别\n​        数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。\n脏读、不可重复读、幻象读　　\n　　脏读：指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。　　不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。　　幻读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）\n\n 读未提交 （Read uncommitted）\n　　读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。\n　　在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。\n\n 读提交（Read Committed） → 脏读\n　　 读提交，顾名思义，就是只能读到已经提交了的内容。\n​         这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显式的加锁。\n　　那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？\n　　这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”\n　　假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而”快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。\n\n**可重复读(Repeated Read)**→不可重复读\n　　可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。\n　　不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。\n　　在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。\n\n序列化 Serializable\n　　这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。\n\n值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。\n数据库引擎\n​        数据库引擎简单来说就是一个”数据库发动机”。当你访问数据库时，不管是手工访问，还是程序访问，都不是直接读写数据库文件，而是通过数据库引擎去访问数据库文件。以关系型数据库为例，你发SQL语句给数据库引擎， 数据库引擎解释SQL语句，提取出你需要的数据返回给你。因此，对访问者来说，数据库引擎就是SQL语句的解释器。\n  正式来说，数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可以控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求，这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。\n​        你能用的数据库引擎取决于mysql在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下,MYSQL支持三个引擎:ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。\n​        MyISAM是MySQL的ISAM扩展格式。除了提供ISAM里所没有的索引 （ISAM允许没有任何索引和主键的表存在，索引都是保存行的地址）和字段管理的大量功能， MyISAM还使用一种表格锁定的机制（表级锁），来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。 MYISAM强调了快速读取操作 ，这可能就是为什么MySQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。\n​        InnoDB数据库引擎是早就Mysql灵活性的技术的直接产品，这项技术就是mysql+api，在使用mysql的时候，你所面对的每一个挑战几乎都源于isam和myisam数据库引擎不支持事务处理也不支持外键。InnoDB要比isam和myisam引擎慢，innoDB为mysql表提供了acid事务支持，系统崩溃修复能力和多版本并发控制的行级锁，该引擎提供了行级锁和外键约束，所以InnoDB是事务型数据库首选的引擎。采用B+树实现，索引与数据存储在同一文件中。\n回滚 / 提交\n1 回滚日志(undo)\nundo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。\nundo log用于存放数据被修改前的值，如果修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。另外InnoDB MVCC事务特性也是基于undo日志实现的。\n因此，undo log有两个作用：提供回滚和多版本控制(MVCC)。\n2 重做日志(redo)\nredo log重做日志记录的是新数据的备份，属于物理日志。在事务提交前，只要将redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是redo log已经持久化。系统可以根据redo log的内容，将所有数据恢复到最新的状态。\nredo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。\nMySQL中redo log刷新规则采用一种称为Checkpoint的机制(利用LSN实现)，为了确保安全性，又引入double write机制。\n4.3 MVCC\nMVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：MVCC就是行级锁的一个变种(升级版)。\n事务的隔离级别就是通过锁的机制来实现，只不过隐藏了加锁细节。\n在表锁中我们读写是阻塞的，基于提升并发性能的考虑，MVCC一般读写是不阻塞的。\nMySQL中MVCC是通过redo log版本链+一致性视图Read-view实现的。\n测试\n测试流程\n需求分析→测试计划→测试设计→测试环境搭建→测试执行→测试记录→缺陷管理→软件评估→测试总结→测试维护\n测试分类\n1、按开发阶段：单元测试、集成测试、系统测试、验收测试2、按测试实施组织：α、β、第三方3、按测试执行方式：静态测试、动态测试4、按是否查看代码：黑盒测试、白盒测试、灰盒测试5、按是否手工执行划分：手工测试、自动化测试6、按测试对象划分：性能测试、安全测试、兼容性测试、文档测试、易用性测试（用户体验测试）、业务测试、界面测试、安装测试（功能测试、接口测试）7、按测试地域划分：本地化测试、国际化测试\n白盒测试\n定义：　　白盒测试又称结构测试,透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例设计方法，白盒指的是程序的内部结构和目的：　　通过检查软件内部的逻辑结构，对软件中的逻辑路径进行覆盖测试；在程序不同地方设置检查点，检查程序的状态，以确定实际运行状态与预期状态是否一致。\n方法：大致分为静态方法和动态方法两大类。\nA. 静态分析：　　是一种不执行程序而进行测试的技术。静态分析的主要目的是检查软件的表示和描述是否一致,没有冲突或者没有歧义。\nB. 动态分析：　　当软件系统在模拟或真实的环境中执行前、过程中和执行后,对其行为分析。它显示了一个系统在检查状态下是否正确。在动态分析技术中,最重要的技术是路径和分支测试。下面要介绍的六种覆盖测试方法属于动态分析方法。\n（1）语句覆盖\n使程序中的每个可执行语句都能执行一次的测试用例\n测试用例条件： A ^ B = T\n（2）判定覆盖（分支覆盖）\n对于判断语句，在设计用例的时候，要设计判断语句结果为True和False的两种情况\n测试用例条件：　　　　　　　A ^ B = T　　　　　　　A ^ B = F\n　　　　　　　\n（3）条件覆盖\n设计用例时针对判断语句里面每个条件表达式true 和 false各取值一次，不考判断语句的计算结果\n测试用例条件：　　　　　　　A=T 　　　　A=F　　　　　　　B=T 　　　　B=F\n　　　　　　　\n（4）判定条件覆盖（分支条件覆盖）\n设计测试用例时，使得判断语句中每个条件表达式的所有可能结果至少出现一次，每个判断语句本身所有可能结果也至少出现一次。\n测试用例条件：　　　　　　　A ^ B = T 　　 A ^ B = F　　　　　　　A=T　　　　　A=F　　　　　　　B=T　　　　　B=F\n（5）条件组合覆盖\n设计测试用例时，使得每个判断语句中条件结果的所有可能组合至少出现一次\n测试用例条件：　　　　　　　A= T　　　 B= T　　　　　　　A= T 　　　B= F　　　　　　　A= F　　　 B= T　　　　　　　A= F 　　　B= F\n（6）路径覆盖\n设计测试用例时，覆盖程序中所有可能的执行路径\n优点：这种覆盖方法可以对程序进行彻底的测试用例覆盖，比前面讲的五种方法覆盖度都要高。\n缺点：于路径覆盖需要对所有可能的路径进行测试（包括循环、条件组合、分支选择等），那么需要设计大量、复杂的测试用例，使得工作量呈指数级增长。路径覆盖虽然是一种比较强的覆盖，但未必考虑判断语句中条件表达式结果的组合，并不能代替条件覆盖和条件组合覆盖。\n冒烟测试\n1.冒烟测试是什么？\n　　针对每个版本或每次需求变更后，在正式测试前，对产品或系统的一次简单的验证性测试。\n2.冒烟测试的目的\n　　为正式测试前，验证是否产品或系统的主要需求或预置条件是否存在bug。\n3.冒烟测试怎么做？\n　　最好的方法，设计出自动化测试脚本，每一次版本更新后都可以去执行脚本验证一下。\nJunit @Before @After\n@Before修饰的方法，会在测试方法之前被自动执行，所有测试方法在执行之前都会执行该方法\n@After修饰的方法，会在测试方法执行之后自动被执行，在所有测试方法执行完之后，都会自动执行该方法\n无论测试方法是否会出现异常，这两个修饰的方法总是会自动执行的。\n测试用例\n设计方法：等价类划分法、边界值分析法、错误推测法、判定表法、正交实验法。\n点赞（抖音）\n\n未点赞时，点赞按钮为浅色或灰色；点赞之后为深色或填满。\n点赞为零时，不显示点赞数。\n点赞大于零时，显示点赞数。\n当点赞数过大时，达到千或万（有时百），需考虑简化点赞数，如1k或1w（跟手机屏幕也有关系）。\n取消点赞时，点赞数需跟着减少。\n每人每天点赞次数，按业务设置上限。\n点赞到达上限时，是否有提示用户点赞达到上限。\n\n搜索\n1：不输入任何字符，点击搜索按钮，一般搜索出网站所有的信息\n2：一般搜索输入框中的有文章显示，当鼠标点击时，文章消失\n3：输入全角/半角中文字符（一个字符、超长字符、已经信息字符）\n4：输入全角/半角英文字符（一个字符、超长字符、已经信息字符）\n5：输入全角/半角特殊字符~!@#$%^&amp;*()_+|{}:”&lt;&gt;?.,;’[]=-(注意单引号经常会发现bug)\n6：输入全角/半角中英文空格\n7：输入html语言\n8：输入特殊字符串NULL、null、&amp;nbsp空格的转义字 符；&lt;scrīpt&gt;&lt;/scrīpt&gt;；；；；&lt; /tr&gt;；；；；\n9：输入javascript\n电梯\n测试电梯能否实现正常的上升和下降功能，每层是否都可以停靠。\n每层停靠楼层是否与所按的楼层一致\n电梯按键在按下时是否点亮按键灯\n电梯在每个楼层的上行和下行的申请是否可以有效\n电梯满负载的时候，是否会忽略其他楼层外部的上行和下行申请\n电梯的两边按钮是否都可以使用，三列按钮。\n电梯的楼层选择是否可以取消电梯门的打开，关闭是否正常关闭（自动关闭）。\n报警装置是否可用。\n（满载）超重时是否能强制关门超重时重新挪动一下人员是否可以上下行与另外一部电梯之间是否协作良好。\n（算法）电梯的灯光是否满足看书的要求联系外界的电话是否可用通风状况如何，人多的时候是否会很热，通风不畅（排气扇）\n电梯里面的摄像头是否可用，拍摄是否清晰\n门不夹人伸手的话，应该不会强制关门管理员可以和内部人通话在各种场合下，可以强制开门运行中时，不能按开门键，不会强制开门在不同情况下（如：有人挡着、马上关门的时候、停电的时候、没有请求的时候…），一直按开门键和关门键从电梯外部可以强制开门\n购物车\n功能性测试:\n1.购物车是否可以添加商品\n2.购物车的优惠券是否可以使用\n3.购物车的计算结果是否正确\n4.如果使用购物券购物车里面的价格是否发送改变\n5.未登录时购物车是否可以正常显示\n6.如果没有登录会不会让你登录之后才可以使用\n7.所有的页面链接功能是否正常，是否可以正确跳转到指定页面\n8.商品没有勾选时结算按钮是否可以点击\n9.购物车页面时用户是否可以取消订单，或者进入订单和客服进行聊天\n10.卖家在线时是否显示在线\n11.购物车添加的商品是否可以有数量上限\n12.购物车点击几件商品时点击结算会不会跳转到支付页面\n13.是否可以批量删除商品\n14.如果没有在指定时间下单，订单会不会自动失效并在购物车清除该商品信息\n15.可否对添加的商品是否可以进行 增加\n16.商品信息过长是否可以显示完整\n17.商品是否可以进行收藏并推荐相似的商品（宝贝）\n18.购物车中的降价商品，库存紧张商品是否成功分类19.购物车商品降价时，购物车是否显示降价信息\n性能性测试:\n20.打开购物车这个页面需要多长时间\n21.弱网时是否还可以进行添加商品，计算商品的价格并且可以正常结算\n22.无网状态下是否提醒请检测你的网络设置\n23.用户过多会不会使购物车服务器崩溃\n24.编辑购物车：删除、添加商品需要的时间。\n25.在购物车页面选择需要购买的商品进行结算的时候，结算金额可不可以实时显示。\n26.清空失效商品需要的时间。\n兼容性测试\n27.ios:不同型号，不同ios的手机系统的耗电情况，打开速度，安装后是否闪退，卸载\n28.安卓：不同品牌，不同型号，不同的安卓系统，手机系统的耗电情况，打开速度，安装后是否闪退，卸载29.web端的打开速度\n界面测试\n30.购物车界面是否完善\n31.各个功能的设计是否美观 ，大小是否合适\n32.页面的功能按钮可以正常显示。\n33.商品的最下方显示失效宝贝。\n34.页面的最低端显示“你可能喜欢”\n35.购物车中如果存在有商品降价、库存不足、限购件数等，在商品详情的下面，会有对应的字体展示\n安全性测试\n36.用户实名认证后个人信息是否会泄露\n37.是否需要绑定手机号\n易用性测试\n38.是否方便人们操作\n39.是否有免密码支付功能\n40.是否具有青少年模式\n测试场景\n工具Git常用命令\n\n\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\n常用自动化测试工具\n1、Appium\n官网：http://appium.io\nAppUI自动化测试\nAppium 是一个移动端自动化测试开源工具，支持iOS 和Android 平台，支持Python、Java 等语言，即同一套Java 或Python 脚本可以同时运行在iOS 和Android平台，Appium 是一个C/S 架构，核心是一个 Web 服务器，它提供了一套 REST 的接口。当收到客户端的连接后，就会监听到命令，然后在移动设备上执行这些命令，最后将执行结果放在 HTTP 响应中返还给客户端。\nLicense：免费\n2、Selenium\n官网：https://www.seleniumhq.org/download/\nWebUI自动化测试\nSelenium是一个用于Web应用程序测试的工具，Selenium已经成为Web自动化测试工程师的首选。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE(7、8、9)、Mozilla Firefox、Mozilla Suite等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。Selenium 是ThoughtWorks专门为Web应用程序编写的一个验收测试工具。其升级版本为Webdriver。\nLicense：免费\n3、Postman\n官网：https://www.getpostman.com\n接口测试\n Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。不仅如此，它还提供测试数据和环境配置数据的导入导出，付费的 Post Cloud 用户还能够创建自己的 Team Library 用来团队协作式的测试，并能够将自己的测试收藏夹和用例数据分享给团队。\nLicense：免费\n4、Soapui\n官网：https://www.soapui.org\n接口测试\nSoapUI提供了所有所需的工具来测试和完善的测试。总览标签给你一个项目的所有内容和全面的看法。只需一次点击，您可以添加任何数量的断言为验证传入的消息TestStep。使用功能强大的HTTP监视器记录，分析甚至修改客户机 - 服务器通信，因为它发生。和SoapUI临带来了更专业和先进的功能，保持遥遥领先其他测试工具。轻松创建和运行数据驱动测试。该数据源TestStep读取测试数据从任何外部来源 - Excel中，XML，JDBC，文件，等等 - 到标准SoapUI属性。\nLicense：免费\n5、Robot Framework\n官网：http://robotframework.org  \nWebUI自动化测试，接口测试，APP测试\n   Robot Framework是一款python编写的功能自动化测试框架。具备良好的可扩展性，支持关键字驱动，可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。主要用于轮次很多的验收测试和验收测试驱动开发。\nRobot framework为不同的自动化测试需求提供了不同的框架。它的测试能力可以通过 Python 和 Java 测试库得到扩展。Selenium WebDriver 是 Robot Framework 中内置的流行库。\nRobot Framework 不仅仅是网页测试工具，同样可以用来做 Android 和 iOS 的自动化测试。对于关键字测试驱动熟悉的测试员可以轻松上手 Robot Framework。\nLicense：免费  \n6、QTP\n官网：https://software.microfocus.com/en-us/products/unified-functional-automated-testing/overview\nWebUI自动化测试，接口测试，APP测试\nHP QuickTest Professional 提供符合所有主要应用软件环境的功能测试和回归测试的自动化。采用关键字驱动的理念以简化测试用例的创建和维护。它让用户可以直接录制屏幕上的操作流程，自动生成功能测试或者回归测试用例。专业的测试者也可以通过提供的内置脚本和调试环境来取得对测试和对象属性的完全控制。目前版本名为Unified Functional Testing，简称UFT。可以测试非常多的应用，比如接口API，Web services，桌面程序，Web系统，手机APP。\nLicense：商业\n7、Jmeter\n官网：https://jmeter.apache.org\n接口测试，性能测试\nJMeter是Apache组织的开放源代码项目，它是功能和性能测试的工具，100%的用java实现；\nJMeter可以用于测试静态或者动态资源的性能（文件、Servlets、Perl脚本、java对象、数据库和查询、ftp服务器或者其他的资源）。JMeter用于模拟在服务器、网络或者其他对象上附加高负载以测试他们提供服务的受压能力，或者分析他们提供的服务在不同负载条件下的总性能情况。你可以用JMeter提供的图形化界面分析性能指标或者在高负载情况下测试服务器/脚本/对象的行为。\n使用Jmeter做接口测试需要注意一点，小心使用“用户定义变量”，Jmeter组件有优先级的，如果多个线程同时执行的时候，“用户定义变量”组件定义的变量可能会乱套。\nLicense：免费\n8、Loadrunner\n官网：https://software.microfocus.com/en-us/products/loadrunner-load-testing/overview\n性能测试\nLoadRunner，是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner能够对整个企业架构进行测试。企业使用LoadRunner能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期。 LoadRunner可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。\nLicense：商业\n9、Monkey\nApp稳定性测试\n软件附带在sdk中，适用于android和ios，通过adb shell，生成用户或系统的伪随机事件，压力测试结果：崩溃crash，无响应anr。\nLicense：免费\n10、GT\n官网：http://gt.qq.com/index.html\nApp性能测试\nGT（随身调）是APP的随身调测平台，它是直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug Environment)。利用GT，仅凭一部手机，无需连接电脑，您即可对APP进行快速的性能测试(CPU、内存、流量、电量、帧率/流畅度等等)、开发日志的查看、Crash日志查看、网络数据包的抓取、APP内部参数的调试、真机代码耗时统计等。\nLicense：免费\n11、Appscan\n官网：https://www.ibm.com/developerworks/downloads/r/appscan/\n安全测试\nIBM Security AppScan 是一个适合安全专家的 Web 应用程序和 Web 服务渗透测试解决方案，对现代 Web 应用程序和服务执行自动化的动态应用程序安全测试 (DAST) 和交互式应用程序安全测试 (IAST)，支持 Web 2.0、JavaScript 和 AJAX 框架的全面的 JavaScript 执行引擎，涵盖 XML 和 JSON 基础架构的 SOAP 和 REST Web 服务测试支持 WS-Security 标准、XML 加密和 XML 签名，详细的漏洞公告和修复建议。\nLicense：免费\n12、Jenkins\n官网：https://jenkins.io\n持续集成\n自动化构建 编译，部署，任务执行，测试报告，邮件通知等。\nLicense：免费\n拓展知识\nCDN\n全称:Content Delivery Network或Content Ddistribute Network，即内容分发网络\n基本思路：\n尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\n目的：\n解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。\n控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。\n","tags":["Java"]}]
[{"title":"LeetCode 463.岛屿的长度","url":"/2020/10/30/LeetCode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E9%95%BF%E5%BA%A6/","content":"题目描述：\n给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n示例：\n输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]\n输出: 16\n解释: 它的周长是下面图片中的 16 个黄色的边：\n\n我的解法（迭代）：\nint[] dx = &#123;-1,1,0,0&#125;;int[] dy = &#123;0,0,-1,1&#125;;// 统计每块陆地四周有几块陆地，贡献的周长=4-四周的陆地块数int around1(int[][] grid,int x,int y)&#123;    int num = 0;    for(int i = 0; i &lt; 4; i++)&#123;        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &lt; 0 || xx &gt;= grid.length || yy &lt; 0 || yy &gt;= grid[0].length) continue;        if(grid[xx][yy] == 1) num++;    &#125;    return num;&#125;public int islandPerimeter(int[][] grid) &#123;    int sum = 0;    for(int i = 0; i &lt; grid.length; i++)&#123;        for(int j = 0; j &lt; grid[0].length; j++)&#123;            if(grid[i][j] == 1)&#123;                sum += 4 - around1(grid,i,j);            &#125;        &#125;    &#125;    return sum;&#125;\n\n\n\n用DFS求岛屿周长：\n思路：岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量。（每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1）\n\npublic int islandPerimeter(int[][] grid) &#123;    for (int r = 0; r &lt; grid.length; r++) &#123;        for (int c = 0; c &lt; grid[0].length; c++) &#123;            if (grid[r][c] == 1) &#123;                // 题目限制只有一个岛屿，计算一个即可                return dfs(grid, r, c);            &#125;        &#125;    &#125;    return 0;&#125;int dfs(int[][] grid, int r, int c) &#123;    if (!(0 &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length)) &#123;        return 1;    &#125;    if (grid[r][c] == 0) &#123;        return 1;    &#125;    if (grid[r][c] != 1) &#123;        return 0;    &#125;    grid[r][c] = 2; // 用2标记已遍历过的岛屿    return dfs(grid, r - 1, c)        + dfs(grid, r + 1, c)        + dfs(grid, r, c - 1)        + dfs(grid, r, c + 1);&#125;\n\n链接：https://leetcode-cn.com/problems/island-perimeter\n","tags":["算法","LeetCode","DFS"]},{"title":"Hello World","url":"/2020/10/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"JavaScript入门","url":"/2020/10/26/JavaScript%E5%85%A5%E9%97%A8/","content":"1 基础语法比较运算符===  //等于（类型不同，值一样，也会判断为true）=== //绝对等于（类型一样，值一样，结果才为true）\n\n这是一个JS的缺陷，坚持不要使用 == 比较\n须知：\n\nNaN===NaN返回false，NaN与所有数值都不相等，包括自己\n只能通过isNaN(NaN)来判断这个数是否是NaN\n\n尽量避免使用浮点数进行运算，存在精度问题\nMath.abs(1/3-(1-2/3))&lt;0.000000001\n\n严格检查模式全局变量 i = 1;\n局部变量 var i = 1; let i = 1;（ES6建议使用let）\n严格检查模式\n‘use strict’; 严格检查模式，预防JavaScript的随意性导致产生的一些问题\n字符串多行字符串：\n`XXX\nXXX`\n模板字符串\n`hello,${变量}`\nstr.length str[0] str.toUpperCase() str.toLowerCase()\nstr.subsring(X,Y)返回str[X,Y)\n数组var arr = [1,2,3,4,5,&#x27;hello&#x27;,null,true];new Array(1,2,3,4,5,&#x27;hello&#x27;,null,true);\n\n取数组下标，如果越界(arr[8]),就会提示undifined\n假如给数组的长度arr.length赋值，数组大小就会发生变化\nindexOf：通过元素获得下标索引\nslice()截取Array的一部分，类似字符串中的substring\narr.push(),arr.pop() // 尾部\narr.unshift(),shift() // 头部 \narr.sort()\narr.reverse()\narr.concat() // 不会改变原数组\narr.join(‘-‘) // 连接符 打印\narr.fill(X)\n对象\n每个属性之间使用逗号隔开，最后一个不需要添加\n\nvar person = &#123;    name:&quot;XXX&quot;,    age:18,    tags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;...&#x27;]&#125;\n\n对象赋值：person.name = “XXX”\n取对象的值：person.name\n使用一个不存在的对象属性，不会报错！undefined\n动态删除，添加对象的属性：delete person.name person.XXX=XXX\nJavaScript中所有键都是字符串，值是任意对象\n判断属性值是否在这个对象中！’XXX’ in XXX\n判断一个属性是否是这个对象自身拥有的 hasOwnProperty()\n流程控制arr.forEach(function (value)&#123;  // ES5.1\tconsole.log(value)&#125;)for(var i in arr)&#123;   // i为数组下标&#125;for(var e of arr)&#123;   // e为数组元素&#125;\n\nMap和SetES6的新特性\nvar map = new Map([[&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90]]);var name = map.get(&#x27;tom&#x27;);map.set(&#x27;admin&#x27;,123); // 新增map.delete(&#x27;XXX&#x27;);console.log(name);var set = new Set(1,1,1,3); // 去重set.add(x);set.delete(x);set.has(x);\n\niterater ES6新特性\n函数function abs(x)&#123;\t//定义方式一    //...&#125;var abs = function(x)&#123;\t//定义方式二    //...&#125;\n\n如果没有执行return，函数执行完也会返回结果：undefined\nJavaScript可以传任意参数，也可以不传参数\nvar abs = function(x)&#123;    //手动抛出异常    if(typeof x != &#x27;number&#x27;)&#123;        throw &#x27;Not a Number&#x27;;    &#125;    if(x &gt;= 0)&#123;        return x;    &#125;else&#123;        return -x;    &#125;&#125;\n\narguments参数表示函数传入的所有参数，是一个数组\nrest剩余参数，只能写在最后面，必须用…表示\nfunction aaa(a,b,...rest)&#123;    consloe(&quot;a-&gt;&quot;+a);    consloe(&quot;b-&gt;&quot;+b);    consloe(&quot;rest-&gt;&quot;+rest);&#125;\n\n全局对象 window所有全局变量都绑定在全局对象window上的\nwindow.x（全局变量）\nwindows.alert(window.x)\nvar old_alert = window.alert;//old_alert(x);window.alert = function()&#123;    &#125;;window.alert(123); //失效//恢复window.alert = old_alert;window.alert(456);\n\n全局变量→冲突\n//唯一全局变量var App = &#123;&#125;;//定义全局变量App.name = &#x27;XXX&#x27;;App.add = function (a,b) &#123;    return a + b;&#125;\n\n把自己代码全部放入自己定义的唯一命名空间中，降低全局命名冲突的问题（JQuery）\nES6建议使用let关键字去定义局部作用域的变量（解决局部作用域冲突的问题），使用const定义常量const PI = &#39;3.14&#39;\n方法var XXX = &#123;\tname:&#x27;xxx&#x27;,\tbirth:2020,\t//方法\tage:function()&#123;        var now = new Date().getFullYear();        return now - this.birth;    &#125;&#125;XXX.nameXXX.age()\n\napply在js中可以控制this指向，通过 apply() 方法，能够编写用于不同对象的方法。函数.apply(对象,参数列表)this指向apply的对象\n2 内部对象\n标准对象\n\nnumber, string, boolean, object\ntypeof NaN&quot;number&quot;typeof []&quot;object&quot;typeof undefined&quot;undefined&quot;\n\n2.1 Datevar now = new Date();now.getFullYear(); // 年now.getMonth(); //月（0-11）now.getDate(); //日now.getDay(); //星期几now.getHours(); //时now.getMinutes(); //分now.getSeconds(); //秒now.getTime(); //时间戳 1970.1.1 00:00 - msconsole.log(new Date(113224222)) //时间戳转为时间//转换为字符串now.toLocaleString()now.toGMTString()\n\n2.2 JSON\nJSON(JavaScript Object Notation, JS 对象表示法) 是一种轻量级的数据交换格式。\n\n特点：简洁，清晰的层次结构；易于人阅读和编写，同时也易于机器解析和生成，有效提升网络传输效率\n在JavaScript中一切皆对象，任何JS支持的类型都可以用JSON来表示\n格式：\n\n对象：{}\n数组：[]\n键值对：key:value\n\nJSON字符串和JS对象的转化\nvar user = &#123;    name: &quot;XXX&quot;,    age: 3,    sex: &#x27;男&#x27;&#125;//对象转化为JSON对象var jsonUser = JSON.stringify()//json字符串转化为对象,参数为json字符串var obj = JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;XXX&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;)\n\n2.3 Ajax\n原生的js写法 xhr异步请求\n\nJQuery封装好的方法 $(“#name”).ajax(“”)\n\naxios 请求\n\n\n3 面向对象编程原型：子类（对象）.__proto__ = 父类（原型对象）; //子类的原型是父类\n随意指向\nclass关键字是在ES6引入的\nclass Student&#123;    constructor(name)&#123;        this.name = name;    &#125;    hello()&#123;        alert(&#x27;hello&#x27;)    &#125;&#125;class pupil extends Student&#123;    constructor(name,grade)&#123;        super(name);        this.grade = grade;    &#125;    myGrade()&#123;        alert(&#x27;我是一名小学生&#x27;)    &#125;&#125;var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);xiaoming.hello();\n\n\n\n原型链：_proto_\\\n\n4 操作BOM对象（重点）\nBOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。\n\n浏览器：\n内核：IE， Chrome, Safari, FireFox\n三方：QQ，360\n4.1 windowwindow代表浏览器窗口\nwindow.alert(1)// 调整浏览器窗口大小window.innerHeightwindow.innerWidthwindow.outerHeightwindow.innerWidth\n\n4.2 navigatornavigator封装了浏览器的信息\nnavigator.appNamenavigator.appVersionnavigator.userAgentnavigator.platform\n\n一般不使用，因为会被人为修改，不建议用这些属性来判断浏览器版本\n4.3 screenscreen代表屏幕尺寸\nscreen.widthscreen.height\n\n4.4 location（重要）location代表当前页面的URL信息\nhost: &quot;www.bilibili.com&quot;hostname: &quot;www.bilibili.com&quot;href: &quot;https://www.bilibili.com/video/BV1JJ41177di?p=19&quot;protocol: &quot;https:&quot;reload: ƒ reload() // 刷新页面// 设置新的地址location.assign(&#x27;https://...&#x27;)\n\n4.5 documentdocument代表当前的页面（document.），HTML DOM文档树\n//获取具体的文档树节点&lt;dl id=&quot;app&quot;&gt;    &lt;dt&gt;Java&lt;/dt&gt;    &lt;dd&gt;JavaSE&lt;/dd&gt;&lt;/dl&gt;&lt;script&gt;\tvar dl = document.getElementById(&#x27;app&#x27;);&lt;/script&gt;\n\n获取cookie\ndocument.cookie&quot;finger=158939783; _uuid=C56A5201-E5AB-30A7-6A3D-33573CFAEC4B75115infoc; buvid3=2DE4F72B-D52C-4628-B6F6-D25A79D4DFBD155818infoc; sid=jsr4r70q; im_notify_type_775959=0; LIVE_BUVID=AUTO6215819975268326; LIVE_PLAYER_TYPE=2; DedeUserID=775959; DedeUserID__ckMd5=5a93072db131a757; bili_jct=e4c30825e9523f0d624509aa21012a7e; rpdid=|(J~RllJRmlY0J&#x27;ulm)RkRm)l; blackside_state=1; CURRENT_FNVAL=80; bp_t_offset_775959=434460479141307658; Hm_lvt_8a6e55dbd2870f0f5bc9194cddf32a02=1600696828; CURRENT_QUALITY=80; bp_video_offset_775959=438421933640865406; finger=158939783; PVID=3&quot;\n\n劫持cookie原理\nwww.taobao.com\n&lt;script src=&quot;aa.js&quot;&gt;&lt;/script&gt;&lt;!-- 恶意人员：获取你的cookie上传到他的服务器 --&gt;\n\n服务器可以设置：httpOnly（安全）\n4.6 historyhistory代表浏览器的历史记录（不建议使用）\nhistory.back()history.forward()\n\n5 操作DOM对象（重点）\n文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本,更新其内容、结构和www文档的风格(目前,HTML和XML文档是通过说明部分定义的)。\n\n浏览器网页就是一个DOM树形结构，要操作一个DOM节点，就必须先获得这个DOM节点\n5.1 获得DOM节点标签选择器：document.getElementsByTagName(&#39;h1&#39;)（返回数组）\nid选择器：documen.getElementById(&#39;id&#39;)\nclass选择器：document.getElementByClassName(&#39;class&#39;)（返回数组）\n获得子节点：Node.children\n5.2 更新DOM节点修改文本值：\nNode.innerText = &#39;xxx&#39;\nNode.innerHTML = &#39;xxx&#39;（超文本）\n设置样式：\nNode.style.color/fontSize/... = &#39;xxx&#39;（驼峰命名）\n5.3 删除DOM节点先获取父节点，再通过父节点删除自己\nNode.parentElement.removeChild(Node)（只能通过id选择器选择节点删除）\n注意：删除节点过程中，父节点的children是动态变化的\n5.4 插入DOM节点获得的DOM节点若为空节点，可以通过innerText增加元素\n追加节点：Node1.append(Node2)\n创建新节点：document.createElement(&#39;p&#39;)\n设置节点属性：Node = setAttribute(&#39;属性名&#39;,&#39;属性值&#39;)\n插入节点：Node.insertBefore(newItem,existingItem);\n6 操作表单（验证）表单的目的：提交信息\n获得要提交的信息\ninput_text.valueboy_radio.checked //boolean\n\nMD5加密密码\n表单绑定提交事件\nonsubmit= 绑定一个提交检测的函数，返回布尔值（return false：不提交表单）\n7 jQuery公式：$(selector).action()\n$(&#x27;#id&#x27;).click(function()&#123;    //...&#125;)//当网页元素加载完毕之后，响应事件$(document).ready(function()&#123;    //...&#125;)//↑简写,获取坐标$(function()&#123;    $(&#x27;#divMove&#x27;).mousemove(function(e)&#123;        $(&#x27;mouseMove&#x27;).text(&#x27;x:&#x27;+e.pageX+&#x27;y:&#x27;+e.pageY)    &#125;)&#125;)\n\n文档工具站：https://jquery.cuishifeng.cn/\n操作DOM：\n$(&#x27;#test-ul li[name=python]&#x27;).css(&#123;&quot;color&quot;,&quot;red&quot;&#125;)$(&#x27;#test-ul li[name=python]&#x27;).show()/hide()$(window).width\n\n\n\nLayUI 弹窗组件\nElementUI 样式好看\n","tags":["JavaScript","JQuery","前端"]},{"title":"网络编程入门","url":"/2020/10/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/","content":"1 概述计算机网络：地理位置不同 多台计算机 连接 通信 共享\n网络编程的目的：数据交换，通信\n如何实现多台主机之间的数据通信：\n\n准确定位网络上的一台主机以及该主机的某个资源（IP：Port）\n传输数据？\n\nJavaWeb：网页编程  B/S\n网络编程：TCP/IP      C/S\n2 网络通信的要素实现网络通信需要知道通信双方地址（ip、端口号）\n规则：网络通信协议\nTCP/IP参考模型：\n\n网络编程专门针对传输层（TCP/IP）\n3 IPip地址：InetAddress\n\n唯一定位一台网络上的计算机\n127.0.0.1：本机localhost\nip地址的分类：\nipv4/ipv6\nipv4：10.164.120.176    4个字节组成，0~255，42亿中30亿在北美，亚洲4亿，2011年就用尽\nipv6：fe80::a1a2:85b0:e7d9:58f1%7  128位，8个无符号整数  \n\n\n公网（互联网） 私网（局域网）\nABCD类地址\n192.168.xx.xx 专门给组织内部使用的\n\n\n\n\n域名→记忆IP问题！\n\n4 端口端口表示计算机上的一个程序的进程：\n\n不同进程有不同的端口号！（不能冲突）用来区分进程！\n\n范围：0~65535\n\nTCP，UDP：65535*2 单个协议下，端口号不能冲突\n\n端口分类\n\n公有端口 0~1023\n\nHTTP：80\nHTTPS：443\nFTP：21\nTelnet：23\n\n\n程序注册端口：1024~49151 分配给用户或者程序\n\nTomcat：8080\nMySQL：3306\nOracle：1521\n\n\n动态/私有端口：49152~65535\nnetstat -ano #查看所有端口netstat -ano|findstr &quot;端口号&quot; #查看指定的端口tasklist|findstr &quot;端口号&quot; #查看指定端口的进程\n\n\n\n\n\n5 通信协议协议：约定\n网络通信协议：速率，传输码率，代码结构，传输控制……\nTCP/IP协议簇\n重要：\n\nTCP：传输控制协议\nUDP：用户数据报协议\n\nTCP vs UDP\n打电话~TCP\n\n连接，稳定\n\n三次握手，四次挥手\n最少需要三次，保证稳定连接！A:你瞅啥？B:瞅你咋地？A:干一场！A:我要走了B:你真的要走了吗？B:你真的真的要走了吗？A:我真的真的要走了！\n\n\n\n客户端、服务端\n\n传输完成，释放连接，效率低\n\n\n发短信~UDP\n\n不连接，不稳定\n客户端、服务器：没有明确的界限\n不管有没有准备好，都可以发给你\n导弹\nDDoS：洪水攻击（饱和攻击）\n\n6 TCP聊天客户端\n\n通过Socket连接服务器\n发送消息\n\npackage tcp;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\tInetAddress serverIP = null;\t\tint port = 0;\t\tSocket socket = null;\t\tOutputStream os = null;\t\ttry &#123;\t\t\t//1.得知服务器地址\t\t\tserverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\tport = 9999;\t\t\t//2.创建一个socket连接\t\t\tsocket = new Socket(serverIP,port);\t\t\t//3.发送消息\t\t\tos = socket.getOutputStream();\t\t\tos.write(&quot;你好&quot;.getBytes());\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\tif(os!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;            if(socket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tsocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t&#125;&#125;\n\n服务器端\n\n建立服务端口\n通过accept等待用户连接\n接收用户消息\n\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tServerSocket serverSocket = null;\t\tSocket socket = null;\t\tInputStream is = null;\t\tByteArrayOutputStream baos = null;\t\t\t\ttry &#123;\t\t\t//1.有地址\t\t\tserverSocket = new ServerSocket(9999);\t\t\t//2.等待客户端连接\t\t\tsocket = serverSocket.accept();\t\t\t//3.读取客户端的消息\t\t\tis = socket.getInputStream();\t\t\t//管道流\t\t\tbaos = new ByteArrayOutputStream();\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tbaos.write(buffer,0,len);\t\t\t&#125;\t\t\tSystem.out.println(baos.toString());\t\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\t//关闭资源\t\t\tif(baos!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tbaos.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(is!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(serverSocket!=null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tserverSocket.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\n\n\n\n文件上传服务器端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import org.omg.CORBA_2_3.portable.OutputStream;public class Server &#123;\t/**\t * @param args\t */\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\t\ttry &#123;\t\t\t//1.创建服务\t\t\tServerSocket serverSocket = new ServerSocket(9999);\t\t\t//2.监听客户端连接\t\t\tSocket socket = serverSocket.accept();\t\t\t//3.读取输入流\t\t\tInputStream is = socket.getInputStream();\t\t\t//4.文件输出\t\t\tFileOutputStream fos = new FileOutputStream(new File(&quot;receive.jpg&quot;));\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=is.read(buffer))!=-1)&#123;\t\t\t\tfos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tis.close();\t\t\tfos.close();\t\t\tsocket.close();\t\t\tserverSocket.close();\t\t\t\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n\n客户端\npackage tcp;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class Client &#123;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\t//1.创建一个socket连接\t\t\tSocket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9999);\t\t\t//2.创建一个输出流\t\t\tOutputStream os = socket.getOutputStream();\t\t\t//3.读取文件\t\t\tFileInputStream fis = new FileInputStream(new File(&quot;dog.jpg&quot;));\t\t\t//4.写出文件\t\t\tbyte[] buffer = new byte[1024];\t\t\tint len;\t\t\twhile((len=fis.read(buffer))!=-1)&#123;\t\t\t\tos.write(buffer,0,len);\t\t\t&#125;\t\t\t//5.关闭资源\t\t\tfis.close();\t\t\tos.close();\t\t\tsocket.close();\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t\t&#125;&#125;\n\n服务端（Tomcat）\n客户端（浏览器）\n7 UDP发短信：不用连接，需要知道对方地址\n发送消息发送端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;//不需要连接服务器public class Client &#123;\tpublic static void main(String[] args) throws Exception &#123;\t//1.建立一个Socket\tDatagramSocket socket = new DatagramSocket();\t//2.建个包\t\tString msg = &quot;Hello!&quot;;\tInetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\tint port = 9090;\t//数据，数据的长度起始，发送给谁\tDatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port);\t//3.发送包\tsocket.send(packet);\t//4.关闭流\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;//还是要等待客户端的连接！public class Server &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//开放端口\t\tDatagramSocket socket = new DatagramSocket(9090);\t\t//接收数据包\t\tbyte[] buffer = new byte[1024];\t\tDatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); //接收\t\tsocket.receive(packet);//阻塞接收\t\tSystem.out.println(packet.getAddress().getHostAddress());\t\tSystem.out.println(new String(packet.getData(),0,packet.getLength()));\t\t//关闭连接\t\tsocket.close();\t&#125;&#125;\n\n循环发送消息发送端\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class Sender &#123;\t/**\t * @param args\t * @throws Exception \t */\tpublic static void main(String[] args) throws Exception &#123;\t\t// TODO Auto-generated method stub\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(8888);\t\t//准备数据：控制台读取\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true)&#123;\t\t\t//2.建个包\t\t\t\tString data = reader.readLine();\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t//数据，数据的长度起始，发送给谁\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,6666));\t\t\t//3.发送包\t\t\tsocket.send(packet);\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t\t//4.关闭流\t\tsocket.close();\t&#125;&#125;\n\n接收端\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receiver &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.建立一个Socket\t\tDatagramSocket socket = new DatagramSocket(6666);\t\t\t\twhile(true)&#123;\t\t\t//准备接收包裹\t\t\tbyte[] container = new byte[1024];\t\t\tDatagramPacket packet = new DatagramPacket(container,0,container.length);\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t//断开连接 bye\t\t\tbyte[] data = packet.getData();\t\t\tString receiveData = new String(data,0,data.length).trim();\t\t\tSystem.out.println(receiveData);\t\t\tif(receiveData.equals(&quot;bye&quot;))&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n在线咨询：两个人既可以是发送端也可以是接收端（多线程）\n线程TalkSend\npackage udp;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;public class TalkSend implements Runnable&#123;\tDatagramSocket socket = null;\tBufferedReader reader = null;\t\tprivate int fromPort;\tprivate String toIP;\tprivate int toPort;\t\tpublic TalkSend(int fromPort, String toIP, int toPort) &#123;\t\tsuper();\t\tthis.fromPort = fromPort;\t\tthis.toIP = toIP;\t\tthis.toPort = toPort;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(fromPort);\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\twhile(true)&#123;\t\t\tString data;\t\t\ttry &#123;\t\t\t\tdata = reader.readLine();\t\t\t\tbyte[] datas = data.getBytes();\t\t\t\t\t\tDatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));\t\t\t\tsocket.send(packet);\t\t\t\tif(data.equals(&quot;bye&quot;))&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\tsocket.close();\t&#125;&#125;\n\n线程TalkReceive\npackage udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class TalkReceive implements Runnable&#123;\tDatagramSocket socket = null;\tprivate int port;\tprivate String msgFrom;\t\tpublic TalkReceive(int port,String msgFrom) &#123;\t\tsuper();\t\tthis.port = port;\t\tthis.msgFrom = msgFrom;\t\ttry &#123;\t\t\tsocket = new DatagramSocket(port);\t\t&#125; catch (Exception e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\t\twhile(true)&#123;\t\t\ttry &#123;\t\t\t\t//准备接收包裹\t\t\t\tbyte[] container = new byte[1024];\t\t\t\tDatagramPacket packet = new DatagramPacket(container, 0,container.length);\t\t\t\tsocket.receive(packet);//阻塞式接收包裹\t\t\t\t//断开连接 bye\t\t\t\tbyte[] data = packet.getData();\t\t\t\tString receiveData = new String(data, 0, data.length).trim();\t\t\t\tSystem.out.println(msgFrom+&quot;：&quot;+receiveData);\t\t\t\tif (receiveData.equals(&quot;bye&quot;)) &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t//关闭流\t\tsocket.close();\t&#125;&#125;\n\n老师TalkTeacher\npackage udp;public class TalkTeacher &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tnew Thread(new TalkSend(5555,&quot;localhost&quot;,8888)).start();\t\tnew Thread(new TalkReceive(9999,&quot;学生&quot;)).start();\t&#125;&#125;\n\n学生TalkStudent\npackage udp;public class TalkStudent &#123;\tpublic static void main(String[] args) &#123;\t\t//开启两个线程\t\tnew Thread(new TalkSend(7777,&quot;localhost&quot;,9999)).start();\t\tnew Thread(new TalkReceive(8888,&quot;老师&quot;)).start();\t&#125;&#125;\n\n8 URL统一资源定位符：定位互联网资源\n协议://ip地址：端口/项目名/资源\nurl下载网络资源\npackage url;import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLDown &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//1.下载地址\t\tURL url = new URL(&quot;http://127.0.0.1:8080/zhg/Confidential.txt&quot;);\t\t//2.连接这个资源HTTP\t\tHttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();\t\tInputStream inputStream = urlConnection.getInputStream();\t\tFileOutputStream fos = new FileOutputStream(&quot;cfile.txt&quot;);\t\tbyte[] buffer = new byte[1024];\t\tint len;\t\twhile((len=inputStream.read(buffer))!=-1)&#123;\t\t\tfos.write(buffer, 0, len); \t\t&#125;\t\tfos.close();\t\tinputStream.close();\t\turlConnection.disconnect();\t&#125;&#125;\n\n","tags":["Java","JavaSE","网络编程","TCP","UDP"]},{"title":"MySQL教程","url":"/2020/10/26/MySQL%E6%95%99%E7%A8%8B/","content":"数据库XX语言：DDL, DML, DQL, DCL\n1 数据库1.1 连接数据库命令行连接\nmysql -uroot -pupdate mysql.user set password = password(&#x27;XXX&#x27;) where user = &#x27;root&#x27; and Host = &#x27;localhost&#x27;; -- 修改用户密码flush privileges; -- 刷新权限-----------------------------------------------show tables;describe 表名; -- 显示表信息exit; -- 退出连接\n\n1.2 操作数据库create database [if not exists] 数据库名 -- 创建drop database [if exists] 数据库名 -- 删除use 数据库名 -- 使用/切换 如果数据库名是关键词，则加上``show databases; -- 查看\n\n\n\n数据类型：\n\n数值：\n\n\n整型：tinyint 1B,smallint 2B, int 4B, bigint 8B\n浮点型：float 4B, double 8B, decimal（字符串形式的浮点数，常用于金融计算）\n\n\n字符串\n\n\nchar 固定大小 0~255,\n\nvarchar 可变 0~65535\n\ntinytext 微型文本 2^8 - 1\n\ntext 文本串 2^16-1\n\n\n\n时间日期\n\n\ndate YYYY- MM- DD\ntime HH: mm: ss \ndatetime YYYY- MM - DD HH: mm: ss\ntimestamp 时间戳，1970.1.1到现在的毫秒数\nyear 年份表示\n\n\nNULL\n\n每个表都必须存在以下五个字段：\n\nid 主键\n`version`乐观锁\nis_delete 伪删除\ngmt_create 创建时间\ngmt_update 修改时间\n\n2 表2.1 创建表CREATE TABLE [IF NOT EXISTS] `student`&#123;\t`id` INT(4) [NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;],\t...\tPRIMARY KEY(`id`)&#125;[ENGINE=INNODB DEFAULT CHARSET=utf-8]\n\n查看创建语句\nSHOW CREATE DATABASE school -- 查看创建数据库语句SHOW CREATE TABLE student -- 查看创建表语句DESC student -- 显示表结构\n\n\n\n数据表的类型\nINNODB（默认）\nMYISAM（早年使用）\n\n\n\n\nMYISAM\nINNODB\n\n\n\n事务支持\n不支持\n支持\n\n\n数据行锁定\n不支持\n支持\n\n\n外键约束\n不支持\n支持\n\n\n全文索引\n支持\n不支持\n\n\n表空间大小\n较小\n较大，约为2倍\n\n\n常规使用的操作：\n\nMYISAM：节约空间，速度较快\nINNODB：安全性高，事务的处理，多表多用户操作\n\n所有的数据库文件都存在data目录下，本质还是文件的存储\nMySQL引擎在物理文件上的区别\n\nINNODB在数据库表中只有*.frm文件，以及上级目录下的ibdata1文件\nMYISAM对应文件\n*.frm - 表结构的定义文件\n*.MYD 数据文件（data）\n*.MYI 索引文件（index）\n\n\n\n2.2 修改删除表\n修改（alter）\n\nALTER TABLE teacher RENAME AS teacher1 -- 修改表名ALTER TABLE teacher1 ADD age INT(11) -- 增加字段-- 修改表的字段ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束ALTER TABLE teacher1 CHANGE age age1 VARCHAR(1) -- 重命名-- 删除表的字段ALTER TABLE teacher1 DROP age1\n\n\n\n\n删除\n\n-- 删除表DROP TABLE [IF EXISTS] teacher1\n\n3 MySQL数据管理3.1 外键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`);\n\n以上操作都是物理外键，数据库级别的外键，不建议使用，避免数据库过多造成困扰\n3.2 DML语言数据库意义：数据存储，数据管理\n添加：insert into 表名[(字段1,2,3...)]values(值1,2,3...)[,(),()...]\n修改：update 表名 set 字段1 = 值1[,字段2 = 值2...] where 条件\n删除：delete from 表名 where 条件\ntruncate 表名：完全清空一个数据库表，表的结构和索引约束不会变！\ntruncate 重新设置，自增列，计数器会归零，不会影响事务\nwhere子句\n=, &gt;, &lt;, &lt;=, &gt;= &lt;&gt;或者!=（不等于）, BETWEEN X AND Y （[X,Y]）\nAND, OR\n注意：没写条件则修改表的所有记录！\n4 DQL查询数据\nDQL:Data QueryLanguage 数据查询语言\n\nselect 字段 [as 别名] from 表 [as 别名]\n函数\nconcat(a,b)\n去重 distinct select distinct 字段 ...\n可以select的表达式：文本值，列，Null，函数，计算表达式，系统变量… \n4.1 模糊查询is null,like, in\n-- 查询姓刘的同学-- like结合 %代表0到任意个字符 _代表一个字符select `StudentNo`,`StudentName` from `student`where StudentName like &#x27;刘%&#x27;--查询1001,1002,1003号学员select `StudentNo`,`StudentName` from `student`where StudentNo in (1001,1002,1003)\n\n4.2 联表查询where 等值查询\njoin on 连接查询\n\n查表思路：\n\n分析需求：分析查询的字段来自哪些表\n确定使用哪种连接查询（7种）\n确定交叉点（判断的条件：student.studentNo = grade.studentNo）\n\n-- 查询缺考的学生select s.StudentNo,studentName,SubjectNo,StudentResultfrom student sleft join result ron s.studentNo = r.studentNowhere StudentResult is null\n\n自连接核心：一张表拆成两张一样的表\nselect a.`categoryName` as &#x27;父栏目&#x27;,b.`categoryName` as &#x27;子栏目&#x27;from `category` as a,`category` as bwhere a.`categoryid` = b.`pid`\n\n4.3 分页和排序limit &amp; order by\n排序：升序 ASC 降序 DESC\n-- 分页：起始值，页面大小limit start(0-),sizelimit 0,5 -- 第一页limit 5,5 -- 第二页...limit (N-1)*pageSize,pageSize --第N页\n\n4.4 嵌套查询select 字段 from 表\nwhere(子查询)\n-- 由里及外select StudentNo,StudentName from student where StudentNo in (    select StudentNo from result where StudentResult&gt;80    and SubjectNo = (        select SubjectNo from `subject` where `SubjectName` = &#x27;高等数学-2&#x27;    ))\n\n5 MySQL函数官网：https://dev.mysql.com/doc/refman/5.7/en/sql-function-reference.html\n5.1 常用函数-- 数学函数select abs(-8) -- 8select ceiling(9.4) -- 10select floor(9.4) -- 9select rand() -- 0~1select sign(-10/0/10) -- -1,0,1-- 字符串函数select char_length(&#x27;xxxxx&#x27;)select concat(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)select insert(&#x27;xxx&#x27;,pos,length,&#x27;yyy&#x27;)select lower(&#x27;XXX&#x27;)select upper(&#x27;xxx&#x27;)select instr(&#x27;xyz&#x27;,&#x27;x&#x27;) -- 返回子串第一次出现的索引select replace(&#x27;abc&#x27;,&#x27;b&#x27;,&#x27;d&#x27;)select substr(&#x27;abcdefg&#x27;,pos,length)select reverse(&#x27;cba&#x27;)-- 查询姓周的同学,替换成邹select replace(studentname,&#x27;周&#x27;&#x27;邹&#x27;） from studentwhere studentname like &#x27;周%&#x27;               -- 时间和日期函数（记住）select current_date()select curdate()select now() -- 当前时间select localtime()select sysdate()-- 系统select system_user()    select user()select version()\n\n5.2 聚合函数select count(字段) from 表 -- 忽略null值，有主键，count(字段)查询效率高select count(*) from 表select count(1) from 表select sum(`StudentResult`) as 总和 from resultselect avg(`StudentResult`) as 平均分 from resultselect max(`StudentResult`) as 最高分 from resultselect min(`StudentResult`) as 最低分 from result-- 分组：查询不同课程的平均分，最高分，最低分select SubjectName,avg(StudentResult) as 平均分,max(StudentResult) as 最高分,min(StudentResult) as 最低分from result rinner join `subject` subon r.`SubjectNo` = sub.`SubjectNo`group by r.SubjectNo -- 分组字段having 平均分&gt;80\n\n5.3 MD5加密不可逆\n破解原理：暴力破解，一个个试\nMD5(pwd)\n将用户传递进来的密码，进行MD5加密，然后比对加密后的值\n6 事务将一组SQL放在一个批次中执行\n原则：ACID（原子性，一致性，隔离性，持久性）\n原子性（Atomicity）\n要么都成功，要么都失败\n一致性（Consistency）\n事务前后的数据完整性要保证一致\n隔离性（Isolation）\n事物之间要相互隔离\n持久性（Durability）\n事务一旦提交则不可逆，被持久化到数据库中\n隔离导致的问题：脏读（读到另一事务未提交的数据）、不可重复读（多次读取结果不同）、幻读（读取别的事务插入的数据）\n-- mysql默认开启事务自动提交set autocommit = 0 -- 关闭set autocommit = 1 -- 开启（默认）-- 手动处理事务set autocommit = 0-- 事务开启start transactioninsert XXXinsert yyy-- 提交commit-- 回滚rollback-- 事务结束set autocommit = 1-- 了解savepoint 保存点名rollback to savepoint 保存点名release savepoint 保存点名\n\n7 索引\nMySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。\n\n7.1 索引的分类\n主键索引（primary key）\n唯一索引（unique key）\n常规索引（key/index）\n全文索引（fulltext）\n\n-- 索引的使用-- 1.在创建表的时候给字段增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息select index from 表名-- 增加一个全文索引alter table 数据库.表名 add fulltext index 索引名(字段名)-- explain分析sql执行的状况explain select * from student --非全文索引explain select * from student where match(studentName) against(&#x27;刘&#x27;)\n\n7.2 测试索引 插入100万条数据测试索引\n--  插入100万条数据delimiter $$ -- 写函数前必须写，标志create function mock_data()returns intbegin\tdeclare num int default 1000000;\tdeclare i int default 0;\twhile i&lt;num do\t\t-- 插入语句\t\tinsert into app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) values(concat(&#x27;用户&#x27;,i),&#x27;178343244@qq.com&#x27;,concat(&#x27;18&#x27;,floor(rand()*(999999999-100000000))+100000000),floor(rand()*2),uuid(),floor(rand()*100));\t\tset i = i+1;\tend while;\t\treturn i;end;select mock_data();-- 测试索引select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.0993 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询99万条数据-- 创建普通索引-- create index 索引名 on 表(字段)-- 索引名：id_表名_字段名create index id_app_user_name on app_user(`name`);select * from app_user where `name` = &#x27;用户9999&#x27;; -- 0.001 secexplain select * from app_user where `name` = &#x27;用户9999&#x27;; -- 查询1条数据\n\n总结：索引在小数据量的时候用处不大，但在大数据的时候，区别十分明显\n7.3 索引原则\n索引不是越多越好\n不要对经常变动的数据加索引\n小数据量的表不需要加索引\n索引一般加在经常查询的字段上\n\n\n索引的数据结构\n\nHash类型的索引\nBtree：InnoDB默认\nhttp://blog.codinglabs.org/articles/theory-of-mysql-index.html\n8 权限管理和备份8.1 权限管理SQL命令操作：本质是对用户表mysql.user进行改动\n-- 创建用户create user xxx identified by &#x27;123456&#x27;-- 修改密码set password [for xxx] = password(&#x27;123456&#x27;)-- 重命名rename user xxx to yyy-- 用户授权 库.表grant all privileges on *.* to xxx -- all privileges 除授权权限-- 查询权限show grants for xxxshow grants for root@localhost-- 撤销权限revoke all privileges on *.* from xxx-- 删除用户drop user xxx\n\n8.2 MySQL备份目的：保证数据不丢失，数据转移\n方式：\n\n直接复制物理文件\n在Navicat这种可视化工具中手动导出\n使用命令行导出 mysqldump\n\nmysqldump -hlocalhost -uroot -p123456 school student &gt;D:/a.sql# 导入# 登录的情况下，切换到指定的数据库# source 备份文件source d:/a.sqlmysql -u用户名 -p密码 库名&lt; 备份文件\n\n9 规范数据库设计数据库设计：分析需求→概要设计（E-R图）\n三大范式：\n\n第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。\n1NF保证每一列不可再分\n\n第二范式（2NF）：满足1NF的前提下，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）\n2NF保证每张表只描述一件事物\n\n第三范式（3NF）：满足2NF的前提下，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\n3NF保证表中每一列数据都与主键直接相关\n\n\n规范性和性能的问题：\n关联查询的表不得超过三张\n\n考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要\n在规范性能的问题的时候，需要适当考虑规范性\n故意给某些表增加一些冗余的字段。（多表查询→单表查询）\n故意增加一些计算列（大数据量查询→小数据量查询）\n\n10 JDBCJava操作数据库\n程序通过数据库驱动操作数据库\n需要导入一个数据库驱动包：mysql-connector-java-X.X.XX.jar\npublic class JDBCFirstDemo &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        // 1. 加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 固定写法，自动加载DriverManager.registerDriver(new com.mysql.jdbc,Driver());        // 2. 用户信息和url        String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=true&quot;; // 协议(jdbc:mysql)://主机地址:端口号/数据库名?参数        String username = &quot;root&quot;;        String password = &quot;1031&quot;;        // 3. 连接成功，数据库对象Connection        Connection connection = DriverManager.getConnection(url,username,password);        // 4. Statement执行SQL对象        Statement statement = connection.createStatement();        String sql = &quot;select * from users&quot;;        ResultSet resultSet = statement.executeQuery(sql);        // 5.查看返回结果        while(resultSet.next())&#123;            System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));            System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));            System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));            System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));            System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));            System.out.println(&quot;=================&quot;);        &#125;        // 6. 释放连接，耗资源，用完关掉        resultSet.close();        statement.close();        connection.close();    &#125;&#125;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\nStatement &amp; ResultSet\nConnection connection = DriverManager.getConnection(url,username,password);Statement statement = connection.createStatement();String sql = &quot;select * from users&quot;;ResultSet resultSet = statement.executeQuery(sql); // 查询操作返回ResultSetstatement.execute(); // 执行任何SQLstatement.executeUpdate(); // 更新、插入，删除，返回一个受影响的行数// ResultSetresultSet.getObject(&quot;id&quot;) // 不知道返回类型resultSet.getString(&quot;id&quot;) // 知道返回类型// 遍历指针（光标）resultSet.next() // 移动到下一行resultSet.beforeFirst() // 移动到最前resultSet.afterLast() // 移动到最后resultSet.previous()  // 移动到前一行resultSet.absolute(row) //移动到指定行\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.2 SQL注入\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SQLInjection &#123;    public static void main(String[] args) &#123;        login(&quot;zhg&quot;,&quot;123456&quot;); // 正常登录        login(&quot;&#x27;or&#x27;1=1&quot;,&quot;&#x27;or&#x27;1=1&quot;); //SQL注入：用or拼接SQL语句...    &#125;    // 登录业务    public static void login(String username,String password)&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users where `NAME` =&#x27;&quot;+username+&quot;&#x27; and `PASSWORD` = &#x27;&quot;+password+&quot;&#x27;&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n10.3 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n10.4 数据库连接池数据库连接→执行→释放，非常浪费系统资源\n池化技术：准备一些预先的资源，过来就连接预先准备好的\n编写连接池，实现接口DataSource\n开源数据源实现\nDBCP\nC3P0\nDruid：阿里\n使用这些数据库连接池之后，我们在项目开发中不需要编写数据库的代码了！\nDBCP，需要jar包：commons-dbcp-1.4, commons-pool-1.6\nC3P0，需要jar包：c3p0-0.9.5.5, mcharge-commons-java-0.2.19\n无论使用什么数据源，本质还是一样的，DataSource接口不会变，方法就不会变\n","tags":["MySQL","JDBC"]},{"title":"注解和反射","url":"/2020/10/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","content":"1 注解简介注解（Annotation）是从JDK5.0开始引入的新技术\n作用：\n\n对程序作出解释（非必须，检查和约束）\n被其他程序读取（编译器）\n\n格式：@注解名（有的还可以添加参数值）\nAnnotation可以附加在package, class, method, field 等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问\n1.1 内置注解@Override：重写父类方法\n@Deprecated：不推荐使用\n@SuppressWarnings(“all”)：抑制警告\n1.2 元注解作用：注解其他注解，为其他annotation提供说明\nJava定义了4个标准的meta-annotation类型：@Target, @Retention, @Document, @Inherited\n\n@Target：描述注解的使用范围\n\n@Retention：描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）\n\n@Documented：说明该注解被包含在javadoc中\n\n@inherited：说明子类可以继承父类中的该注释\n\n\n1.3 自定义注解格式：public @ interface 注解名 {定义内容}\npublic class Test extends Object&#123;\t//注解可以显式赋值，如果没有默认值，则必须赋值\t@MyAnnotation(name = &quot;XXX&quot;,schools = &#123;&quot;门头沟大学&quot;,&quot;家里蹲大学&quot;&#125;)\tpublic void test() &#123;\t\t&#125;&#125;//定义一个注解//Target 描述注解使用范围@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 描述注解生效时间@Retention(value = RetentionPolicy.RUNTIME)//Documented 表示将注解生成在javadoc中@Documented//Inherited 表示子类可以继承父类的注解@Inherited@interface MyAnnotation&#123;\t//注解的参数：参数类型+参数名()\t//假如只有一参数，建议命名为value\tString name() default &quot;&quot;;\tint age() default 0;\tint id() default -1;\tString[] schools() default &#123;&quot;&quot;&#125;;&#125;\n\n2 反射机制静态语言VS动态语言\n\n动态语言：运行时代码可以根据某些条件改变自身结构（C#, JavaScript, Python…）\n\n静态语言：运行时结构不可变（Java, C, C++…）\n\n\nJava不是动态语言，但Java可以利用反射机制获得类似动态语言的特性\n反射机制（Reflection）允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法\n功能：\n\n运行时进行与类（对象）相关的操作\n运行时处理注解\n生成动态代理（AOP）\n\n优点：实现动态创建对象和编译，体现出很大的灵活性\n缺点：对性能有影响。使用反射基本上是一种解释操作，这类操作总是慢于直接执行相同的操作\n主要API：java.lang.Class…\n2.1 Class类Object类中定义了getClass()方法，被所有子类继承\n\n获取Class类的实例：\npublic class Test01 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\tPerson person = new Student();\t\tSystem.out.println(&quot;这个人是：&quot;+person.name);\t\t//一个类在内存中只有一个Class对象\t\t//一个类被加载后，类的整个结构都会被封装在Class对象中\t\t//获取类的Class对象\t\t//方式一：通过对象获得\t\tClass c1 = person.getClass();\t\tSystem.out.println(c1.hashCode());\t\t\t\t//方式二：通过Class.forName获得\t\tClass c2 = Class.forName(&quot;com.zhg.reflection.Student&quot;);\t\tSystem.out.println(c2.hashCode());\t\t\t\t//方式三：通过类名.class获得\t\tClass c3 = Student.class;\t\tSystem.out.println(c3.hashCode());\t\t\t\t//方式四：基本内置类型的包装类都有一个TYPE属性\t\tClass c4 = Integer.TYPE;\t\tSystem.out.println(c4);\t\t\t\t//获得父类类型\t\tClass c5 = c1.getSuperclass();\t\tSystem.out.println(c5);\t&#125;&#125;class Person&#123;\tpublic String name;\tpublic Person() &#123;\t\tsuper();\t&#125;\tpublic Person(String name) &#123;\t\tsuper();\t\tthis.name = name;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Person [name=&quot; + name + &quot;]&quot;;\t&#125;&#125;class Student extends Person&#123;\tpublic Student() &#123;\t\tthis.name = &quot;学生&quot;;\t&#125;&#125;class Teacher extends Person&#123;\tpublic Teacher() &#123;\t\t\t&#125;&#125;\n\n哪些类型可以有Class对象？\nimport java.lang.annotation.ElementType;//所有类型的Class对象public class Test02 &#123;\tpublic static void main(String[] args) &#123;\t\tClass c1 = Object.class; //类\t\tClass c2 = Comparable.class; //接口\t\tClass c3 = String[].class; //一维数组\t\tClass c4 = int[][].class; //二维数组\t\tClass c5 = Override.class; //注解\t\tClass c6 = ElementType.class; //枚举\t\tClass c7 = Integer.class; //基本数据类型包装类\t\tClass c8 = void.class; //void\t\tClass c9 = Class.class; //Class\t\tSystem.out.println(c1); //class java.lang.Object\t\tSystem.out.println(c2); //interface java.lang.Comparable\t\tSystem.out.println(c3); //class [Ljava.lang.String;\t\tSystem.out.println(c4); //class [[I\t\tSystem.out.println(c5); //interface java.lang.Override\t\tSystem.out.println(c6); //class java.lang.annotation.ElementType\t\tSystem.out.println(c7); //class java.lang.Integer\t\tSystem.out.println(c8); //void\t\tSystem.out.println(c9); //class java.lang.Class\t\t//只要元素类型与维度一样，就是同一Class\t\tint[] a = new int[10];\t\tint[] b = new int[100];\t\tSystem.out.println(a.getClass().hashCode());\t\tSystem.out.println(b.getClass().hashCode()); \t&#125;&#125;\n\n2.2 内存分析Java内存：堆（方法区），栈\n堆：存放new的对象和数组，可以被所有线程共享\n方法区：特殊的堆，存放所有class和static变量\n栈：存放基本变量类型，引用类型的变量\n2.2.1 类的加载过程\n加载（Load）：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象\n链接（Link）：将Java类的二进制代码合并到JVM的运行状态（JRE）中的过程\n\n验证：确保加载类信息符合JVM规范，没有安全问题\n准备：为类变量（static）分配内存并设置默认初始值\n解析：虚拟机常量池的符号（常量名）引用替换为直接引用（地址）的过程\n\n初始化（Initialize）：\n\n执行类构造器&lt;clinit&gt;()方法的过程（类构造器是构造类信息的）\n先触发父类的初始化\n保证&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步\n\npublic class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\tA a = new A();\t\tSystem.out.println(A.m);\t\t/*\t\t 1.加载到内存，会产生一个类对应的Class对象\t\t 2.链接，链接结束后 m = 0\t\t 3.初始化\t\t &lt;clinit&gt;()&#123;\t\t \tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\t\tm = 300;\t\t\tm = 100;\t\t&#125;\t\tm = 100;\t\t */\t&#125;&#125;class A&#123;\tstatic &#123;\t\tSystem.out.println(&quot;A类静态代码块初始化&quot;);\t\tm = 300;\t&#125;\tstatic int m = 100;\tpublic A() &#123;\t\tSystem.out.println(&quot;A类的无参构造器初始化&quot;);\t&#125;&#125;\n\n2.2.2 类的初始化什么时候会发生类的初始化？\n\n类的主动引用（一定会发生类的初始化）\n虚拟机启动时先初始化main方法所在的类\nnew一个类的对象\n调用类的静态成员和静态方法（除了final常量）\n对类进行反射调用\n当初始化一个类时，先初始化其父类\n\n\n类的被动引用（不会发生类的初始化）\n当访问静态域时，只有真正声明这个于的类才会被初始化\n通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）\n\n\n\n//测试类什么时候会初始化public class Test04 &#123;\tstatic &#123;\t\tSystem.out.println(&quot;main类被加载&quot;);\t&#125;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//1.主动引用\t\t//Son son = new Son();\t\t\t\t//反射也会产生主动引用\t\t//Class.forName(&quot;com.zhg.reflection.Son&quot;);\t\t\t\t//不会产生类的引用的方法\t\t//System.out.println(Son.b);\t\t//Son[] array = new Son[5];\t\tSystem.out.println(Son.M);\t&#125;&#125;class Father&#123;\tstatic int b = 2;\tstatic &#123;\t\tSystem.out.println(&quot;父类被加载&quot;);\t&#125;&#125;class Son extends Father&#123;\tstatic &#123;\t\tSystem.out.println(&quot;子类被加载&quot;);\t\tm = 300;\t&#125;\t\tstatic int m = 100;\tstatic final int M = 1;&#125;\n\n2.2.3 类加载器作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成这个类的Class对象，作为方法区中类数据的访问入口\n\n类缓存：类加载器加载类时，先按要求查找类，如果某个类被加载到类加载器中，它将维持加载（缓存）一段时间。\n类加载器的类型：\n\n引导类加载器（负责Java核心库）\n扩展类加载器\n系统类加载器\n\npublic class Test05 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//获取系统类的加载器\t\tClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\t\tSystem.out.println(systemClassLoader);\t\t\t\t//获取系统类加载器的父类加载器--&gt;扩展类加载器\t\tClassLoader parent = systemClassLoader.getParent();\t\tSystem.out.println(parent);\t\t\t\t//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）\t\tClassLoader parent1 = parent.getParent();\t\tSystem.out.println(parent1);\t\t\t\t//测试当前类是哪个加载器加载的（系统类加载器）\t\tClassLoader classLoader = Class.forName(&quot;com.zhg.reflection.Test05&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//测试JDK内置的类是谁加载的（根加载器）\t\tclassLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();\t\tSystem.out.println(classLoader);\t\t\t\t//如何获得系统类加载器可以加载的路径\t\tSystem.out.println(System.getProperty(&quot;java.class.path&quot;));\t\t\t\t//双亲委派机制\t\t\t//java.lang.String--&gt;多重检测，保证安全性\t&#125;&#125;\n\n2.2.4 获取类的结构通过反射获取运行时类的完整结构\nField, Method, Constructor, Superclass, Interface, Annotation…\n//获取类的信息public class Test06 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, NoSuchMethodException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\tPerson person = new Person();\t\tc1 = person.getClass();\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的名字\t\tSystem.out.println(c1.getName()); //获得包名 + 类名\t\tSystem.out.println(c1.getSimpleName()); //获得类名\t\t\t//获得类的属性\t\tField[] fields = c1.getFields(); //只能找到public属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\tfields = c1.getDeclaredFields(); //找到全部的属性\t\tfor(Field field:fields) &#123;\t\t\tSystem.out.println(field);\t\t&#125;\t\t\t//获取指定属性的值\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\tSystem.out.println(name);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得类的方法\t\tMethod[] methods = c1.getMethods(); //获得本类及父类的所有public方法\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;正常的：&quot;+method);\t\t&#125;\t\tmethods = c1.getDeclaredMethods(); //获得本类的所有方法（包括private方法）\t\tfor(Method method:methods) &#123;\t\t\tSystem.out.println(&quot;getDeclaredMethods：&quot;+method);\t\t&#125;\t\t//获得指定方法\t\tMethod getName = c1.getMethod(&quot;getName&quot;, null);\t\tMethod setName = c1.getMethod(&quot;setName&quot;, String.class);\t\tSystem.out.println(getName);\t\tSystem.out.println(setName);\t\tSystem.out.println(&quot;==================&quot;);\t\t//获得指定的构造器\t\tConstructor[] constructors = c1.getConstructors(); //获得public构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(constructor);\t\t&#125;\t\tconstructors = c1.getDeclaredConstructors(); //获得全部构造器\t\tfor(Constructor constructor:constructors) &#123;\t\t\tSystem.out.println(&quot;#&quot;+constructor);\t\t&#125;\t\t//获得指定的构造器\t\tConstructor declaredConstructor = c1.getDeclaredConstructor(String.class);\t\tSystem.out.println(&quot;指定：&quot;+declaredConstructor);\t&#125;&#125;\n\n2.3 实际应用2.3.1 动态创建对象动态创建类的对象：调用Class对象的newInstance()方法\n\n类必须有一个无参构造器\n类的构造器的访问权限需要足够\n\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//通过反射动态的创建对象public class Test07 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;\t\t//构造Class对象\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.Person&quot;);\t\t\t\t//构造一个对象\t\tPerson person = (Person) c1.newInstance();  //本质是调用了类的无参构造器\t\tSystem.out.println(person);\t\t\t\t//通过构造器创建对象\t\tConstructor constructor = c1.getDeclaredConstructor(String.class);\t\tPerson person2 = (Person)constructor.newInstance(&quot;XX&quot;);\t\tSystem.out.println(person2);\t\t\t\t//通过反射调用普通方法\t\tPerson person3 = (Person) c1.newInstance();\t\tMethod setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);\t\t//invoke(对象，方法参数)\t\tsetName.invoke(person3, &quot;XXX&quot;);\t\tSystem.out.println(person3.name);\t\tSystem.out.println(&quot;=================&quot;);\t\t//通过反射操作属性\t\tPerson person4 = (Person) c1.newInstance();\t\tField name = c1.getDeclaredField(&quot;name&quot;);\t\t//不能直接操作私有属性，需要关闭程序的安全检测，属性或者方法的setAccessible(true)\t\tname.setAccessible(true); //\t\tname.set(person4, &quot;XXXX&quot;);\t\tSystem.out.println(person4.getName());\t\t\t&#125;&#125;\n\nsetAccessible参数值为true则指示反射的对象在使用时取消Java语言访问检查→提高了反射的效率；使得原本无法访问的私有成员也可以访问\n性能分析（调用对象的方法）：普通方式 VS 反射方式 VS 关闭检测后反射\nimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class Test08 &#123;\t//普通方式调用\tpublic static void test01() &#123;\t\tPerson person = new Person();\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tperson.getName();\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;普通方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t//反射方式调用\tpublic static void test02() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\t\t//反射方式调用 关闭检测\tpublic static void test03() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\tPerson person = new Person();\t\tClass c1 = person.getClass();\t\t\t\tMethod getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\t\tgetName.setAccessible(true);\t\t\t\tlong startTime = System.currentTimeMillis();\t\tfor(int i= 0; i &lt; 1000000000; i++) &#123;\t\t\tgetName.invoke(person, null);\t\t&#125;\t\tlong endTime = System.currentTimeMillis();\t\t\t\tSystem.out.println(&quot;关闭检测后反射方式执行&quot;+(endTime-startTime)+&quot;ms&quot;);\t&#125;\t\tpublic static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;\t\ttest01();\t\ttest02();\t\ttest03();\t&#125;&#125;\n\n2.3.2 获取泛型信息Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，一旦编译完成，所有和泛型有关的类型全部擦除\n通过反射操作类型：\nimport java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;//通过反射获取泛型public class Test09 &#123;\tpublic void test01(Map&lt;String,Person&gt; map,List&lt;Person&gt; list)&#123;\t\tSystem.out.println(&quot;test01&quot;);\t&#125;\tpublic Map&lt;String,Person&gt;test02()&#123;\t\tSystem.out.println(&quot;test02&quot;);\t\treturn null;\t&#125;\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException &#123;\t\tMethod method = Test09.class.getMethod(&quot;test01&quot;, Map.class,List.class);\t\tType[] genericParameterTypes = method.getGenericParameterTypes();\t\tfor(Type genericParameterType:genericParameterTypes) &#123;\t\t\tSystem.out.println(&quot;#&quot;+genericParameterType);\t\t\tif(genericParameterType instanceof ParameterizedType) &#123;\t\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericParameterType).getActualTypeArguments();\t\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tmethod = Test09.class.getMethod(&quot;test02&quot;, null);\t\tType genericReturnType = method.getGenericReturnType();\t\tif(genericReturnType instanceof ParameterizedType) &#123;\t\t\tType[] actualTypeArguments = ((ParameterizedType)genericReturnType).getActualTypeArguments();\t\t\tfor(Type actualTypeArgument:actualTypeArguments) &#123;\t\t\t\tSystem.out.println(actualTypeArgument);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n2.3.3 获取注解信息ORM(Object Relationship Mapping)：对象关系映射\n\n类和表结构对应\n属性和字段对应\n对象和记录对应\n\n利用注解和反射完成类和表结构的映射关系：\nimport java.lang.annotation.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;//练习反射操作注解public class Test10 &#123;\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException &#123;\t\tClass c1 = Class.forName(&quot;com.zhg.reflection.StudentX&quot;);\t\t\t\t//通过反射获得注解\t\tAnnotation[] annotations = c1.getAnnotations();\t\tfor(Annotation annotation:annotations) &#123;\t\t\tSystem.out.println(annotation);\t\t&#125;\t\t\t\t//获取注解的value值\t\tTableX table = (TableX)c1.getAnnotation(TableX.class);\t\tString value = table.value();\t\tSystem.out.println(value);\t\t\t\t//获取类指定的注解\t\tField f = c1.getDeclaredField(&quot;name&quot;);\t\tFieldX annotation = f.getAnnotation(FieldX.class);\t\tSystem.out.println(annotation.columnName());\t\tSystem.out.println(annotation.type());\t\tSystem.out.println(annotation.length());\t&#125;&#125;@TableX(&quot;db_student&quot;)class StudentX&#123;\t\t@FieldX(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)\tprivate int id;\t@FieldX(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)\tprivate int age;\t@FieldX(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)\tprivate String name;\tpublic StudentX() &#123;\t\tsuper();\t&#125;\tpublic StudentX(int id, int age, String name) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.age = age;\t\tthis.name = name;\t&#125;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\tpublic int getAge() &#123;\t\treturn age;\t&#125;\tpublic void setAge(int age) &#123;\t\tthis.age = age;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Student [id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;\t&#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableX&#123;\tString value();&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldX&#123;\tString columnName();\tString type();\tint length();&#125;","tags":["Java","JavaSE","注解","反射"]},{"title":"多线程详解","url":"/2020/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/","content":"1.1 线程简介多任务→多线程\n进程 VS 线程\n\n程序是指令和数据的有序集合，是一个静态的概念。\n进程是程序的一次执行过程,是一个动态的概念。\n进程中至少有一个线程，线程是CPU调度和执行的基本单位。\n\n1.2 线程创建三种创建方式：\n\n继承Thread类\n实现Runnable接口\n实现Callable接口（了解）\n\n1.2.1 继承Thread类创建线程方式一：继承Thread类→重写run()方法→调用start()启动线程\n//注意，线程开启不一定立即执行，由CPU调度执行public class TestThread1 extends Thread&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//main线程，主线程\t\tTestThread1 testThread1 = new TestThread1();\t\t//调用start()方法开启线程，交替执行\t\ttestThread1.start();\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;\t&#125;\n\n实现多线程同步下载图片\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;public class TestThread2 extends Thread&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2 t1 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2 t2 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2 t3 = new TestThread2(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\tt1.start();\t\tt2.start();\t\tt3.start();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n1.2.2 实现Runnable接口创建线程方式二：实现Runnable接口→重写run()方法→调用start()启动线程（需要Runnable接口实现类）\npublic class TestThread3 implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// run方法线程体\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在看代码—————&quot;+i);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\t//创建runnable接口的实现类对象\t\tTestThread3 testThread3 = new TestThread3();\t\t\t\t//创建线程对象，通过线程对象来开启线程，代理//\t\tThread thread = new Thread(testThread3);//\t\tthread.start();\t\tnew Thread(testThread3).start();\t\t\t\tfor(int i = 0;i &lt; 20;i++) &#123;\t\t\tSystem.out.println(&quot;我在学习多线程—————&quot;+i);\t\t&#125;\t&#125;&#125;\n\nimport java.io.File;import java.net.URL;import org.apache.commons.io.FileUtils;//练习Thread，实现多线程同步下载图片public class TestThread2n implements Runnable&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestThread2n(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic void run() &#123;\t\tWebDownloader1 webDownloader = new WebDownloader1();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread2n t1 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestThread2n t2 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestThread2n t3 = new TestThread2n(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\tnew Thread(t1).start();\t\tnew Thread(t2).start();\t\tnew Thread(t3).start();\t&#125;&#125;//下载器class WebDownloader1&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\n小结：\n\n继承Thread类\n子类继承Thread类具备多线程能力\n启动线程：子类对象.start()\n不建议使用：避免OOP单继承局限性\n\n\n实现Runnable接口\n实现接口Runnable具有多线程能力\n启动线程：传入目标对象+Thread对象.start()\n推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用\n\n\n\n多个线程同时操作一个对象，买火车票的例子\n//问题：多个线程操作同一个资源，线程不安全，数据紊乱public class TestThread4 implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\ttry &#123;\t\t\t\tThread.sleep(10);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestThread4 ticket = new TestThread4();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\n案例：龟兔赛跑\n//模拟龟兔赛跑public class Race implements Runnable&#123;\t//胜利者\tprivate static String winner; \tpublic static void main(String[] args) &#123;\t\tRace race = new Race();\t\tnew Thread(race,&quot;兔子&quot;).start();\t\tnew Thread(race,&quot;乌龟&quot;).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tfor(int i = 0; i &lt;= 100;i++) &#123;\t\t\t//模拟兔子休息\t\t\tif(&quot;兔子&quot;.equals(Thread.currentThread().getName() )&amp;&amp; i%10==5) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(56);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(&quot;乌龟&quot;.equals(Thread.currentThread().getName() )) &#123;\t\t\t\ttry &#123;\t\t\t\t\tThread.sleep(5);\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t\t//判断比赛是否结束\t\t\tboolean flag = gameOver(i);\t\t\t//如果比赛结束了，就停止程序\t\t\tif(flag) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;跑了&quot;+i+&quot;步&quot;);\t\t&#125;\t\t&#125;\t//判断是否完成比赛\tprivate boolean gameOver(int steps) &#123;\t\t//判断是否有胜利者\t\tif(winner!=null) &#123;\t\t\treturn true;\t\t&#125;else &#123;\t\t\tif(steps==100) &#123;\t\t\t\twinner = Thread.currentThread().getName();\t\t\t\tSystem.out.println(&quot;winner is &quot;+winner);\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t\treturn false;\t&#125;&#125;\n\n1.2.3 实现Callable接口创建线程方式三（了解即可）：实现Callable接口（需要返回值类型）→重写call()方法（需要抛出异常）→创建目标对象→创建关闭服务\nimport java.io.File;import java.net.URL;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import org.apache.commons.io.FileUtils;//创建方式三：实现Callable接口/* * Callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 */public class TestCallable implements Callable&lt;Boolean&gt;&#123;\tprivate String url,name; //网络图片地址，保存的文件名\tpublic TestCallable(String url,String name) &#123;\t\tthis.url = url;\t\tthis.name = name;\t&#125;\t//下载图片线程执行体\t@Override\tpublic Boolean call() &#123;\t\tWebDownloader webDownloader = new WebDownloader();\t\twebDownloader.downloader(url, name);\t\tSystem.out.println(&quot;下载了文件名为：&quot;+name);\t\treturn true;\t&#125;\tpublic static void main(String[] args) throws Exception &#123;\t\tTestCallable t1 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;1.jpg&quot;);\t\tTestCallable t2 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;2.jpg&quot;);\t\tTestCallable t3 = new TestCallable(&quot;https://pics6.baidu.com/feed/838ba61ea8d3fd1ffe50b135beb0651894ca5f6d.jpeg?token=34d0744ffdbbc1f2d6ddea302862b052&quot;,&quot;3.jpg&quot;);\t\t\t\t//创建执行服务 \t\tExecutorService ser = Executors.newFixedThreadPool(3);\t\t\t\t//提交执行\t\tFuture&lt;Boolean&gt; r1 = ser.submit(t1);\t\tFuture&lt;Boolean&gt; r2 = ser.submit(t2);\t\tFuture&lt;Boolean&gt; r3 = ser.submit(t3);\t\t\t\t//获取结果\t\tboolean rs1 = r1.get();\t\tboolean rs2 = r2.get();\t\tboolean rs3 = r3.get();\t\t\t\tSystem.out.println(rs1);\t\tSystem.out.println(rs2);\t\tSystem.out.println(rs3);\t\t//关闭服务\t\tser.shutdown();\t&#125;&#125; //下载器class WebDownloader&#123;\t//下载方法\tpublic void downloader(String url,String name) &#123;\t\ttry &#123;\t\t\tFileUtils.copyURLToFile(new URL(url), new File(name));\t\t&#125;catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;IO异常，downloader方法出现问题&quot;);\t\t&#125;\t&#125;&#125;\n\nLamda表达式语法：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }\n作用：简化代码，避免匿名内部类定义过多\nFunction Interface（函数式接口）：只包含唯一一个抽象方法\n可以通过lamda表达式来创建函数式接口的对象\n推导lambda表达式\npublic class TestLambda1 &#123;\t//3.静态内部类\tstatic class Like2 implements ILike&#123;\t\t@Override\t\tpublic void lambda() &#123;\t\t\tSystem.out.println(&quot;I like lambda2&quot;);\t\t&#125;\t\t\t&#125;\t\tpublic static void main(String[] args) &#123;\t\tILike like = new Like();\t\tlike.lambda();\t\tlike = new Like2();\t\tlike.lambda();\t\t\t\t//4.局部内部类\t\tclass Like3 implements ILike&#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda3&quot;);\t\t\t&#125;\t\t\t\t&#125;\t\tlike = new Like3();\t\tlike.lambda();\t\t\t\t//5.匿名内部类，没有类的名称，必须借助接口或者父类\t\tlike = new ILike() &#123;\t\t\t@Override\t\t\tpublic void lambda() &#123;\t\t\t\tSystem.out.println(&quot;I like lambda4&quot;);\t\t\t&#125;\t\t&#125;;\t\tlike.lambda();\t\t\t\t//6.用lambda简化\t\tlike = () -&gt; &#123;\t\t\tSystem.out.println(&quot;I like lambda5&quot;);\t\t&#125;;\t\tlike.lambda();\t&#125;&#125;//1.定义一个函数式接口interface ILike&#123;\tvoid lambda();&#125;//2.实现类class Like implements ILike&#123;\t@Override\tpublic void lambda() &#123;\t\tSystem.out.println(&quot;I like lambda&quot;);\t&#125;\t&#125;\n\n简化lambda表达式：1.省略参数类型 2.省略括号\n静态代理示例（婚庆公司）\npublic class StaticProxy &#123;\tpublic static void main(String[] args) &#123;        You you = new You(); \t\tyou.HappyMarry();        //\t\tnew Thread(()-&gt;System.out.println(&quot;我爱你&quot;)).start();//\t\tnew WeddingCompany(new You()).HappyMarry();\t\t//代理\t\tWeddingCompany weddingCompany = new WeddingCompany(new You());\t\tweddingCompany.HappyMarry();\t&#125;&#125;interface Marry&#123;\tvoid HappyMarry();&#125;//真实角色class You implements Marry&#123;\t@Override\tpublic void HappyMarry() &#123;\t\tSystem.out.println(&quot;结婚了，开心&quot;);\t\t\t&#125;&#125;//代理角色class WeddingCompany implements Marry&#123;\tprivate Marry target;\t\tpublic WeddingCompany(Marry target) &#123;\t\tthis.target = target;\t&#125;\t@Override\tpublic void HappyMarry() &#123;\t\tbefore();\t\tthis.target.HappyMarry(); //真实对象\t\tafter();\t&#125;\tprivate void after() &#123;\t\tSystem.out.println(&quot;结婚之后，收尾款&quot;);\t\t\t&#125;\tprivate void before() &#123;\t\tSystem.out.println(&quot;结婚之前，布置现场&quot;);\t\t\t&#125;\t&#125;\n\n静态代理模式总结：\n\n真实对象和代理对象都要实现同一个接口\n代理对象代理真实对象\n\n好处：\n\n代理对象可以做很多真实对象做不了的事情\n真实对象专注做自己的事情\n\n1.3 线程状态1.3.1 五大状态\n\n1.3.2 线程停止\n不推荐使用JDK提供的stop()、destroy()方法【已废弃】\n推荐线程自己停下来（建议使用一标志位进行终止变量）\n\n//测试stop//1.建议线程正常停止--&gt;利用次数，不建议死循环//2.建议使用标志位//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法public class TestStop implements Runnable&#123;\tprivate boolean flag = true;\tpublic static void main(String[] args) &#123;\t\tTestStop testStop = new TestStop();\t\tnew Thread(testStop).start();\t\tfor(int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t\tif(i == 900) &#123;\t\t\t\t//调用stop()方法切换标志位，让线程停止\t\t\t\ttestStop.stop();\t\t\t\tSystem.out.println(&quot;线程停止&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tint i = 0;\t\twhile(flag) &#123;\t\t\tSystem.out.println(&quot;run ... Thread&quot;+i++);\t\t&#125;\t\t&#125;\tpublic void stop() &#123;\t\tthis.flag = false;\t&#125;&#125;\n\n1.3.3 线程休眠sleep(毫秒)→就绪\n每个对象有个锁，sleep不会释放锁\n//模拟网络延时：放大问题的发生性public class TestSleep implements Runnable&#123;\t//票数\tprivate int ticketNum = 10;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tif(ticketNum&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\t//模拟延时\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketNum--+&quot;张票&quot;);\t\t&#125;\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tTestSleep ticket = new TestSleep();\t\tnew Thread(ticket,&quot;小明&quot;).start();\t\tnew Thread(ticket,&quot;老师&quot;).start();\t\tnew Thread(ticket,&quot;黄牛党&quot;).start();\t&#125;&#125;\n\nimport java.text.SimpleDateFormat;import java.util.Date;public class TestSleep2&#123;\tpublic static void main(String[] args) &#123;\t\t//模拟倒计时\t\ttry &#123;\t\t\ttenDown();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t//打印当前系统时间\t\tDate startTime = new Date(System.currentTimeMillis());\t\twhile(true) &#123;\t\t\ttry &#123;\t\t\t\tSystem.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\t\t\t\tThread.sleep(1000);\t\t\t\tstartTime = new Date(System.currentTimeMillis()); //更新当前时间\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t&#125;\tpublic static void tenDown() throws InterruptedException &#123;\t\tint num = 3;\t\twhile(true) &#123;\t\t\tThread.sleep(1000);\t\t\tSystem.out.println(num--);\t\t\tif(num&lt;=0) &#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\t&#125;&#125;\n\n1.3.4 线程礼让Yield让当前线程暂停但不阻塞，转为就绪状态\n礼让不一定成功\n//测试礼让线程，礼让不一定成功public class TestYield &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tMyYield myYield = new MyYield();\t\tnew Thread(myYield,&quot;a&quot;).start();\t\tnew Thread(myYield,&quot;b&quot;).start();\t&#125;&#125;class MyYield implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);\t\tThread.yield(); //礼让\t\tSystem.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);\t&#125;\t&#125;\n\n1.3.5 线程强制执行Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞（可以看作是插队）\n//测试join方法public class TestJoin implements Runnable&#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\t//启动我们的线程\t\tTestJoin testJoin = new TestJoin();\t\tThread thread = new Thread(testJoin);\t\tthread.start();\t\tfor (int i = 0; i &lt; 500; i++) &#123;\t\t\tif(i==200) &#123;\t\t\t\tthread.join();//插队\t\t\t&#125;\t\t\tSystem.out.println(&quot;main&quot;+i);\t\t&#125;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 1000; i++) &#123;\t\t\tSystem.out.println(&quot;线程vip来了&quot;+i);\t\t&#125;\t\t&#125;&#125;\n\n1.3.6 线程优先级优先高的不一定先执行，默认是5\n//测试线程的优先级public class TestPriority&#123;\tpublic static void main(String[] args) &#123;\t\t//主线程默认优先级\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\tMyPriority myPriority = new MyPriority();\t\tThread t1 = new Thread(myPriority);\t\tThread t2 = new Thread(myPriority);\t\tThread t3 = new Thread(myPriority);\t\tThread t4 = new Thread(myPriority);\t\t//先设置优先级，再启动\t\tt1.start();\t\tt2.setPriority(1);\t\tt2.start();\t\tt3.setPriority(4);\t\tt3.start();\t\tt4.setPriority(Thread.MAX_PRIORITY); //MAX_PRIORITY=10\t\tt4.start();\t&#125;&#125;class MyPriority implements Runnable&#123;\t@Override\tpublic void run() &#123;\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\t\t&#125;\t&#125;\n\n1.3.7 守护（daemon）线程线程分为用户线程和守护线程\n虚拟机必须确保用户线程（如，后台记录操作日志，监控内存，垃圾回收等待）执行完毕，但不用等待守护线程执行完毕\n//测试守护线程//上帝守护你public class TestDaemon &#123;\tpublic static void main(String[] args) &#123;\t\tGod god = new God();\t\tYou you = new You();\t\tThread thread = new Thread(god);\t\tthread.setDaemon(true); //默认是false表示是用户线程，正常的线程都是用户线程\t\tthread.start(); //守护线程启动\t\tnew Thread(you).start(); //用户线程启动\t&#125;&#125;//上帝class God implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tSystem.out.println(&quot;上帝保佑着你&quot;);\t\t&#125;\t&#125;\t&#125;//你class You implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 36500; i++) &#123;\t\t\tSystem.out.println(&quot;开心活着&quot;);\t\t&#125;\t\tSystem.out.println(&quot;====Good bye!====&quot;);\t&#125;\t&#125;\n\n1.4 线程同步多个线程操作同一资源（并发）\n线程同步是一种等待机制，多个需要同时访问同一对象的线程进图该对象的等待池形成队列，等待前面线程使用完毕，下一线程再使用\n形成条件：队列+锁（synchronized）\n1.4.1 同步方法及同步块三个不安全案例1.不安全的买票\n//不安全的买票(线程不安全）public class UnsafeBuyTicket &#123;\tpublic static void main(String[] args) &#123;\t\tBuyTicket station = new BuyTicket();\t\tnew Thread(station,&quot;苦逼的我&quot;).start();\t\tnew Thread(station,&quot;牛逼的你们&quot;).start();\t\tnew Thread(station,&quot;可恶的黄牛党&quot;).start();\t&#125;\t&#125;class BuyTicket implements Runnable&#123;\t\t//票\tprivate int ticketNum = 10;\tboolean flag = true; //外部停止方式\t@Override\tpublic void run() &#123;\t\t//买票\t\twhile(flag) &#123;\t\t\tbuy();\t\t&#125;\t&#125;\tprivate void buy() &#123;\t\tif(ticketNum&lt;=0) &#123;\t\t\tflag = false;\t\t\treturn;\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//买票        System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--);\t&#125;\t&#125;\n\n2.不安全的取钱\n//不安全的取钱（两个人）public class UnsafeBank &#123;\tpublic static void main(String[] args) &#123;\t\tAccount account = new Account(100,&quot;结婚基金&quot;);\t\tDrawing you = new Drawing(account,50,&quot;你&quot;);\t\tDrawing GF = new Drawing(account,100,&quot;女朋友&quot;);\t\tyou.start();\t\tGF.start();\t&#125;&#125;//账户class Account&#123;\tint money; //余额\tString name; //卡名\tpublic Account(int money, String name) &#123;\t\tsuper();\t\tthis.money = money;\t\tthis.name = name;\t&#125;&#125;//银行：模拟取款class Drawing extends Thread&#123;\tAccount account;\t//取了多少钱\tint drawingMoney;\t//现在手里有多少钱\tint nowMoney;\tpublic Drawing(Account account,int drawingMoney,String name) &#123;\t\tsuper(name);\t\tthis.account = account;\t\tthis.drawingMoney = drawingMoney;\t&#125;\t//取钱\t@Override\tpublic void run() &#123;\t\t//判断有没有钱\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\treturn;\t\t&#125;\t\t//放大问题的发生性\t\ttry &#123;\t\t\tThread.sleep(100);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\t//卡内余额 = 余额 - 取的钱\t\taccount.money = account.money - drawingMoney;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;&#125;\n\n3.不安全的集合\n//线程不安全的集合//添加到同一位置被覆盖public class UnsafeList &#123;\tpublic static void main(String[] args) &#123;\t\tList&lt;String&gt; list = new ArrayList&lt;String&gt;();\t\tfor (int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\nsynchronized同步方法：public synchronized void method(int args) { }\nsynchronized方法控制对“对象”的访问，每个对象对象对应一把锁，每个synchronized方法都必须获得调用该方法的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行\n同步块：synchronized(Obj) { }\nObj称为同步监视器\n\nObj可以是任何对象，但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this\n\npublic void run() &#123;\t\t//锁的对象就是变化的量，需要增删改的对象\t\tsynchronized (account) &#123;\t\t\t//判断有没有钱\t\t\tif(account.money - drawingMoney &lt; 0) &#123;\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);\t\t\t\treturn;\t\t\t&#125;\t\t\t//放大问题的发生性\t\t\ttry &#123;\t\t\t\tThread.sleep(100);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t//卡内余额 = 余额 - 取的钱\t\t\taccount.money = account.money - drawingMoney;\t\t&#125;\t\t//你手里的钱\t\tnowMoney = nowMoney + drawingMoney;\t\tSystem.out.println(account.name+&quot;余额为：&quot;+account.money);\t\t//Thread.currentThread() == this.getName()\t\tSystem.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);\t&#125;\n\nCopyOnWriteArrayListJUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。Callable接口也在JUC中。\nimport java.util.concurrent.CopyOnWriteArrayList;//测试JUC安全类型的集合public class TestJUC &#123;\tpublic static void main(String[] args) &#123;\t\tCopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();\t\tfor(int i = 0; i &lt; 10000; i++) &#123;\t\t\tnew Thread(()-&gt;&#123;\t\t\t\tlist.add(Thread.currentThread().getName());\t\t\t&#125;).start();\t\t&#125;\t\ttry &#123;\t\t\tThread.sleep(3000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(list.size());\t&#125;&#125;\n\n1.4.2 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“的问题\n//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class DeadLock &#123;\tpublic static void main(String[] args) &#123;\t\tMakeup g1 = new Makeup(0,&quot;灰姑娘&quot;);\t\tMakeup g2 = new Makeup(1,&quot;白雪公主&quot;);\t\tg1.start();\t\tg2.start();\t&#125;&#125;//口红class Lipstick&#123;\t&#125;//镜子class Mirror&#123;\t&#125;class Makeup extends Thread&#123;\t//需要的资源只有一份，用static来保证只有一份\tstatic Lipstick lipstick = new Lipstick();\tstatic Mirror mirror = new Mirror();\t\tint choice; //选择\tString girlName; //选择化妆品的人\t\tMakeup(int choice,String girlName)&#123;\t\tthis.choice = choice;\t\tthis.girlName = girlName;\t&#125;\t@Override\tpublic void run() &#123;\t\t//化妆\t\ttry &#123;\t\t\tmakeup();\t\t&#125; catch (InterruptedException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t\t//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t\t\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t\t\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n锁中锁（多个对象互相嵌套的锁）使多个线程互相抱着对方需要的资源，然后形成僵持\n解决方法：锁分开写，不要同时占有多个资源\n//化妆，互相持有对方的锁，就是需要拿到对方的资源\tprivate void makeup() throws InterruptedException &#123;\t\tif(choice == 0) &#123;\t\t\tsynchronized(lipstick) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\tThread.sleep(1000);\t\t\t&#125;\t\t\tsynchronized(mirror) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\t&#125;\t\t&#125;else &#123;\t\t\tsynchronized(mirror) &#123; //获得口红的锁\t\t\t\tSystem.out.println(this.girlName+&quot;获得镜子的锁&quot;);\t\t\t\tThread.sleep(2000);\t\t\t&#125;\t\t\tsynchronized(lipstick) &#123;\t\t\t\t\tSystem.out.println(this.girlName+&quot;获得口红的锁&quot;);\t\t\t\t&#125;\t\t&#125;\n\n产生死锁的四个必要条件：\n\n互斥条件\n请求与保持条件\n不剥夺条件\n循环等待条件\n\n1.4.3 Lock锁从JDK 5.0开始，Java提供了更强大的线程同步机制——显式定义同步锁对象来实现同步。同步锁使用Lock对象充当，Lock锁也包含在JUC内\nReentrantLock（可重入锁）类实现了Lock，可以显式加锁、释放锁\n使用格式：\nLock lock=new ReentrantLock();lock.lock();try&#123;    //处理任务&#125;catch(Exception ex)&#123;     &#125;finally&#123;    lock.unlock();   //释放锁&#125;\n\n测试Lock类（买票）：\nimport java.util.concurrent.locks.ReentrantLock;//测试Lock类public class TestLock &#123;\tpublic static void main(String[] args) &#123;\t\tTestLock2 testLock2 = new TestLock2(); \t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t\tnew Thread(testLock2).start();\t&#125;&#125;class TestLock2 implements Runnable&#123;\tint ticketNum = 10;\t\t//定义Lock锁\tprivate final ReentrantLock lock = new ReentrantLock();\t@Override\tpublic void run() &#123;\t\twhile(true) &#123;\t\t\tlock.lock();//加锁\t\t\ttry &#123;\t\t\t\tif(ticketNum &gt; 0) &#123;\t\t\t\t\ttry &#123;\t\t\t\t\t\tThread.sleep(1000);\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t\t\t// TODO Auto-generated catch block\t\t\t\t\t\te.printStackTrace();\t\t\t\t\t&#125;\t\t\t\t\tSystem.out.println(ticketNum--);\t\t\t\t&#125;else &#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;finally &#123;\t\t\t\t//解锁\t\t\t\tlock.unlock();\t\t\t&#125;\t\t\t\t&#125;\t&#125;&#125;\n\nsynchronized与Lock对比\n\nLock是显式锁（手动开启和关闭锁），synchronized是隐式锁，自动释放\n使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）\n\n1.4.4 线程通信线程通信方法：\n\n注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常\n生产者消费者问题解决方法：\n\n利用缓冲区解决：管程法\n//测试生产者消费者模型--&gt;利用缓冲区解决：管程法//生产者，消费者，产品，缓冲区public class TestPC &#123;\tpublic static void main(String[] args) &#123;\t\tSynContainer container = new SynContainer();\t\t\t\tnew Producer(container).start();\t\tnew Consumer(container).start();\t&#125;&#125;//生产者class Producer extends Thread&#123;\tSynContainer container;\tpublic Producer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t\t//生产\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\tcontainer.push(new Chicken(i));\t\t\tSystem.out.println(&quot;生产了第&quot;+i+&quot;只鸡&quot;);\t\t&#125;\t&#125;&#125;//消费者class Consumer extends Thread&#123;\tSynContainer container;\tpublic Consumer(SynContainer container) &#123;\t\tthis.container = container;\t&#125;\t//消费\t\t@Override\t\tpublic void run() &#123;\t\t\tfor (int i = 0; i &lt; 100; i++) &#123;\t\t\t\tSystem.out.println(&quot;消费了第&quot;+container.pop().id+&quot;只鸡&quot;);\t\t\t&#125;\t\t\t\t&#125;&#125;//产品class Chicken&#123;\tint id; //产品编号\tpublic Chicken(int id) &#123;\t\tthis.id = id;\t&#125;\t&#125;//缓冲区class SynContainer&#123;\t//需要一个容器大小\tChicken[] chickens = new Chicken[10];\t//容器计数器\tint count = 0;\t\t//生产者放入产品\tpublic synchronized void push(Chicken chicken) &#123;\t\t//如果容器满了，就需要等待消费者消费\t\tif(count == chickens.length) &#123;\t\t\t//通知消费者消费，生产等待\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果没有满，我们就需要丢入产品\t\tchickens[count] = chicken;\t\tcount++;\t\t\t\t//可以通知消费者消费了\t\tthis.notifyAll();\t&#125;\t//消费者消费产品\tpublic synchronized Chicken pop() &#123;\t\t//判断能否消费\t\tif(count==0) &#123;\t\t\t//等待生产者生产\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t//如果可以消费\t\tcount--;\t\tChicken chicken = chickens[count];\t\t\t//吃完了，通知生产者生产\t\tthis.notifyAll();\t\treturn chicken;\t\t\t&#125;&#125;\n\n利用标志位解决：信号灯法\npackage com.zhg.thread;//测试生产者消费者模型2--&gt;利用标志位解决：信号灯法public class TestPC2 &#123;\tpublic static void main(String[] args) &#123;\t\tTV tv = new TV();\t\tnew Player(tv).start();\t\tnew Watcher(tv).start();\t&#125;&#125;//生产者--&gt;演员class Player extends Thread&#123;\tTV tv;\tpublic Player(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\tif(i%2==0) &#123;\t\t\t\tthis.tv.play(&quot;快乐大本营&quot;);\t\t\t&#125;else &#123;\t\t\t\tthis.tv.play(&quot;广告&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;//消费者--&gt;观众class Watcher extends Thread&#123;\tTV tv;\tpublic Watcher(TV tv) &#123;\t\tthis.tv = tv;\t&#125;\t@Override\tpublic void run() &#123;\t\tfor (int i = 0; i &lt; 20; i++) &#123;\t\t\ttv.watch();\t\t&#125;\t&#125;&#125;//产品--&gt;节目class TV&#123;\t\t//演员表演，观众等待 T\t//观众观看，演员等待 F\tString voice;//表演的节目\tboolean flag = true;\t\t//表演\tpublic synchronized void play(String voice) &#123;\t\t\t\tif(!flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(&quot;演员表演了：&quot;+voice);\t\t//通知观众观看\t\tthis.notifyAll(); //通知唤醒\t\tthis.voice = voice;\t\tthis.flag = !this.flag;\t&#125;\t\t//观看\tpublic synchronized void watch() &#123;\t\tif(flag) &#123;\t\t\ttry &#123;\t\t\t\tthis.wait();\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\t// TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;观众观看了：&quot;+voice);\t\t//通知演员表演\t\tthis.notifyAll();\t\tthis.flag = !this.flag;\t&#125;&#125;\n\n\n\n线程池背景：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。\n好处：\n\n提高响应速度\n降低资源消耗\n便于线程管理\n\nJDK 5.0起提供了线程池相关API：ExecutorService和Executors\n\nExecutorService：真正的线程池接口。\n\nExecutor：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。\n\n\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//测试线程池public class TestPool &#123;\tpublic static void main(String[] args) &#123;\t\t//1.创建服务，创建线程池\t\t//newFixedThreadPool 参数为线程池大小\t\tExecutorService service = Executors.newFixedThreadPool(10);\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\tservice.execute(new MyThread());\t\t//2.关闭连接\t\tservice.shutdown();\t&#125;&#125;class MyThread implements Runnable&#123;\t@Override\tpublic void run() &#123;\t\tSystem.out.println(Thread.currentThread().getName());\t\t\t&#125;&#125;","tags":["Java","JavaSE","多线程"]},{"title":"LeetCode 140.单词拆分II","url":"/2020/11/01/LeetCode140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II/","content":"题目描述：\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。\n说明：\n\n分隔时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n\n示例1：\n输入:s = “catsanddog”wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]输出:[  “cats and dog”,  “cat sand dog”]\n示例2：\n输入:s = “pineapplepenapple”wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]输出:[  “pine apple pen apple”,  “pineapple pen apple”,  “pine applepen apple”]解释: 可以重复使用字典中的单词。\n示例3：\n输入:s = “catsandog”wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出:[]\n概述：动态规划求是否有解、回溯算法求所有具体解。题目问可不可以拆分，没有问具体怎么拆分，通常考虑使用动态规划解决；题目如果问一个问题的所有的具体解，一般而言使用回溯算法（DFS）完成。\n动态规划求是否有解：\nimport java.util.HashSet;import java.util.List;import java.util.Set;public class Solution &#123;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);        int len = s.length();        // 状态定义：以 s[i] 结尾的子字符串是否符合题意        boolean[] dp = new boolean[len];        for (int right = 0; right &lt; len; right++) &#123;            // 分类讨论 1：不拆分，substring 右端点不包含，所以是 right + 1            if (wordSet.contains(s.substring(0, right + 1))) &#123;                dp[right] = true;                continue;            &#125;            // 分类讨论 2：拆分            for (int left = right - 1; left &gt;= 0; left--) &#123;                if (wordSet.contains(s.substring(left + 1, right + 1)) &amp;&amp; dp[left]) &#123;                    dp[right] = true;                    // 这个 break 很重要，一旦得到 dp[right] = True ，循环不必再继续                    break;                &#125;            &#125;        &#125;        return dp[len - 1];    &#125;&#125;\n\n回溯算法求所有具体解：\n回溯的时间复杂度在最坏情况下高达 O(n^n)。时间复杂度高的原因是存在大量重复计算，可以通过动态规划+深度优先搜索或者记忆化搜索的方式降低时间复杂度。\n1.动态规划+深度优先搜索\nimport java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.HashSet;import java.util.List;import java.util.Set;public class Solution &#123;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        // 为了快速判断一个单词是否在单词集合中，需要将它们加入哈希表        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);        int len = s.length();        // 第 1 步：动态规划计算是否有解        // dp[i] 表示「长度」为 i 的 s 前缀子串可以拆分成 wordDict 中的单词        // 长度包括 0 ，因此状态数组的长度为 len + 1        boolean[] dp = new boolean[len + 1];        // 0 这个值需要被后面的状态值参考，如果一个单词正好在 wordDict 中，dp[0] 设置成 true 是合理的        dp[0] = true;        for (int right = 1; right &lt;= len; right++) &#123;            // 如果单词集合中的单词长度都不长，从后向前遍历是更快的            for (int left = right - 1; left &gt;= 0; left--) &#123;                // substring 不截取 s[right]，dp[left] 的结果不包含 s[left]                if (wordSet.contains(s.substring(left, right)) &amp;&amp; dp[left]) &#123;                    dp[right] = true;                    // 这个 break 很重要，一旦得到 dp[right] = True ，不必再计算下去                    break;                &#125;            &#125;        &#125;        // 第 2 步：回溯算法搜索所有符合条件的解        List&lt;String&gt; res = new ArrayList&lt;&gt;();        if (dp[len]) &#123;            Deque&lt;String&gt; path = new ArrayDeque&lt;&gt;();            dfs(s, len, wordSet, dp, path, res);            return res;        &#125;        return res;    &#125;    private void dfs(String s, int len, Set&lt;String&gt; wordSet, boolean[] dp, Deque&lt;String&gt; path, List&lt;String&gt; res) &#123;        if (len == 0) &#123;            res.add(String.join(&quot; &quot;,path));            return;        &#125;        // 可以拆分的左边界从 len - 1 依次枚举到 0        for (int i = len - 1; i &gt;= 0; i--) &#123;            String suffix = s.substring(i, len);            if (wordSet.contains(suffix) &amp;&amp; dp[i]) &#123;                path.addFirst(suffix);                dfs(s, i, wordSet, dp, path, res);                path.removeFirst();            &#125;        &#125;    &#125;&#125;\n\n2.记忆化搜索\nclass Solution &#123;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map = new HashMap&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;();        List&lt;List&lt;String&gt;&gt; wordBreaks = backtrack(s, s.length(), new HashSet&lt;String&gt;(wordDict), 0, map);        List&lt;String&gt; breakList = new LinkedList&lt;String&gt;();        for (List&lt;String&gt; wordBreak : wordBreaks) &#123;            breakList.add(String.join(&quot; &quot;, wordBreak));        &#125;        return breakList;    &#125;    public List&lt;List&lt;String&gt;&gt; backtrack(String s, int length, Set&lt;String&gt; wordSet, int index, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map) &#123;        if (!map.containsKey(index)) &#123;            List&lt;List&lt;String&gt;&gt; wordBreaks = new LinkedList&lt;List&lt;String&gt;&gt;();            if (index == length) &#123;                wordBreaks.add(new LinkedList&lt;String&gt;());            &#125;            for (int i = index + 1; i &lt;= length; i++) &#123;                String word = s.substring(index, i);                if (wordSet.contains(word)) &#123;                    List&lt;List&lt;String&gt;&gt; nextWordBreaks = backtrack(s, length, wordSet, i, map);                    for (List&lt;String&gt; nextWordBreak : nextWordBreaks) &#123;                        LinkedList&lt;String&gt; wordBreak = new LinkedList&lt;String&gt;(nextWordBreak);                        wordBreak.offerFirst(word);                        wordBreaks.add(wordBreak);                    &#125;                &#125;            &#125;            map.put(index, wordBreaks);        &#125;        return map.get(index);    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/word-break-ii\n","tags":["算法","LeetCode","DFS","记忆化搜索","动态规划"]},{"title":"JavaWeb入门","url":"/2020/11/03/JavaWeb%E5%85%A5%E9%97%A8/","content":"1 环境配置1.1 TomcatTomcat服务器目录\n\nsever.xml可以配置启动的端口号，配置主机的名称\n&lt;!--配置启动的端口号--&gt;&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!--配置主机的名称--&gt;&lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;&gt;\n\n默认端口号：\ntomcat：8080\nmysql：3306\nhttp：80\nhttps：443\n1.2 MavenMaven项目架构管理工具，自动导入和配置jar包\nMaven核心思想：约定大于配置\nMaven会规定如何编写java代码\n镜像：mirrors\n&lt;!--阿里云镜像--&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;\n\n建立一个本地仓库 localRepository\n&lt;localRepository&gt;C:\\apache-maven-3.6.3\\maven-repo&lt;/localRepository&gt;\n\n在IDEA中使用Maven\n\n\n\nMaven项目目录\n\nMaven Web应用项目目录\n\n\npom.xml是maven项目的核心文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Maven版本和头文件--&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--一开始配置的GAV--&gt;  &lt;groupId&gt;com.zhg&lt;/groupId&gt;  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;&lt;!--package：项目打包的方式jar：Java应用war：JavaWeb应用--&gt;  &lt;name&gt;javaweb-01-maven Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#x27;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;&lt;!--配置--&gt;  &lt;properties&gt;    &lt;!--项目的默认构建编码--&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;!--编码版本--&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;!--项目依赖--&gt;  &lt;dependencies&gt;    &lt;!--具体依赖的jar包配置文件--&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;!--项目构建--&gt;  &lt;build&gt;    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.8.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.22.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;\n\nMaven的高级之处在于，它会帮你导入jar包依赖的jar包\n配置resouces节点防止资源导出失败\n&lt;build&gt;    .......      &lt;resources&gt;        &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.properties&lt;/include&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;    ......&lt;/build&gt;\n\nMaven的使用\n地址：https://mvnrepository.com/\n2 HTTP两个时代：\n\nhttp1.0：\nHTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n\nhttp2.0\nHTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源\n\n\n网站访问过程：\n\n输入域名，回车；\n检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有输入域名的映射\n有：直接返回并访问对应的ip地址\n没有：去DNS服务器找，找到就返回并访问\n\n\n\nHTTP请求：\n访问百度请求：\nRequest URL: https://www.baidu.com/ Request Method: GETStatus Code: 200 OKRemote Address: 36.152.44.95:443Accept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7Cache-Control: max-age=0Connection: keep-alive\n\n请求行：请求方式（GET, POST, HEAD, DELETE, PUT, TRACT…）\nRequest URL: https://www.baidu.com/ Request Method: GET\n\n消息头：\nAccept: text/html // 支持的数据类型Accept-Encoding: gzip, deflate, br // 支持的编码格式Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7 // 语言环境Cache-Control: max-age=0 // 缓存控制Connection: keep-alive //保持连接HOST...\n\n\nHTTP响应：\n访问百度响应：\nRequest URL: https://www.baidu.com/ Request Method: GETStatus Code: 200 OKRemote Address: 36.152.44.95:443Cache-Control: privateConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8\n\n响应体：\nAccept: text/html // 支持的数据类型Accept-Encoding: gzip, deflate, br // 支持的编码格式Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7 // 语言环境Cache-Control: max-age=0 // 缓存控制Connection: keep-alive //保持连接HOST...Refresh...Location...\n\n响应状态码：\n200 请求响应成功\n3** 请求重定向\n404 找不到资源\n5** 服务器代码错误 502：网关错误\n3 ServletServlet程序开发步骤：\n\n编写一个类，实现Servlet接口\n把开发好的Java类部署到Web服务器中\n\n用IDEA开发Servlet程序步骤：\n\n构建一个普通的Maven项目，删掉里面的src目录，之后就在项目里创建module，这个空工程就是Maven的主工程\n\n创建子模块（Maven Web应用）\n父项目pom.xml中会有\n&lt;modules&gt;        &lt;module&gt;servlet-01&lt;/module&gt;&lt;/modules&gt;\n\n子项目pom.xml中会有\n&lt;parent&gt;    &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt;    &lt;groupId&gt;com.zhg&lt;/groupId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;\n\nMaven环境优化（更新web.xml，创建java和resources目录）\n\n编写Servlet程序\n\n编写普通类\n实现Servlet接口，这里直接继承HttpServlet\n\n\n\nServlet接口→GenericServlet→HttpServlet→自己写的Servlet类\n\n编写Servlet映射\n\n配置Tomcat\n\n\n一个Servlet可以映射到多个路径\n默认请求路径\n&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;error&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n映射路径可以自定义后缀（*.do）\n注意：*前不能加路径！\n具体指定的映射路径优先级更高\n3.1 ServletContextweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用\n\n共享数据\n//servlet1设置共享数据ServletContext context = this.getServletContext();String username = &quot;XXX&quot;;context.setAttribute(&quot;username&quot;,username);//servlet2读取共享数据ServletContext context = this.getServletContext();String username = (String) context.getAttribute(&quot;username&quot;);\n\n获取初始化参数\n&lt;context-param&gt;    &lt;param-name&gt;url&lt;/param-name&gt;    &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;  &lt;/context-param&gt;\n\nServletContext context = this.getServletContext();String url = context.getInitParameter(&quot;url&quot;);\n\n请求转发\nServletContext context = this.getServletContext();context.getRequestDispatcher(&quot;/xx&quot;).forward(req,resp);\n\n读取资源文件\nServletContext context = this.getServletContext();InputStream is = context.getResourceAsStream(&quot;/WEB-  INF/classes/db.properties&quot;);Properties prop = new Properties();prop.load(is);String user = prop.getProperty(&quot;username&quot;);\n\n\n\n3.2 ServletResponse\n发送数据\n\npublic ServletOutputStream getOutputStream() throws IOException;public PrintWriter getWriter() throws IOException;\n\n\n发送响应头\n\npublic void setCharacterEncoding(String charset);public void setContentLength(int len);public void setContentLengthLong(long len);public void setContentType(String type);public void setDateHeader(String name, long date);public void addDateHeader(String name, long date);public void setHeader(String name, String value);public void addHeader(String name, String value);public void setIntHeader(String name, int value);public void addIntHeader(String name, int value);\n\n\n响应状态码\n\n/**     * Status code (100) indicating the client can continue.     */    public static final int SC_CONTINUE = 100;    /**     * Status code (101) indicating the server is switching protocols     * according to Upgrade header.     */    public static final int SC_SWITCHING_PROTOCOLS = 101;    /**     * Status code (200) indicating the request succeeded normally.     */    public static final int SC_OK = 200;    /**     * Status code (201) indicating the request succeeded and created     * a new resource on the server.     */    public static final int SC_CREATED = 201;    /**     * Status code (202) indicating that a request was accepted for     * processing, but was not completed.     */    public static final int SC_ACCEPTED = 202;    /**     * Status code (203) indicating that the meta information presented     * by the client did not originate from the server.     */    public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;    /**     * Status code (204) indicating that the request succeeded but that     * there was no new information to return.     */    public static final int SC_NO_CONTENT = 204;    /**     * Status code (205) indicating that the agent &lt;em&gt;SHOULD&lt;/em&gt; reset     * the document view which caused the request to be sent.     */    public static final int SC_RESET_CONTENT = 205;    /**     * Status code (206) indicating that the server has fulfilled     * the partial GET request for the resource.     */    public static final int SC_PARTIAL_CONTENT = 206;    /**     * Status code (300) indicating that the requested resource     * corresponds to any one of a set of representations, each with     * its own specific location.     */    public static final int SC_MULTIPLE_CHOICES = 300;    /**     * Status code (301) indicating that the resource has permanently     * moved to a new location, and that future references should use a     * new URI with their requests.     */    public static final int SC_MOVED_PERMANENTLY = 301;    /**     * Status code (302) indicating that the resource has temporarily     * moved to another location, but that future references should     * still use the original URI to access the resource.     *     * This definition is being retained for backwards compatibility.     * SC_FOUND is now the preferred definition.     */    public static final int SC_MOVED_TEMPORARILY = 302;    /**    * Status code (302) indicating that the resource reside    * temporarily under a different URI. Since the redirection might    * be altered on occasion, the client should continue to use the    * Request-URI for future requests.(HTTP/1.1) To represent the    * status code (302), it is recommended to use this variable.    */    public static final int SC_FOUND = 302;    /**     * Status code (303) indicating that the response to the request     * can be found under a different URI.     */    public static final int SC_SEE_OTHER = 303;    /**     * Status code (304) indicating that a conditional GET operation     * found that the resource was available and not modified.     */    public static final int SC_NOT_MODIFIED = 304;    /**     * Status code (305) indicating that the requested resource     * &lt;em&gt;MUST&lt;/em&gt; be accessed through the proxy given by the     * &lt;code&gt;&lt;em&gt;Location&lt;/em&gt;&lt;/code&gt; field.     */    public static final int SC_USE_PROXY = 305;     /**     * Status code (307) indicating that the requested resource      * resides temporarily under a different URI. The temporary URI     * &lt;em&gt;SHOULD&lt;/em&gt; be given by the &lt;code&gt;&lt;em&gt;Location&lt;/em&gt;&lt;/code&gt;      * field in the response.     */    public static final int SC_TEMPORARY_REDIRECT = 307;    /**     * Status code (400) indicating the request sent by the client was     * syntactically incorrect.     */    public static final int SC_BAD_REQUEST = 400;    /**     * Status code (401) indicating that the request requires HTTP     * authentication.     */    public static final int SC_UNAUTHORIZED = 401;    /**     * Status code (402) reserved for future use.     */    public static final int SC_PAYMENT_REQUIRED = 402;    /**     * Status code (403) indicating the server understood the request     * but refused to fulfill it.     */    public static final int SC_FORBIDDEN = 403;    /**     * Status code (404) indicating that the requested resource is not     * available.     */    public static final int SC_NOT_FOUND = 404;    /**     * Status code (405) indicating that the method specified in the     * &lt;code&gt;&lt;em&gt;Request-Line&lt;/em&gt;&lt;/code&gt; is not allowed for the resource     * identified by the &lt;code&gt;&lt;em&gt;Request-URI&lt;/em&gt;&lt;/code&gt;.     */    public static final int SC_METHOD_NOT_ALLOWED = 405;    /**     * Status code (406) indicating that the resource identified by the     * request is only capable of generating response entities which have     * content characteristics not acceptable according to the accept     * headers sent in the request.     */    public static final int SC_NOT_ACCEPTABLE = 406;    /**     * Status code (407) indicating that the client &lt;em&gt;MUST&lt;/em&gt; first     * authenticate itself with the proxy.     */    public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;    /**     * Status code (408) indicating that the client did not produce a     * request within the time that the server was prepared to wait.     */    public static final int SC_REQUEST_TIMEOUT = 408;    /**     * Status code (409) indicating that the request could not be     * completed due to a conflict with the current state of the     * resource.     */    public static final int SC_CONFLICT = 409;    /**     * Status code (410) indicating that the resource is no longer     * available at the server and no forwarding address is known.     * This condition &lt;em&gt;SHOULD&lt;/em&gt; be considered permanent.     */    public static final int SC_GONE = 410;    /**     * Status code (411) indicating that the request cannot be handled     * without a defined &lt;code&gt;&lt;em&gt;Content-Length&lt;/em&gt;&lt;/code&gt;.     */    public static final int SC_LENGTH_REQUIRED = 411;    /**     * Status code (412) indicating that the precondition given in one     * or more of the request-header fields evaluated to false when it     * was tested on the server.     */    public static final int SC_PRECONDITION_FAILED = 412;    /**     * Status code (413) indicating that the server is refusing to process     * the request because the request entity is larger than the server is     * willing or able to process.     */    public static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;    /**     * Status code (414) indicating that the server is refusing to service     * the request because the &lt;code&gt;&lt;em&gt;Request-URI&lt;/em&gt;&lt;/code&gt; is longer     * than the server is willing to interpret.     */    public static final int SC_REQUEST_URI_TOO_LONG = 414;    /**     * Status code (415) indicating that the server is refusing to service     * the request because the entity of the request is in a format not     * supported by the requested resource for the requested method.     */    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;    /**     * Status code (416) indicating that the server cannot serve the     * requested byte range.     */    public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;    /**     * Status code (417) indicating that the server could not meet the     * expectation given in the Expect request header.     */    public static final int SC_EXPECTATION_FAILED = 417;    /**     * Status code (500) indicating an error inside the HTTP server     * which prevented it from fulfilling the request.     */    public static final int SC_INTERNAL_SERVER_ERROR = 500;    /**     * Status code (501) indicating the HTTP server does not support     * the functionality needed to fulfill the request.     */    public static final int SC_NOT_IMPLEMENTED = 501;    /**     * Status code (502) indicating that the HTTP server received an     * invalid response from a server it consulted when acting as a     * proxy or gateway.     */    public static final int SC_BAD_GATEWAY = 502;    /**     * Status code (503) indicating that the HTTP server is     * temporarily overloaded, and unable to handle the request.     */    public static final int SC_SERVICE_UNAVAILABLE = 503;    /**     * Status code (504) indicating that the server did not receive     * a timely response from the upstream server while acting as     * a gateway or proxy.     */    public static final int SC_GATEWAY_TIMEOUT = 504;    /**     * Status code (505) indicating that the server does not support     * or refuses to support the HTTP protocol version that was used     * in the request message.     */    public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\n\n应用：\n\n浏览器输出消息\n\n下载文件\nimport javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class FileServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //下载步骤：        //1.获取下载文件的路径        //String realPath = this.getServletContext().getRealPath(&quot;/1.png&quot;);        String realPath = &quot;C:\\\\Users\\\\zhomg\\\\Documents\\\\Java\\\\JavaEE\\\\javaweb-02-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png&quot;;        System.out.println(&quot;下载文件的路径：&quot;+realPath);        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;)+1); //获取下载文件名        //2.设置浏览器响应头        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));        //3.获取下载文件的输入流        FileInputStream in = new FileInputStream(realPath);        //4.创建缓冲区和输出流        int len = 0;        byte[] buffer = new byte[1024];        ServletOutputStream out = resp.getOutputStream();        //5.读取输入流并存储到缓冲区，使用输出流将缓冲区中的数据输出到客户端        while((len=in.read(buffer))!=-1)&#123;            out.write(buffer,0,len);        &#125;        in.close();        out.close();    &#125;\n\n验证码\n@Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //让浏览器自动刷新        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);        //在内存中创建一个图片        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);        //得到图片，Graphics对象相当于画笔        Graphics2D g = (Graphics2D)image.getGraphics();        //设置图片的背景颜色        g.setColor(Color.WHITE);        g.fillRect(0,0,45,20);        //给图片写数据        g.setColor(Color.BLUE);        g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD,20));        g.drawString(makeNum(),0,20);        //设置浏览器打开方式为图片        resp.setContentType(&quot;image/jpeg&quot;);        //关闭浏览器缓存        resp.setDateHeader(&quot;expires&quot;,-1);        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);        //把图片写给浏览器        ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream());    &#125;    private String makeNum()&#123;        Random random = new Random();        String num = random.nextInt(10000)+&quot;&quot;;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 4-num.length(); i++) &#123;            sb.append(&quot;0&quot;);        &#125;        num = sb.toString() + num;        return num;    &#125;\n\n重定向\n\n\nA→B，B通知A访问另一个Web资源C\npublic void sendRedirect(String location) throws IOException;/*相当于resp.setHeader(&quot;Location&quot;,/r/success.jsp);resp.setStatus(302);*/\n\n重定向和转发的区别\n相同点\n\n页面都会实现跳转\n\n不同点\n\n请求转发时，URL不会产生变化 307\n重定向时，URL会产生变化 302\n\n&lt;form action=&quot;$&#123;pageContext.request.getContextPath&#125;/login&quot; method=&quot;get&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    ...    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n\n\n3.3 ServletRequestRequest是用户（客户端）的请求，可以获取客户端的各种信息\n应用：\n\n获取前端传递的参数\n\nStirng username = req.getParameter(&quot;username&quot;);\n\n\n请求转发\n\n//这里的/代表当前web应用根目录req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);\n\n4 Cookie &amp; Session4.1 Cookie\n从请求中拿到cookie信息\n服务器响应给客户端cookie\n\nCookie[] cookies = req.getCookies();cookie.getName(); //获得cookie中的keycookie.getValue(); new Cookie(&quot;lastLoginTime&quot;,System.currentTimeMills()+&quot;&quot;);cookie.setMaxAge(24*60*60);//cookie.setMaxAge(0);将cookie设置过期resp.addCookie(cookie); //响应给客户端一个cookie\n\nCookie只能存放一个大小限制为4KB的字符串信息\n编码解码：\nURLEncoder.encode(&quot;中文&quot;，&quot;utf-8&quot;);URLDecoder.decode(copkie.getValue(),&quot;utf-8&quot;);\n\n4.2 SessionHttpSession session = req.getSession();session.removeAttribute(&quot;name&quot;);//手动注销Sessionsession.invalidate();\n\n会话自动过期：web.xml配置\n&lt;!--设置session默认失效的时间--&gt;&lt;session-config&gt;\t&lt;!--15分钟后session自动失效--&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;\n\n5 JSPJSP执行原理：\ntomcat服务器中有一个work目录；\nIDEA中使用tomcat的会在IDEA中产生一个work目录\n\n发现页面转变成了Java程序\n\n浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet\nJSP最终也会被转换为一个Java类\nJSP本质上就是一个Servlet\n//初始化public void _jspInit() &#123;&#125;//销毁public void _jspDestroy() &#123;&#125;//JSPServicepublic void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)\n\n\n判断请求\n内置对象 \n\nfinal javax.servlet.jsp.PageContext pageContext;final javax.servlet.ServletContext application; //applicationContextfinal javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null;final java.lang.Object page = this; //当前页面javax.servlet.http.HttpServletRequest request;final javax.servlet.http.HttpServletResponse response;\n\n\n输出页面前增加的代码\n\nresponse.setContentType(&quot;text/html; charset=UTF-8&quot;);pageContext = _jspxFactory.getPageContext(this, request, response,null, false, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();out = pageContext.getOut();_jspx_out = out;\n\n可以在JSP页面中直接使用内置对象\nJSP基础语法\n\nJSP表达式&lt;%=(var/exp)%&gt;\n\nJSP脚本&lt;%(script)%&gt;\n\nJSP声明&lt;%!(statement)%&gt;\n\n\n区别：\nJSP声明会被编译到JSP生成的类中，而JSP表达式和脚本则会被生成到_jspService方法中\nJSP注释：&lt;%--注释--%&gt;，不会在客户端（浏览器）显示\nEL表达式：${var}\n5.1 JSP指令\npage指令\n\n&lt;%--自动生成--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;Java&quot; %&gt;&lt;%--导入jar包--%&gt;&lt;%@ page import=&quot;java.util.*&quot; %&gt;&lt;%--定制错误页面--%&gt;&lt;%@ page errorPage=&quot;error/500.jsp&quot; %&gt;\n\nweb.xml\n&lt;error-page&gt;\t&lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/error/404.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;\t&lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/error/500.jsp&lt;/location&gt;&lt;/error-page&gt;\n\n\ninclude指令\n\n&lt;%@include file=&quot;common/header.jsp&quot; %&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=&quot;common/footer.jsp&quot; %&gt;&lt;%--JSP标签--%&gt;&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;\n\n区别：\ninclude指令将三个页面的内容一并输出，本质是一个页面\ninclude标签是主页面调用两个子页面，本质还是三个页面\n作用域大小不同的内置对象\n&lt;%\t//底层→高层（作用域）：page→request→session→application\t//JVM：双亲委派机制\tpageContext.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一个页面中有效    request.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一次请求中有效    session.setAttribute(&quot;name1&quot;,&quot;1&quot;); //在一次会话中有效    application.setAttribute(&quot;name1&quot;,&quot;1&quot;); //servletContext,在打开服务器期间有效%&gt;\n\n双亲委派机制的作用：\n1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。\n拓展：请求转发\n&lt;%\tpageContext.forward(&quot;/index.jsp&quot;);\t//request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request,response);%&gt;\n\n5.2 JSP标签JSP标签\n&lt;jsp:forward page = &quot;/jsptag2.jsp&quot;&gt;\t&lt;jsp:param name = &quot;name&quot; value = &quot;xxx&quot;&gt;&lt;/jsp:param&gt;    &lt;jsp:param name = &quot;age&quot; value = &quot;18&quot;&gt;&lt;/jsp:param&gt;&lt;/jsp:forward&gt;\n\nJSTL标签→弥补HTML标签的不足\n使用jstl标签的maven依赖\n&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;\n\n核心标签\n&lt;%--引入JSTL核心标签库，才能使用JSTL标签--%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;\n\n\n格式化标签，SQL标签，XML标签\n6 JavaBeanJavaBean特定写法：\n\n必须要有一个无参构造\n属性必须私有化\n必须有对应的get/set方法\n\n一般用来和数据库字段做映射ORM\nORM：对象关系映射\n\n表→类\n字段→属性\n行→对象\n\n过滤器，文件上传，邮件发送\n7 MVC三层架构Model\n\n业务处理：业务逻辑（Service）\n数据持久层：CRUD（Dao）\n\nView\n\n展示数据\n提供链接发起Servlet请求（a, form, img…）\n\nController(Servlet)\n\n接收用户的请求：（req：请求参数、Session信息…）\n交给业务层处理相应的代码\n控制视图的跳转\n\n8 FilterFilter：过滤器，用来过滤网站的数据\n\n处理中文乱码\n登录验证\n\nFilter开发步骤：\n\n导包\n编写过滤器\n\nimport javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);    &#125;    /*    1.在过滤特定请求时，Filter所有代码都会执行    2.注意务必通过chain.doFilter让过滤器继续通行     */    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        request.setCharacterEncoding(&quot;utf-8&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        System.out.println(&quot;CharacterEncodingFilter执行前...&quot;);        chain.doFilter(request,response);        System.out.println(&quot;CharacterEncodingFilter执行后...&quot;);    &#125;    @Override    public void destroy() &#123;        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);    &#125;&#125;\n\n\nweb.xml配置Filter\n\n&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.zhg.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n9 Listener\n编写一个监听器（实现监听器的接口）\n\nimport javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class OnlineCounterListener implements HttpSessionListener &#123;    @Override    public void sessionCreated(HttpSessionEvent se) &#123;        ServletContext ctx = se.getSession().getServletContext();        Integer onlineCount = (Integer)ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count+1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;    @Override    public void sessionDestroyed(HttpSessionEvent se) &#123;        ServletContext ctx = se.getSession().getServletContext();        Integer onlineCount = (Integer)ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count-1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;&#125;\n\n\n在web.xml中注册监听器\n\n&lt;listener&gt;    &lt;listener-class&gt;com.zhg.listener.OnlineCounterListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n10 JDBC环境搭建\nmaven导入jar包\n&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;\n\nJava使用JDBC连接数据库步骤：\n\n加载驱动\n连接数据库DriverManager\n获取执行sql的对象Statement\n获取返回的结果集\n释放连接\n\n10.1 封装JDBC（JDBCUtils.java）import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static &#123;        try&#123;            InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty(&quot;driver&quot;);            url = properties.getProperty(&quot;url&quot;);            username = properties.getProperty(&quot;username&quot;);            password = properties.getProperty(&quot;password&quot;);            // 1.驱动只要加载一次            Class.forName(driver);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取连接    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url,username,password);    &#125;    //释放连接    public static void release(Connection connection, Statement statement, ResultSet resultSet)&#123;        try &#123;            if (resultSet != null)&#123;                resultSet.close();            &#125;            if (statement != null)&#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n测试用JDBC封装类来操作数据库\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(4,&#x27;zhg&#x27;,&#x27;123456&#x27;,&#x27;zhomgun@qq.com&#x27;,&#x27;2020-01-01&#x27;)&quot;; // 删改只需改sql语句            int i = statement.executeUpdate(sql);            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            statement = connection.createStatement();            String sql = &quot;select * from users&quot;; // 删改只需改sql语句            resultSet = statement.executeQuery(sql);            while(resultSet.next())&#123;                System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;));                System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;));                System.out.println(&quot;pwd=&quot;+resultSet.getObject(&quot;password&quot;));                System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;));                System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;));                System.out.println(&quot;=================&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\n\n\n10.2 PreparedStatement对象PreparedStatement可以防止SQL注入\nimport com.zhg.lesson02.utils.JDBCUtils;import java.sql.*;import java.util.Date;public class TestInsert &#123;    public static void main(String[] args) &#123;        Connection connection = null;        PreparedStatement statement = null;        ResultSet resultSet = null;        try &#123;            connection = JDBCUtils.getConnection();            //使用?占位符代替参数            String sql = &quot;insert into users(id,`NAME`,`PASSWORD`,`email`,`birthday`) values(?,?,?,?,?)&quot;; // 删改只需改sql语句            statement = connection.prepareStatement(sql); // 预编译的SQL，先写SQL，然后不执行            //手动给参数赋值            statement.setInt(1,5);            statement.setString(2,&quot;hugh&quot;);            statement.setString(3,&quot;123456&quot;);            statement.setString(4,&quot;24245525@qq.com&quot;);            // 注意点：sql.Date    数据库   new java.sql.Date(时间戳)            //        util.Date   Java    new Date().getTime() 获得时间戳            statement.setDate(5,new java.sql.Date(new Date().getTime()));            int i = statement.executeUpdate();            if(i &gt; 0)&#123;                System.out.println(&quot;插入成功！&quot;);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;finally &#123;            JDBCUtils.release(connection,statement,resultSet);        &#125;    &#125;&#125;\n\nPreparedStatement可以防止SQL注入的本质：把传递进来的参数当作字符，假如存在转义字符，就直接转义\n11 Ajax\nAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n$.ajax(&#123; \ttype: &quot;POST&quot;, \turl: &quot;$&#123;pageContext.request.contextPath&#125;/jsp/user.do&quot;,    dataType: &quot;json&quot;,    success:function(data)&#123;    \t...\t&#125;,    error:function(data)&#123;        ...    &#125;&#125;);\n\n11.1 JSON\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n使用阿里巴巴的fastjson.jar包\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;\n\nServlet中设置一个Map结果集\nMap&lt;String,String&gt; resultMap = new HashMap&lt;&gt;();...resp.setContentType(&quot;application/json&quot;);PrintWriter writer = resp.getWritter();// JSONArray 阿里巴巴的JSON工具类 → 转换格式// Map（[&quot;key1&quot;:&quot;value1&quot;]）→JSON（&#123;key:value&#125;）writter.write(JSONArray.toJSONString(resultMap));writer.flush();writer.close();\n\n12 Web项目开发用户请求数据流：前端页面（Ajax/表单提交）→Servlet→Service（处理事务）→Dao→JDBC→数据库\n12.1 上传文件实现文件上传需要jar包common-io，上传组件common-fileupload\n在页面中创建上传按钮\n&lt;form action=&quot;/upload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n上传文件处理代码（Servlet）\n// 判断上传文件是普通表单还是带文件的表单if(!ServletFileUpload.isMultipartContent(request))&#123;    return;&#125;// 创建上传文件的保存路径，建议保存在WEB-INF路径下，安全，用户无法直接访问上传的文件String uploadPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);File uploadFile = new File(uploadPath);if(!uploadFile.exists())&#123;    uploadFile.mkdir();&#125;// 临时路径，假如文件超过了预期的大小，就把这个文件放到一个临时文件中，过几天自动删除，或者提醒用户转存为永久String tmpPath = this.getServletContext().getRealPath(&quot;/WEB-INF/tmp&quot;);File tmpFile = new File(tmpPath);if(!tmpFile.exists())&#123;    tmpFile.mkdir();&#125;// 1.创建DiskFileItemFactory对象，处理文件上传路径或文件大小限制DiskFileItemFactory factory = new DiskFileItemFactory();// 通过这个工厂设置一个缓冲区，当上传文件大于缓冲区时，将其放到临时文件中factory.setSizeThreshold(1024*1024); // 缓存区大小为1Mfactory.setRepository(tmpFile);// 2.获取ServletFileUploadServletFileUpload upload = new ServletFileUpload(factory);// 监听文件上传进度upload.setProgressListener(new ProgressListener()&#123;    @Override    public void update(long pByteRead,long pContentLength,int pItem)&#123;        System.out.println(&quot;总大小：&quot;+pContentLength+&quot;已上传：&quot;+pBytesRead);    &#125;&#125;);upload.setHeaderEncoding(&quot;UTF-8&quot;);upload.setFileSizeMax(1024*1024*10); // 设置总共能上传10M文件// 3.解析前端请求，封装成FileItem对象List&lt;FileItem&gt; fileItems = upload.parseRequest(request);for(FileItem fileItem : fileItems)&#123;    if(fileItem.isFormField())&#123; //普通的表单        // getFieldName指的是前端表单控件的name        String name = fileItem.getFieldName();        String value = fileItem.getString(&quot;UTF-8&quot;);        System.out.println(name+&quot;:&quot;+value);    &#125;else&#123; //上传文件        String uploadFileName = fileItem.getName();        System.out.println(&quot;上传的文件名：&quot;+uploadFileName);        if(uploadFileName.trim().equals(&quot;&quot;)||uploadFileName==null)&#123;            continue;        &#125;        String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(/)+1);        String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(.)+1);        String uuidPath = UUID.randomUUID().toString();                String realPath = uploadPath+&quot;/&quot;+uuidPath;        File realPathFile = new File(realPath);        if(!realPathFile.exists())&#123;            realPathFile.mkdir();        &#125;        InputStream inputStream = fileItem.getInputStream();        FileOutputStream fos = new FileOutputStream(realPath+&quot;/&quot;+fileName);        byte[] buffer = new byte[1024*1024];        int len = 0;        while((len = inputStream.read(buffer)) != -1)&#123;            fos.write(buffer,0,len);        &#125;        fos.close();        inputStream.close();                msg = &quot;文件上传成功！&quot;;        fileItem.delete(); // 上传成功，清除临时文件    &#125;&#125;\n\nServletFileUpload负责上传得文件数据，并将表单中每个输入项封装成一个FileItem对象，在使用ServletFileUpload对象解析请求时需要DiskFileItemFactory对象（通过ServletFileUpload对象的构造方法或setFileItemFactory()方法设置ServletFileUpload对象的FileItemFactory属性）\n上传的注意事项：\n\n为保护服务器安全，上传文件应该放在外界无法直接访问的目录下（WEB-INF）\n为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名（时间戳，UUID，MD5，位运算）\n要限制上传文件的最大值\n可以限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法\n\n12.2 发送邮件协议：SMTP和POP3/IMAP、MIME\n当两台不同的服务器进行消息通讯时，是SMTP进行握手，A服务器发送邮件到B服务器，B服务器的SMTP会替本地用户接受外面发过来的邮件，然后POP3/IMAP去读取SMTP收取的邮件\nSMTP是邮局，POP3是快递员，快递员只会去邮局领取邮件，而不是直接去发件人手上直接拿，两个地区（邮箱服务器）邮件收发也是通过邮局（SMTP）来完成\n收发邮件步骤：\n\n用户A的邮箱为&#x78;&#120;&#x78;&#x40;&#113;&#113;&#x2e;&#x63;&#109;，通过foxmail客户端写好一封邮件点击发送，即提交到了QQ邮箱服务器，使用的是SMTP协议。\nQQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是qq邮箱，会直接存储到自己的存储空间，\n如果不是则会发送到指定邮箱服务器，使用的也是SMTP协议。163服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件\n用户B收到消息后，打开客户端访问163服务器（也可以自己敲命令直接访问），163服务器会去调用POP3服务\nPop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。\n将读取到的邮件返回给客户端软件\n\n用Java实现邮件收发，首先应该准备JavaMail API和Java Activation Framework（mail.jar, activation.jar）\nSession：定义整个程序所需程序环境信息（主机名、端口号、协议）\nMessage：邮件\nTransport（发送邮件）→Store（接收邮件）\nProperties prop = new Properties();prop.setProperty(&quot;mail.host&quot;,&quot;smtp.qq.com&quot;);prop.setProperty(&quot;mail.transport.protocol&quot;,&quot;smtp&quot;);prop.setProperty(&quot;mail.smtp.auth&quot;,true); // 需要验证用户名密码// QQ邮箱还需要设置SSL加密MailSSLSocketFactory sf = new MailSSLSocketFactory();sf.setTrustAllHosts(true);prop.put(&quot;mail.smtp.ssl.enable&quot;,&quot;true&quot;);prop.put(&quot;mail.smtp.ssl.socketFactory&quot;,sf);// 使用JavaMail发送邮件的5个步骤// 1.创建定义整个应用程序所需环境信息的Session对象// 只有QQ邮箱需要Session session = Session.getDefaultInstance(prop,new Authenticator()&#123;    public PasswordAuthentication getPasswordAuthentication()&#123;        // 发送人邮件用户名、授权码        return new PasswordAuthentication(&quot;xxxxx@qq.com&quot;,&quot;授权码&quot;); //授权码可以在QQ邮箱 设置 → 开启POP3/SMTP服务后获取    &#125;&#125;);//开启Session的debug模式，可以查看程序发送Email的运行状态session.setDebug(true);// 2.通过Session得到Transport对象Transport ts = session.getTransport();// 3.使用邮箱的用户名和授权码连接邮件服务器ts.connect(&quot;smtp.qq.com&quot;,&quot;xxxxx@qq.com&quot;,&quot;授权码&quot;)    // 4.创建邮件MimeMessage message = new MimeMessage(session);message.setFrom(new InternetAddress(&quot;xxxxx@qq.com&quot;)); // 指明发件人message.setRecipient(Message.RecipientType.To,new InternetAddress(&quot;yyyyy@qq.com&quot;)); // 指明收件人// 4.1.发送只含文本的简单邮件message.setSubject(&quot;只含文本的简单邮件&quot;);message.setContent(&quot;你好啊！&quot;,&quot;text/html;charset=UTF-8&quot;);// 4.2.发送带图片/附件的邮件message.setSubject(&quot;带图片的邮件&quot;);// 图片MimeBodyPart image = new MimeBodyPart();DataHandler dh = new DataHandler(new FileDataSource(&quot;src/resouces/xxx.jpg&quot;));image.setDataHandler(dh);image.setContentID(&quot;bz.jpg&quot;);// 文本MimeBodyPart text = new MimeBodyPart();text.setContent(&quot;这是一封带图片&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;的邮件&quot;,&quot;text/html;charset=UTF-8&quot;);// 附件MimeBodyPart attachment = new MieBodyPart();attachment.setDataHandler(new DataHandler(new FileDataSource(&quot;src/resources/1.txt&quot;)));attachment.setFileName(&quot;1.txt&quot;);// 拼装邮件正文内容MimeMultipart mm1 = new MimeMultipart();mm.addBodyPart(text);mm.addBodyPart(image);// MimeMultipart.subType:alternative(超文本) → related(内嵌资源) → mixed(附件)mm.setSubType(&quot;related&quot;); // 图片文本内嵌成功MimeBodyPart contextText = new MimeBodyPart();contentText.setContent(mm1);//拼接附件MimeMultipart allFile = new MimeMultipart();allFile.addBodyPart(attachment); allFile.addBodyPart(contentText);allFile.setSubType(&quot;mixed&quot;);// 设置到消息中，保存修改message.setContent(mm);message.saveChanges();   // 5.发送邮件ts.sendMessage(message,message.getAllRecipients());// 6.关闭连接ts.close();\n\n","tags":["Java","JavaWeb","Servlet","Session","Cookie","JSP"]},{"title":"LeetCode 57.插入区间","url":"/2020/11/04/LeetCode57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/","content":"题目描述：\n给出一个无重叠的 ，按照区间起始端点排序的区间列表。\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n示例1：\n输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]\n示例2：\n输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]\n思路：找出所有与新插入区间 newInterval = [left,right] 重叠的区间集合并将这些区间合并\n\n遍历 intervals 的区间 [li,ri] \n\n如果 ri &lt; left 或者 li &gt; right，说明 [li,ri] 与 newInterval不重叠，可直接将 [li,ri] 加入答案\n否则， [li,ri] 与 newInterval重叠，需要将 [li,ri] 与 newInterval合并\n\npublic int[][] insert(int[][] intervals, int[] newInterval) &#123;    int left = newInterval[0];    int right = newInterval[1];    boolean placed = false;    List&lt;int[]&gt; ansList = new ArrayList&lt;int[]&gt;();    for (int[] interval : intervals) &#123;        if (interval[0] &gt; right) &#123;            // 在插入区间的右侧且无交集            if (!placed) &#123;                ansList.add(new int[]&#123;left, right&#125;);                placed = true;                                &#125;            ansList.add(interval);        &#125; else if (interval[1] &lt; left) &#123;            // 在插入区间的左侧且无交集            ansList.add(interval);        &#125; else &#123;            // 与插入区间有交集，计算它们的并集            left = Math.min(left, interval[0]);            right = Math.max(right, interval[1]);        &#125;    &#125;    if (!placed) &#123;        ansList.add(new int[]&#123;left, right&#125;);    &#125;    int[][] ans = new int[ansList.size()][2];    for (int i = 0; i &lt; ansList.size(); ++i) &#123;        ans[i] = ansList.get(i);    &#125;    return ans;&#125;\n\n链接：https://leetcode-cn.com/problems/insert-interval\n类似题目：56.合并区间\n题目描述：\n给出一个区间的集合，请合并所有重叠的区间。\n示例1：\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]\n示例2：\n输入: intervals = [[1,4],[4,5]]输出: [[1,5]]\n思路：按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。\n\n然后将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间。如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，直接将这个区间加入数组 merged 的末尾；否则，需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。\npublic int[][] merge(int[][] intervals) &#123;    if (intervals.length == 0) &#123;        return new int[0][2];    &#125;    Arrays.sort(intervals, (int[] interval1, int[] interval2) -&gt; interval1[0] - interval2[0]);    List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;();    for (int i = 0; i &lt; intervals.length; ++i) &#123;        int L = intervals[i][0], R = intervals[i][1];        if (merged.size() == 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123;            merged.add(new int[]&#123;L, R&#125;);        &#125; else &#123;            merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);        &#125;    &#125;    return merged.toArray(new int[merged.size()][]);&#125;\n\n链接：https://leetcode-cn.com/problems/merge-intervals\n","tags":["算法","LeetCode","数组","排序"]},{"title":"LeetCode 1356.根据数字二进制下1的数目排序","url":"/2020/11/06/Leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/","content":"题目描述：\n给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。\n如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。\n请你返回排序后的数组。\n示例1：\n输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]\n示例2：\n输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]\n思路：调用系统自带的排序函数，改写一下排序规则即可\n统计数字二进制下1的数目：\n// 方法一int bitCount(int n) &#123;    int count = 0;    while (n &gt; 0) &#123;        if((n &amp; 1) == 1)  count++;        n &gt;&gt;= 1 ;    &#125;    return count;&#125;// 方法二int bitCount(int n) &#123;    int count = 0;    while (n != 0) &#123;        n &amp;= (n-1);        count++;    &#125;    return count;&#125;\n\n改写排序规则:\npublic int[] sortByBits(int[] arr) &#123;    int[] bit = new int[10001];    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    for (int x : arr) &#123;        list.add(x);        bit[x] = bitCount(x);    &#125;    Collections.sort(list, (Integer x,Integer y) -&gt; &#123;        if (bit[x] != bit[y]) &#123;            return bit[x] - bit[y];        &#125; else &#123;            return x - y;        &#125;    &#125;);    //return list.stream().mapToInt(Integer::intValue).toArray();    for (int i = 0; i &lt; arr.length; ++i) &#123;        arr[i] = list.get(i);    &#125;    return arr;&#125;public int bitCount(int n) &#123;    int count = 0;    while (n != 0) &#123;        n &amp;= (n-1);        count++;    &#125;    return count;&#125;\n\n\n链接：https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\n","tags":["算法","LeetCode","排序","位运算"]},{"title":"Java优先级队列（PriorityQueue）","url":"/2020/11/10/Java%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88PriorityQueue%EF%BC%89/","content":"PriorityQueue，即优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。\nJava中PriorityQueue实现了Queue接口，不允许放入null元素以及不可比较的对象（没有实现Comparable接口的对象）；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆。PriorityQueue 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。\n用法示例：\npublic class App &#123;    public static void main(String[] args) &#123;        //通过改造器指定排序规则        PriorityQueue&lt;Student&gt; q = new PriorityQueue&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;            public int compare(Student o1, Student o2) &#123;                //按照分数低到高，分数相等按名字                if(o1.getScore() == o2.getScore())&#123;                    return o1.getName().compareTo(o2.getName());                &#125;                return o1.getScore() - o2.getScore();            &#125;        &#125;);        //入列        q.offer(new Student(&quot;dafei&quot;, 20));        q.offer(new Student(&quot;will&quot;, 17));        q.offer(new Student(&quot;setf&quot;, 30));        q.offer(new Student(&quot;bunny&quot;, 20));        //出列        System.out.println(q.poll());  //Student&#123;name=&#x27;will&#x27;, score=17&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;bunny&#x27;, score=20&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;dafei&#x27;, score=20&#125;        System.out.println(q.poll());  //Student&#123;name=&#x27;setf&#x27;, score=30&#125;    &#125;&#125;\n\nLeetCode相关题目：\nLeetCode 347.前K个高频元素\n题目描述：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\nclass Solution &#123;    public int[] topKFrequent(int[] nums, int k) &#123;        Map&lt;Integer, Integer&gt; occurrences = new HashMap&lt;Integer, Integer&gt;();        for (int num : nums) &#123;            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);        &#125;        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] m, int[] n) &#123;                return m[1] - n[1];            &#125;        &#125;);        for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;            int num = entry.getKey(), count = entry.getValue();            if (queue.size() == k) &#123;                if (queue.peek()[1] &lt; count) &#123;                    queue.poll();                    queue.offer(new int[]&#123;num, count&#125;);                &#125;            &#125; else &#123;                queue.offer(new int[]&#123;num, count&#125;);            &#125;        &#125;        int[] ret = new int[k];        for (int i = 0; i &lt; k; ++i) &#123;            ret[i] = queue.poll()[0];        &#125;        return ret;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/top-k-frequent-elements\nLeetCode 973.最接近原点的K的点\n题目描述：我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。\nclass Solution &#123;    public int[][] kClosest(int[][] points, int K) &#123;        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;            public int compare(int[] array1, int[] array2) &#123;                return array2[0] - array1[0];            &#125;        &#125;);        for (int i = 0; i &lt; K; ++i) &#123;            pq.offer(new int[]&#123;points[i][0] * points[i][0] + points[i][1] * points[i][1], i&#125;);        &#125;        int n = points.length;        for (int i = K; i &lt; n; ++i) &#123;            int dist = points[i][0] * points[i][0] + points[i][1] * points[i][1];            if (dist &lt; pq.peek()[0]) &#123;                pq.poll();                pq.offer(new int[]&#123;dist, i&#125;);            &#125;        &#125;        int[][] ans = new int[K][2];        for (int i = 0; i &lt; K; ++i) &#123;            ans[i] = points[pq.poll()[1]];        &#125;        return ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/k-closest-points-to-origin/\n","tags":["算法","LeetCode","Java","JavaSE","数据结构"]},{"title":"Mybatis教程","url":"/2020/11/14/Mybatis%E6%95%99%E7%A8%8B/","content":"Mybatis教程官方文档：https://mybatis.org/mybatis-3/zh/index.html\n1 简介\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n获取方式：\n\nMaven\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.3&lt;/version&gt;&lt;/dependency&gt;\n\nGithub：https://github.com/mybatis/mybatis-3/tree/master/src/site\n\n\n数据持久化就是将程序的数据在持久状态和瞬时状态转化的过程（内存：断电即失）\nMybatis框架简化JDBC代码操作，sql与java代码分离\n2 编写Mybatis程序思路：搭建环境→导入Mybatis→编写代码→测试\n\n搭建环境\n创建数据库→新建maven项目（删除src目录）→导入maven依赖\n&lt;dependencies&gt;        &lt;!--mysql驱动--&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--junit--&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建一个模块\n编写mybatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1031&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n编写mybatis工具类\nimport org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory → sqlSessionpublic class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static&#123;        try &#123;            // 使用Mybatis首先获取sqlSessionFactory对象            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。    // 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n编写代码\n\n实体类\n\n// 实体类public class User &#123;    private int id;    private String name;    private String pwd;    public User() &#123;    &#125;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\nDao接口\n\nimport com.zhg.pojo.User;import java.util.List;public interface UserDao &#123;    List&lt;User&gt; getUserList();&#125;\n\n\n接口实现类（UserDaoImpl.java → UserMapper.xml）\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.zhg.dao.UserDao&quot;&gt;    &lt;!--select查询语句--&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.zhg.pojo.User&quot;&gt;    select * from mybatis.user;  &lt;/select&gt;&lt;/mapper&gt;\n\n\njunit测试\n\nimport com.zhg.pojo.User;import com.zhg.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123;    @Test    public void test()&#123;        // 第一步：获得SqlSession对象        SqlSession sqlSession = MybatisUtils.getSqlSession();        // 方式一：getMapper        UserDao userDao = sqlSession.getMapper(UserDao.class);        List&lt;User&gt; userList = userDao.getUserList();//      // 方式二：不推荐//        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.zhg.dao.UserDao.getUserList&quot;);        for (User user : userList) &#123;            System.out.println(user);        &#125;        // 关闭SqlSession        sqlSession.close();    &#125;&#125;\n\n可能遇到的问题：\n\n配置文件没有注册\n绑定接口错误\n方法名不对\n返回类型不对\nMaven导出资源问题\n\n注意点：\norg.apache.ibatis.binding.BindingException\njunit测试\n\n\n3 CRUDnamespace（命名空间）中绑定的包名与Dao/Mapper接口名要一致\nselect查询语句：\n\nid：namespace绑定接口中的方法名\n\nresultType：SQL语句执行的返回类型\n\nparameterType：参数类型\n\nMap：#{key}\n类：#{field}\n基本类型：直接取到\n\n多个参数用Map或注解\n\n\nUserMapper.xml\n&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zhg.pojo.User&quot;&gt;    select * from user where id = #&#123;id&#125;;&lt;/select&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.zhg.pojo.User&quot;&gt;    insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt;\n\njunit测试\nSqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User user = userMapper.getUserById(1);System.out.println(user);int count = userMapper.addUser(new User(4,&quot;XXX&quot;,&quot;111111&quot;));if(count &gt; 0)&#123;\tSystem.out.println(&quot;插入成功！&quot;);&#125;// 更新(增删改)数据库数据需要提交事务！sqlSession.commit();\n\n4 配置解析4.1 核心配置文件mybatis-config.xml\nconfiguration（配置）\n\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\n\n\n\n\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n\n\n环境配置（environments）\nMybatis可以配置多个环境，每个SQLSessionFactory实例只能选择一种环境。\nMybatis的默认事务管理器是JDBC，默认数据源类型为POOLED。\n\n属性（properties）\n可以通过properties属性实现引用配置文件（db.properties）\n\n这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。\n\n编写配置文件（db.properties）\ndriver = com.mysql.cj.jdbc.Driverurl = jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=trueusername = rootpassword = 1031\n\n核心配置文件中引入外部配置文件（优先使用）\n&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;1031&quot;/&gt;&lt;/properties&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;\n\n类型别名（typeAliases）\n\n类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。\n\n mybatis-config.xml\n &lt;typeAliases&gt;    &lt;!--可以给实体类起别名--&gt;    &lt;typeAlias type=&quot;com.zhg.pojo.User&quot; alias=&quot;User&quot;/&gt;    &lt;!--扫描包，默认别名为类名（首字母小写）--&gt;    &lt;package name=&quot;com.zhg.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\nUserMapper.xml\n &lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;    select * from user;&lt;/select&gt;\n\n可以在实体类前加注解@Alias(“XXX”)起别名\n\n设置（settings）\n\n\n\n\n\n设置名\n描述\n有效值\n默认值\n\n\n\ncacheEnabled\n全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。\ntrue | false\ntrue\n\n\nlazyLoadingEnabled\n延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。\ntrue | false\nfalse\n\n\nmapUnderscoreToCamelCase\n是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。\ntrue | false\nfalse\n\n\nlogImpl\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\n未设置\n\n\n\n其他配置\n\n类型处理器（typeHandlers）\n对象工厂（objectFactory）\nplugins插件\nmybatis-generator-core\nmybatis-plus\n通用mapper\n\n\n\n\n映射器（mappers）\n&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;com/zhg/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;com.zhg.dao.UserMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;com.zhg.dao&quot;/&gt;&lt;/mappers&gt;\n\n注意点：\n\n接口和Mapper配置文件必须同名\n接口和Mapper配置文件必须在同一包下\n\n\n\n4.2 生命周期和作用域生命周期和作用域错误的使用会导致非常严重的并发问题\nSqlSessionFactoryBuilder：一旦创建SqlSessionFactory就不在需要\nSqlSessionFactory（线程池）：一旦被创建就应该在运行期间一直存在\n5 结果映射解决实体类属性名和数据库表字段名不一致的问题\nUserMapper.xml\n&lt;!--结果集映射--&gt;&lt;resultMap id = &quot;userResultMap&quot; type = &quot;User&quot;&gt;\t&lt;!--column对应数据库中的字段，property对应实体类中的属性--&gt;    &lt;!--    &lt;result column = &quot;id&quot; property = &quot;id&quot;/&gt;    &lt;result column = &quot;name&quot; property = &quot;name&quot;/&gt;\t--&gt;\t&lt;result column = &quot;pwd&quot; property = &quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    select * from user where id = #&#123;id&#125;;&lt;/select&gt;\n\n6 日志6.1 日志工厂通过在核心配置文件中的settings中设置logImpl的值来设定在Mybatis中所用日志的具体实现\nSLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING \n &lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n\n6.2 LOG4J\nLog4j是Apache的一个开源项目，通过使用Log4j，我们可以\n\n控制日志信息输送的目的地是控制台、文件、GUI组件；\n控制每一条日志的输出格式；\n通过定义每一条日志信息的级别，更加细致地控制日志的生成过程；\n通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n\n\n导入log4j的jar包\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\nlog4j.properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/zhg.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n设置log4j为日志的实现\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt;\n\n\n\nlog4j的简单使用\n\n在使用log4j的类中，导入包org.apache.log4j.Logger\n\n日志对象，参数为当前类的class\nstatic Logger logger = Logger.getLogger(UserDaoTest.class);\n\n日志级别\nlogger.info(&quot;info&quot;);logger.debug(&quot;debug&quot;);logger.error(&quot;error&quot;);\n\n\n\n7 分页7.1 limit分页SELECT * FROM user LIMIT startIndex,pageSize;\n\n接口\n// 分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n\nMapper.xml\n&lt;select id = &quot;getUserBylimit&quot; parameterType = &quot;map&quot; resultMap = &quot;useMap&quot;&gt;    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;\n\n测试\n@Testpublic void getUserByLimit()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();    map.put(&quot;startIndex&quot;,1);    map.put(&quot;pageSize&quot;,2);        List&lt;User&gt; userList = mapper.getUserByLimit(map);    for(User user:userList)&#123;        System.out.println(user);    &#125;        sqlSession.close();&#125;\n\n\n\n7.2 RowBounds分页\n接口\n// 分页2List&lt;User&gt; getUserRowBounds();mapper.xml\n\n&lt;!--分页--&gt;&lt;select id = &quot;getUserByRowBounds&quot; resultMap = &quot;userMap&quot;&gt;    select * from mybatis.user&lt;/select&gt;\n\n测试\n@Testpublic void getUserByRowBounds()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();        // RowBounds实现    RowBounds rowBounds = new RowBounds(1,2);        // 通过Java代码层面实现分页    List&lt;User&gt; userList = sqlSession.selectList(&quot;com.zhg.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);    for(User user:userList)&#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n7.3 分页插件PageHelper：https://pagehelper.github.io/\n8 使用注解开发面向接口编程，根本原因：解耦，使定义与实现的分离\n\n在接口方法上添加注解\npublic interface UserMapper &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt; getUserList();&#125;\n\n在核心配置文件中绑定接口\n&lt;mappers&gt;    &lt;mapper class=&quot;com.zhg.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;\n\n测试\n@Testpublic void test()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getUserList();    for (User user : users) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n本质：反射机制实现\n底层：动态代理\n使用注解实现CRUD\n\n添加注解\n// 方法存在多个参数时，参数前必须加上注解@Param()@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User getUserById(@Param(&quot;id&quot;) int id);@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)int addUser(User user);\n\n测试\nSqlSession sqlSession = MybatisUtils.getSqlSession(); // sqlSessionFactory.openSession(true) 开启自动提交事务UserMapper mapper = sqlSession.getMapper(UserMapper.class);User user = mapper.getUserById(1);System.out.println(user);mapper.addUser(new User(5,&quot;Hello&quot;,&quot;123456&quot;));sqlSession.close();\n\n\n\n@Param()注解\n\n基本类型的参数或者String类型，需要加上\n引用类型不需要加\n如果只有一个基本类型，可以忽略，但建议加上\n\n9 Lombok\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n\n在IDEA中安装Lombok插件\n\n在项目中导入lombok的jar包\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;\n\n在实体类上加注解\n@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@varexperimental @var@UtilityClass\n\n常用注解：\n@Data：无参构造，get，set，toString，hashcode，equals\n@AllArgsConstructor：有参构造\n@NoArgsConstructor：无参构造\n@ToString\n@EqualsAndHashCode\n\n\n10 多对一处理数据库创建表，学生和老师是多对一的关系\nCREATE TABLE `teacher` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;); CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);\n\n学生实体类：\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123;    int id;    String name;    Teacher teacher;&#125;\n\n10.1 按照查询嵌套处理StudentMapper.xml\n&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;    select * from student;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;    &lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;teacher&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;teacher&quot; resultType=&quot;Teacher&quot;&gt;    select * from teacher where id = #&#123;id&#125;;&lt;/select&gt;\n\n10.2 按照结果嵌套处理StudentMapper.xml\n&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;    select s.id sid,s.name sname,t.name tname    from student s,teacher t    where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;\n\n11 一对多处理一个老师拥有多个学生\n老师实体类\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Teacher &#123;    int id;    String name;    List&lt;Student&gt; students;&#125;\n\n11.1 按照结果嵌套处理TeacherMapper.xml\n&lt;select id=&quot;getTeacher&quot; resultMap=&quot;Teacher&quot;&gt;    select s.id sid,s.name sname,t.id tid,t.name tname    from student s,teacher t    where s.tid = t.id and t.id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;Teacher&quot; type=&quot;Teacher&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;tid&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt;    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;sid&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n\n11.2 按照查询嵌套处理&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent&quot;&gt;    select * from teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;    &lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentsByTeacherId&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTeacherId&quot; resultType=&quot;Student&quot;&gt;    select * from student where tid = #&#123;tid&#125;;&lt;/select&gt;\n\n小结：\n\n关联 - association【多对一】\n集合 - collection【一对多】\njavaType &amp; ofType\njavaType：属性的类型\nofType：集合的泛型\n\n\n\n12 动态SQL动态SQL：根据不同条件生成不同的SQL语句\n\n动态 SQL 是 MyBatis 的强大特性之一。利用动态 SQL，可以彻底摆脱拼接 SQL 语句的痛苦。如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\n\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n创建数据库表blog\nCREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8\n\n创建实体类Blog\nimport lombok.Data;import java.util.Date;@Datapublic class Blog &#123;    String id;    String title;    String author;    Date createTime; // 属性名和字段名不一致    int views;&#125;\n\n属性名和字段名不一致，需要在核心配置文件中添加&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;，在**Mapper.xm文件的select语句中返回ResultType时，返回字段会自动转换成驼峰命名，与实体类中的属性相对应。\n12.1 条件查询与更新根据提交数据查询与更新博客\n&lt;!--if--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog where 1 = 1    &lt;if test=&quot;title != null&quot;&gt;        and title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;&lt;!--where--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;if test=&quot;title != null&quot;&gt;        \ttitle = #&#123;title&#125;    \t&lt;/if&gt;    \t&lt;if test=&quot;author != null&quot;&gt;        \tand author = #&#123;author&#125;    \t&lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!--choose,只执行一个分支--&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;choose&gt;            &lt;when test = &quot;title != null&quot;&gt;                title = #&#123;title&#125;            &lt;/when&gt;            &lt;when test = &quot;author != null&quot;&gt;                author = #&#123;author&#125;            &lt;/when&gt;            &lt;otherwise&gt;                views = #&#123;views&#125;            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!--set--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot; &gt;    update blog    &lt;set&gt;        &lt;if test=&quot;title != null&quot;&gt;        \ttitle = #&#123;title&#125;    \t&lt;/if&gt;    \t&lt;if test=&quot;author != null&quot;&gt;        \tand author = #&#123;author&#125;    \t&lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;;&lt;/update&gt;\n\n12.2 SQL片段提取重复SQL语句，方便复用！\n&lt;sql id = &quot;if&quot;&gt;\t&lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;queryBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;include refid = &quot;if&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;\n\n12.3 集合遍历查询多个特定条件的记录\n&lt;select id=&quot;queryBlog&quot;  parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\tSELECT * FROM blog    &lt;where&gt;        &lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;        \tid = #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n13 缓存13.1 简介缓存，即存在内存中的临时数据。将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上数据库查询，而是从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n缓存减少了和数据库的交互次数，减少系统开销，提高系统效率。\n经常查询且不经常改变的数据，可以使用缓存！\n13.2 Mybatis缓存MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 \n默认情况下，只启用了本地的会话缓存（一级缓存，SQLSession级别缓存），它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存（namespace级别缓存），只需要在SQL 映射文件中添加一行&lt;cache/&gt;。为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过Cache接口自定义二级缓存。\n一级缓存一级缓存也叫本地缓存：SqlSession\n与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要获取相同的数据，直接从缓存拿，不需要重新查询数据库。\n缓存失效的情况：\n\n增删改操作\n手动清理缓存sqlSession.clearCache()\n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，即获得连接到关闭连接这个时间段。\n二级缓存二级缓存也叫全局缓存：namespace\n一级缓存作用域太低了，所以诞生了二级缓存\n工作机制：\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中。如果当前会话关闭了，这个会话对应的一级缓存就没了。但我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中，新的会话中查询信息时可以从二级缓存中获取内容。\n步骤：\n\n开启全局缓存\n&lt;!--显式开启全局缓存--&gt;&lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;\n\n在要使用二级缓存的Mapper中开启\n&lt;cache  eviction=&quot;FIFO&quot;  flushInterval=&quot;60000&quot;  size=&quot;512&quot;  readOnly=&quot;true&quot;/&gt;\n\n\n\n问题：二级缓存配置中没有加上readOnly=&quot;true&quot;，出现异常Caused by: java.io.NotSerializableException:com.zhg.pojo.User\n解决：需要将实体类序列化！public class User implements Serializable&#123;...&#125;\n小结：只要开启了二级缓存，在同一个Mapper下就有效。所有数据都会先放在一级缓存中，只有当会话提交或关闭时，才会转存到二级缓存中。\n自定义缓存\nEhCache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存，Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器，缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。\n\n\n导入jar包\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n配置文件ehcache.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;         updateCheck=&quot;false&quot;&gt;    &lt;!--       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：       user.home – 用户主目录       user.dir  – 用户当前工作目录       java.io.tmpdir – 默认临时文件路径     --&gt;    &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot;/&gt;    &lt;!--       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。     --&gt;    &lt;!--      name:缓存名称。      maxElementsInMemory:缓存最大数目      maxElementsOnDisk：硬盘最大缓存个数。      eternal:对象是否永久有效，一但设置了，timeout将不起作用。      overflowToDisk:是否保存到磁盘，当系统当机时      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。      clearOnFlush：内存数量最大时是否清除。      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。      FIFO，first in first out，这个是大家最熟的，先进先出。      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。   --&gt;    &lt;defaultCache            eternal=&quot;false&quot;            maxElementsInMemory=&quot;10000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;259200&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;      &lt;cache            name=&quot;cloud_user&quot;            eternal=&quot;false&quot;            maxElementsInMemory=&quot;5000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;1800&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;  &lt;/ehcache&gt;\n\nMapper.xml中指定使用的缓存实现\n&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n\n\n\n商业项目中常使用Redis数据库（键值对）来做缓存！\n","tags":["Java","Mybatis","SSM框架"]},{"title":"LeetCode 1122.数组的相对排序","url":"/2020/11/14/LeetCode1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","content":"题目描述：\n给你两个数组，arr1 和 arr2，\narr2 中的元素各不相同arr2 中的每个元素都出现在 arr1 中对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。\n示例：\n输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19]\n提示：\narr1.length, arr2.length &lt;= 10000 &lt;= arr1[i], arr2[i] &lt;= 1000arr2 中的元素 arr2[i] 各不相同arr2 中的每个元素 arr2[i] 都出现在 arr1 中\n我的解法：\n思路：迭代两个数组，将数组arr1中出现在数组arr2的元素前置，再将未出现在数组arr2的元素按升序排列。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        int m = arr1.length, n = arr2.length;        int flag = 0;        for(int i = 0; i &lt; n; i++)&#123;            for(int j = 0; j &lt; m; j++)&#123;                if(arr1[j] == arr2[i])&#123;                    if(flag != j)&#123;                        int tmp = arr1[flag];                        arr1[flag] = arr1[j];                        arr1[j] = tmp;                     &#125;                    flag++;                &#125;            &#125;        &#125;        Arrays.sort(arr1,flag,m);        return arr1;    &#125;&#125;\n\n官方解法一：自定义排序\n思路：使用排序并自定义比较函数。对于比较函数的元素x和y有没有出现在数组arr2中分情况考虑。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for(int num : arr1) list.add(num);        for(int i = 0; i &lt; arr2.length; i++) map.put(arr2[i], i);        Collections.sort(list, (x, y) -&gt; &#123;            if(map.containsKey(x) || map.containsKey(y)) return map.getOrDefault(x, 1001) - map.getOrDefault(y, 1001); // arr2[i] &lt;= 1000            return x - y;        &#125;);        for(int i = 0; i &lt; arr1.length; i++) arr1[i] = list.get(i);        return arr1;    &#125;&#125;\n\n官方解法二：计数排序\n思路：构造数组记录值等于下标 i 出现在数组arr1中的频次frequency[i]，再遍历数组arr2，将遍历到的元素 x 加入答案 并将frequency[x]清零。最后再遍历数组frequency，将frequency[x]不为0的元素x加入答案。\nclass Solution &#123;    public int[] relativeSortArray(int[] arr1, int[] arr2) &#123;        int upper = 0;        for (int x : arr1) &#123;            upper = Math.max(upper, x);        &#125;        int[] frequency = new int[upper + 1];        for (int x : arr1) &#123;            ++frequency[x];        &#125;        int[] ans = new int[arr1.length];        int index = 0;        for (int x : arr2) &#123;            for (int i = 0; i &lt; frequency[x]; ++i) &#123;                ans[index++] = x;            &#125;            frequency[x] = 0;        &#125;        for (int x = 0; x &lt;= upper; ++x) &#123;            for (int i = 0; i &lt; frequency[x]; ++i) &#123;                ans[index++] = x;            &#125;        &#125;        return ans;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/relative-sort-array\n","tags":["算法","LeetCode","数组","排序"]},{"title":"POI和EasyExcel","url":"/2020/11/15/POI%E5%92%8CEasyExcel/","content":"POI和EasyExcel应用场景：\n\n将数据导出为Excel表格\n将Excel表格数据录入到数据库\n\n操作Excel表格目前比较流行的是Apache POI和阿里巴巴的EasyExcel\nApache POI\nApache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。\n\n官网：http://poi.apache.org/\n基本功能：\nHSSF － 提供读写Microsoft Excel格式档案的功能。（03）XSSF － 提供读写Microsoft Excel OOXML格式档案的功能。（07）HWPF － 提供读写Microsoft Word格式档案的功能。HSLF － 提供读写Microsoft PowerPoint格式档案的功能。HDGF － 提供读写Microsoft Visio格式档案的功能。\n导入依赖\n&lt;!-- xls(03) --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi&lt;/artifactId&gt;    &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- xls(07) --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;    &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日期格式化工具 --&gt;&lt;!-- https://mvnrepository.com/artifact/joda-time/joda-time --&gt;&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.10.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- test --&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;\n\nPOI-Excel写工作簿 → 工作表 → 行 → 列\n03版本\n@Testpublic void testWrite03() throws IOException &#123;    // 1.创建一个工作簿    Workbook workbook = new HSSFWorkbook();    // 2.创建一个工作表    Sheet sheet = workbook.createSheet(&quot;打卡记录03&quot;);    // 3.创建一个行    // 第一行    Row row1 = sheet.createRow(0);    // 4.创建一个单元格    Cell cell11 = row1.createCell(0);    cell11.setCellValue(&quot;姓名&quot;);    Cell cell12 = row1.createCell(1);    cell12.setCellValue(&quot;XXX&quot;);    // 第二行    Row row2 = sheet.createRow(1);    // 4.创建一个单元格    Cell cell21 = row2.createCell(0);    cell21.setCellValue(&quot;打卡时间&quot;);    Cell cell22 = row2.createCell(1);    String time = new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;);    cell22.setCellValue(time);    // 生成一张表（IO流）    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;打卡记录03.xls&quot;);    // 输出    workbook.write(fileOutputStream);    // 关闭流    fileOutputStream.close();    System.out.println(&quot;打卡记录03.xls生成完毕！&quot;);&#125;\n\n07版本\n@Testpublic void testWrite07() throws IOException &#123;    // 1.创建一个工作簿    Workbook workbook = new XSSFWorkbook();    // 2.创建一个工作表    Sheet sheet = workbook.createSheet(&quot;打卡记录07&quot;);    // 3.创建一个行    // 第一行    Row row1 = sheet.createRow(0);    // 4.创建一个单元格    Cell cell11 = row1.createCell(0);    cell11.setCellValue(&quot;姓名&quot;);    Cell cell12 = row1.createCell(1);    cell12.setCellValue(&quot;XXX&quot;);    // 第二行    Row row2 = sheet.createRow(1);    // 4.创建一个单元格    Cell cell21 = row2.createCell(0);    cell21.setCellValue(&quot;打卡时间&quot;);    Cell cell22 = row2.createCell(1);    String time = new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;);    cell22.setCellValue(time);    // 生成一张表（IO流）    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;打卡记录07.xlsx&quot;);    // 输出    workbook.write(fileOutputStream);    // 关闭流    fileOutputStream.close();    System.out.println(&quot;打卡记录07.xlsx生成完毕！&quot;);&#125;\n\n\n03版的xls最多只能容纳65536行数据\n\n07版的xlsx则没有限制，但耗时长\n\n\n可以使用SXSSFWorkbook读写大数据量的Excel表格，且耗时比XSSFWorkbook短，不过在使用SXSSFWorkbook读写Excel表格时会生成临时文件，处理结束时需加上((SXSSFWorkbook) workbook).dispose()将其清理。\n官方解释：实现”BigGridDemo”策略的流式XSSFWorkbook版本允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。但是注意，如果广泛使用例如合并区域，注释这类功能，将可能消耗大量内存。\nPOI-Excel读03版本\n@Testpublic void testRead03() throws IOException &#123;    // 获取文件流    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;打卡记录03.xls&quot;);    // 1.创建一个工作簿    Workbook workbook = new HSSFWorkbook(fileInputStream);    // 2.得到表    Sheet sheet = workbook.getSheetAt(0);    // 3.得到行    Row row = sheet.getRow(1);    // 4.得到列    Cell cell = row.getCell(1);    // 读取值的时候一定要注意类型！    System.out.println(cell.getStringCellValue());    fileInputStream.close();&#125;\n\n07版本\n@Testpublic void testRead07() throws IOException &#123;    // 获取文件流    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;打卡记录07.xlsx&quot;);    // 1.创建一个工作簿    Workbook workbook = new XSSFWorkbook(fileInputStream);    // 2.得到表    Sheet sheet = workbook.getSheetAt(0);    // 3.得到行    Row row = sheet.getRow(1);    // 4.得到列    Cell cell = row.getCell(1);    // 读取值的时候一定要注意类型！    System.out.println(cell.getStringCellValue());    fileInputStream.close();&#125;\n\n读取不同类型的数据类型\n@Testpublic void testCellType() throws Exception&#123;    // 获取文件流，读取工作簿    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;明细表.xls&quot;);    Workbook workbook = new HSSFWorkbook(fileInputStream);    Sheet sheet = workbook.getSheetAt(0);    // 获取标题内容    Row rowTitle = sheet.getRow(0);    if(rowTitle!=null)&#123;        int cellCount = rowTitle.getPhysicalNumberOfCells();        for(int cellNum = 0; cellNum &lt; cellCount; cellNum++)&#123;            Cell cell = rowTitle.getCell(cellNum);            if(cell != null)&#123;                String cellValue = cell.getStringCellValue();                System.out.print(cellValue + &quot; | &quot;);            &#125;        &#125;        System.out.println();    &#125;    // 获取表中内容    int rowCount = sheet.getPhysicalNumberOfRows();    for(int rowNum = 1; rowNum &lt; rowCount; rowNum++)&#123;        Row rowData = sheet.getRow(rowNum);        if(rowData!=null)&#123;            int cellCount = rowTitle.getPhysicalNumberOfCells();            for(int cellNum = 0; cellNum &lt; cellCount; cellNum++)&#123;                System.out.print(&quot;[&quot;+(rowNum+1)+&quot;-&quot;+(cellNum+1)+&quot;] &quot;);                Cell cell = rowData.getCell(cellNum);                // 匹配列的数据类型                if(cell != null)&#123;                    int cellType = cell.getCellType();                    String cellValue = &quot;&quot;;                    switch(cellType)&#123;                        case HSSFCell.CELL_TYPE_STRING:                            System.out.print(&quot;String - &quot;);                            cellValue = cell.getStringCellValue();                            break;                        case HSSFCell.CELL_TYPE_BOOLEAN:                            System.out.print(&quot;Boolean - &quot;);                            cellValue = String.valueOf(cell.getBooleanCellValue());                            break;                        case HSSFCell.CELL_TYPE_BLANK:                            System.out.print(&quot;Blank&quot;);                            break;                        case HSSFCell.CELL_TYPE_NUMERIC:                            System.out.print(&quot;Numeric - &quot;);                            if(HSSFDateUtil.isCellDateFormatted(cell))&#123;                                System.out.print(&quot;Date - &quot;);                                Date date = cell.getDateCellValue();                                cellValue = new DateTime(date).toString(&quot;yyyy-MM-dd&quot;);                            &#125;else &#123;                                System.out.print(&quot;Number - &quot;);                                cell.setCellType(HSSFCell.CELL_TYPE_STRING); // 防止数字过长，转化为字符串类型                                cellValue = cell.toString();                            &#125;                            break;                        case HSSFCell.CELL_TYPE_ERROR:                            System.out.println(&quot;Error&quot;);                            break;                    &#125;                    System.out.println(cellValue);                &#125;            &#125;        &#125;    &#125;    fileInputStream.close();&#125;\n\n计算公式\n@Testpublic void testFormula() throws IOException &#123;    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;公式.xls&quot;);    Workbook workbook = new HSSFWorkbook(fileInputStream);    Sheet sheet = workbook.getSheetAt(0);    Row row = sheet.getRow(1);    Cell cell = row.getCell(1);    // 拿到计算公式eval    FormulaEvaluator FormulaEvaluator = new HSSFFormulaEvaluator((HSSFWorkbook)workbook);        // 输出单元格的内容    int cellType = cell.getCellType();    switch(cellType)&#123;        case Cell.CELL_TYPE_FORMULA:            String formula = cell.getCellFormula();            System.out.println(formula);            // 计算            CellValue evaluate = FormulaEvaluator.evaluate(cell);            String cellValue = evaluate.formatAsString();            System.out.println(cellValue);            break;    &#125;    fileInputStream.close();&#125;\n\nEasyExcel\nEasyExcel重写了POI对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。\n\n官网：https://github.com/alibaba/easyexcel/\nEasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行一行读取数据，逐个解析。\n\n官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n导入依赖\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;    &lt;version&gt;2.2.6&lt;/version&gt;&lt;/dependency&gt;\n\nEasyExcel操作写入操作：固定类格式进行写入\nhttps://www.yuque.com/easyexcel/doc/write\n读取操作：根据监听器设置规则进行读取\nhttps://www.yuque.com/easyexcel/doc/read\n","tags":["Java","Excel"]},{"title":"LeetCode 222.完全二叉树的节点个数","url":"/2020/11/24/LeetCode222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","content":"题目描述：\n给出一个完全二叉树，求出该树的节点个数。\n示例：\n输入: [1,2,3,4,5,6]输出: 6\n解法一：简单递归\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null)&#123;            return 0;        &#125;        return countNodes(root.left) + countNodes(root.right) + 1;    &#125;&#125;\n\n但是解法一考虑到完全二叉树的性质。\n解法二：二分查找+位运算\n思路：首先求出二叉树高度，再根据二叉树高度算出节点个数范围，二分查找范围内中间节点，根据位运算判断中间节点是否存在。\n\nclass Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125;        int level = 0;        TreeNode node = root;        while (node.left != null) &#123;            level++;            node = node.left;        &#125;        int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1; // 2^n 可以写成 1&lt;&lt;n        while (low &lt; high) &#123;            int mid = (high - low + 1) / 2 + low;            if (exists(root, level, mid)) &#123;                low = mid;            &#125; else &#123;                high = mid - 1;            &#125;        &#125;        return low;    &#125;    public boolean exists(TreeNode root, int level, int k) &#123;        int bits = 1 &lt;&lt; (level - 1);        TreeNode node = root;        while (node != null &amp;&amp; bits &gt; 0) &#123;            if ((bits &amp; k) == 0) &#123;                node = node.left;            &#125; else &#123;                node = node.right;            &#125;            bits &gt;&gt;= 1;        &#125;        return node != null;    &#125;&#125;\n\n链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/\n","tags":["算法","LeetCode","位运算","二叉树","二分查找"]},{"title":"Spring5教程","url":"/2020/11/24/Spring5%E6%95%99%E7%A8%8B/","content":"1 Spring框架简介雏形：interface21框架\n创始人：Rod Johnson\n目标：解决企业级应用开发的复杂性，简化Java开发。\n文档地址：https://docs.spring.io/spring-framework/docs/current/reference/html/core.htmlhttps://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/\n下载地址：https://repo.spring.io/release/org/springframework/spring/\nGitHub：https://github.com/spring-projects/spring-framework\n&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n优点：开源免费，轻量级，非入侵式，支持事务处理，Java框架整合\n最大特性：控制反转（IOC），面向切面编程（AOP）\n总结：Spring是一个轻量级的控制反转和面向切面编程的框架\nSpring七大模块：\n\nSpring Boot\n\n快速开发的脚手架\n基于Spring Boot可以快速开发单个微服务\n约定大于配置\n\nSpring Cloud\n\n基于Spring Boot实现的\n\n弊端：”配置地狱“\n2 IOC理论推导2.1 IOC原型问题：需要根据用户需求修改源代码\n解决方法：使用set实现动态值注入\nprivate UserDao userDao;// 利用set进行动态实现值的注入public void setUserDao(UserDao userDao)&#123;    this.userDao = userDao;&#125;\n\n变化：程序主动创建对象 → 被动接受对象\n2.2 IOC本质控制反转IoC是一种设计思想，DI（依赖注入）是实现IoC的一种方法。面向对象编程中，对象的创建与对象间的依赖关系完全编写在程序中，由程序自己控制，控制反转后将对象的创建转移给第三方，所谓控制反转就是获得依赖对象的方式反转了。\n采用XML方式配置Bean的时候，Bean的定义是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入。\n3 HelloSpring创建类\npublic class Hello &#123;    String str;    public String getStr() &#123;        return str;    &#125;    public void setStr(String str) &#123;        this.str = str;    &#125;    @Override    public String toString() &#123;        return &quot;Hello&#123;&quot; +                &quot;str=&#x27;&quot; + str + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nSpring配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--bean：对象 id：变量名 class：类 property：类的属性 value：属性的值（基本数据类型） ref：引用其他创建的bean--&gt;    &lt;bean id=&quot;hello&quot; class=&quot;com.zhg.pojo.Hello&quot;&gt;        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试\nimport com.zhg.pojo.Hello;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123;    public static void main(String[] args) &#123;        // 获取Spring的上下文对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Hello hello = (Hello) context.getBean(&quot;hello&quot;);        System.out.println(hello.toString());    &#125;&#125;\n\n总结：\n\nSpring容器可以创建对象并设置对象属性的值\n依赖注入是利用类的set方法实现的\n\n4 IOC创建对象的方式\n使用无参构造创建对象（默认）\n\n使用有参构造创建对象\n\n参数下标\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n参数类型\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n参数名\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n\n\n\n\n总结：在配置文件加载的时候，Spring容器中管理的对象就已经初始化了！\n5 Spring配置5.1 别名&lt;!--可以通过别名获取到对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;&gt;&lt;/alias&gt;\n\n5.2 bean的配置&lt;!--\tid：bean的唯一标识，相当于对象名\tclass：包名+类型\tname：也是别名，可以同时取多个别名--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; name=&quot;user2 u2,u3;u4&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n5.3 importimport一般用于团队开发使用，可以将多个配置文件导入合并为一个。\napplicationContext.xml\n&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt;\n\n6 依赖注入6.1 构造器注入上文已经说过（4 IOC创建对象的方式）\n6.2 Set方式注入依赖注入\n\n依赖：bean对象的创建依赖于容器\n注入：bean对象的所有属性由容器来注入\n\nStudent实体类\npublic class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbys;    private Map&lt;String,String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    ...&#125;\n\napplicationContext.xml\n&lt;bean id=&quot;address&quot; class=&quot;com.zhg.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;...&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.zhg.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt;    &lt;!--数组注入--&gt;    &lt;property name=&quot;books&quot;&gt;    \t&lt;array&gt;            &lt;value&gt;book1&lt;/value&gt;            &lt;value&gt;book2&lt;/value&gt;            &lt;value&gt;book3&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name=&quot;hobbys&quot;&gt;    \t&lt;list&gt;            &lt;value&gt;hobby1&lt;/value&gt;            &lt;value&gt;hobby2&lt;/value&gt;            &lt;value&gt;hobby3&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--Map注入--&gt;    &lt;property name=&quot;card&quot;&gt;    \t&lt;map&gt;            &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;games&quot;&gt;    \t&lt;set&gt;            &lt;value&gt;hobby1&lt;/value&gt;            &lt;value&gt;hobby2&lt;/value&gt;            &lt;value&gt;hobby3&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!--null值注入--&gt;    &lt;property name=&quot;wife&quot;&gt;    \t&lt;null&gt;&lt;/null&gt;    &lt;/property&gt;    &lt;!--属性注入--&gt;    &lt;property name=&quot;info&quot;&gt;        &lt;props&gt;        \t&lt;prop key=&quot;pk1&quot;&gt;pv1&lt;/prop&gt;        \t&lt;prop key=&quot;pk2&quot;&gt;pv2&lt;/prop&gt;        \t&lt;prop key=&quot;pk3&quot;&gt;pv3&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n6.3 其他方式注入p命名空间注入&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;    &lt;/bean&gt;    &lt;bean name=&quot;john-modern&quot;        class=&quot;com.example.Person&quot;        p:name=&quot;John Doe&quot;        p:spouse-ref=&quot;jane&quot;/&gt;    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nc命名空间注入&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;    &lt;!-- traditional declaration with optional argument names --&gt;    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;        &lt;constructor-arg name=&quot;email&quot; value=&quot;[email protected]&quot;/&gt;    &lt;/bean&gt;    &lt;!-- c-namespace declaration with argument names --&gt;    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;[email protected]&quot;/&gt;&lt;/beans&gt;\n\n注意点：p命名空间和c命名空间不能直接使用，需要导入xml约束\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n\n6.4 bean的作用域\n\n\nScope\nDescription\n\n\n\nsingleton\n(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.\n\n\nprototype\nScopes a single bean definition to any number of object instances.\n\n\nrequest\nScopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nsession\nScopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\napplication\nScopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nwebsocket\nScopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\n单例模式（默认）Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，每次获取到的对象都是同一个对象。\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;XXX&quot; scope=&quot;singleton&quot;/&gt;\n\n原型模式Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。\n&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; scope=&quot;prototype&quot;/&gt;\n\n其他\n其余的request、session、application等只能在Web开发中使用！\n7 Bean的自动装配\n自动装配是使用spring满足bean依赖的一种方法\nspring会在应用上下文中为某个bean寻找其依赖的bean\n\nSpring中bean有三种装配机制，分别是：\n\n在xml中显式配置；\n在java中显式配置；\n隐式的bean发现机制和自动装配。\n\nbeans.xml显示配置\n&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;    &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;    &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n7.1 byName自动装配&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; autowire=&quot;byName&quot;&gt;   &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n当一个bean节点带有 autowire byName的属性时。\n\n将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。\n去spring容器中寻找是否有此字符串名称id的对象。\n如果有，就取出注入；如果没有，就报空指针异常。\n\n7.2 byType自动装配&lt;bean class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot; autowire=&quot;byType&quot;&gt;   &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;&lt;/bean&gt;\n\n使用autowire byType需要保证：同一类型的对象，在spring容器中唯一！\n7.3 注解自动装配jdk1.5开始支持注解，spring2.5开始全面支持注解。\n准备工作：利用注解的方式注入属性。\n\n在spring配置文件中引入context文件头\n\n开启属性注解支持！\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n@Autowired\n@Autowired是按类型自动转配的，不支持id匹配；\n\n可以直接在类的属性名上使用，也可以在set方法上使用；\n\n可以不写set方法；\n\n需要导入spring-aop的包！\n\n\n@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat;\n\n@Qualifier\n@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配；\n@Qualifier不能单独使用。\n\nbeans.xml\n&lt;bean id=&quot;dog1&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;/&gt;\n\n实体类属性上添加注解\npublic class User &#123;\t@Autowired    @Qualifier(value = &quot;cat2&quot;)    private Cat cat;    @Autowired    @Qualifier(value = &quot;dog2&quot;)    private Dog dog;&#125;\n\n@Resource\n@Resource如有指定的name属性，先按该属性进行byName方式查找装配；\n其次再进行默认的byName方式进行装配；\n如果以上都不成功，则按byType的方式自动装配。\n都不成功，则报异常。\n\nbeans.xml\n&lt;bean id=&quot;dog&quot; class=&quot;com.zhg.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zhg.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zhg.pojo.User&quot;/&gt;\n\n实体类属性上添加注解\npublic class User &#123;   //如果允许对象为null，设置required = false,默认为true   @Resource(name = &quot;cat2&quot;)   private Cat cat;   @Resource   private Dog dog;   private String str;&#125;\n\n小结\n@Autowired与@Resource异同：\n\n@Autowired与@Resource都可以用来装配bean。都可以写在属性上，或写在setter方法上。\n\n@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n\n@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n\n\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n8 使用注解开发在spring4之后，想要使用注解形式，必须得要引入aop的包\n；在配置文件当中，还得要引入一个context约束。\n\nbean的实现\nbeans.xml配置扫描哪些包下的注解\n&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.zhg.pojo&quot;/&gt;\n\n在指定包下编写类，增加注解\n@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;   public String name = &quot;XXX&quot;;&#125;\n\n属性注入\n可以不用提供set方法，直接在直接名上添加@Value(“值”)\n@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;   @Value(&quot;XXX&quot;)   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;XXX&quot;/&gt;   public String name;&#125;\n\n如果提供了set方法，也可在set方法上添加@Value(“值”)\n\n衍生注解\n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。写上这些注解，就相当于将这个类交给Spring管理装配了！\n\n@Controller：web层\n@Service：service层\n@Repository：dao层\n\n\n自动装配\n@AutoWired，@Qualified，@Resource，详见上文。\n\n作用域\n@Scope(“singleton/prototype”)\n\n\n小结\nXML与注解比较\n\nXML可以适用任何场景 ，结构清晰，维护方便\n注解不是自己提供的类使用不了，开发简单方便\n\nxml与注解整合开发 （推荐最佳实践）\n\nxml管理bean\n注解完成属性注入\n使用过程中， 可以不用扫描，扫描是为了类上的注解\n\n&lt;context:annotation-config/&gt;作用：\n\n进行注解驱动注册，从而使注解生效\n用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册\n如果不扫描包，就需要手动配置bean\n如果不加注解驱动，则注入的值为null！\n\n基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。\nDog实体类\n@Component  //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123;   public String name = &quot;dog&quot;;&#125;\n\nMyConfig配置类\n@Configuration  //代表这是一个配置类public class MyConfig &#123;   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！   public Dog dog()&#123;       return new Dog();  &#125;&#125;\n\n测试\n@Testpublic void test()&#123;   ApplicationContext applicationContext =           new AnnotationConfigApplicationContext(MyConfig.class);   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);   System.out.println(dog.name);&#125;\n\n9 代理模式代理模式是Spring AOP的底层\n代理模式的分类：\n\n静态代理\n动态代理\n\n9.1 静态代理角色分析：\n\n抽象角色：一般使用接口或抽象类来解决\n真实角色：被代理的角色\n代理角色：代理真实角色，一般会做一些附属操作\n客户：访问代理对象的人\n\n代理模式的好处：\n\n可以使真实角色的操作更加纯粹，不用关注一些公共的业务\n公共业务交给代理角色，实现了业务的分工\n公共业务发生扩展的时候，方便集中管理\n\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低。\n\n9.2 动态代理\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的，不是直接写好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口——JDK动态代理\n基于类：cglib\nJava字节码实现：JAVAssist\n\n\n\n需要了解两个类：Proxy，InvocationHandler\n【InvocationHandler：调用处理程序】\nInvocationHandler是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。\nObject invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。\n\n【Proxy  : 代理】\nProxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理对象的超类。\n//生成代理类//public static Object newProxyInstance(Classloader loader,类&lt;&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException//loader - 类加载器来定义代理类//interfaces - 代理类实现的接口列表//h - 调度方法调用的调用处理程序public Object getProxy()&#123;   return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);&#125;\n\n代码实现：\nRent - 抽象角色\n//抽象角色：租房public interface Rent &#123;   public void rent();&#125;\n\nHost  - 真实角色\n//真实角色：房东，房东要出租房子public class Host implements Rent&#123;   public void rent() &#123;       System.out.println(&quot;房屋出租&quot;);  &#125;&#125;\n\nProxyInvocationHandler - 代理角色\npublic class ProxyInvocationHandler implements InvocationHandler &#123;   private Rent rent;   public void setRent(Rent rent) &#123;       this.rent = rent;  &#125;   //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色   public Object getProxy()&#123;       return Proxy.newProxyInstance(this.getClass().getClassLoader(),               rent.getClass().getInterfaces(),this);  &#125;   // proxy : 代理类 method : 代理类的调用处理程序的方法对象.   // 处理代理实例上的方法调用并返回结果   @Override   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;       seeHouse();       //核心：本质利用反射实现！       Object result = method.invoke(rent, args);       fare();       return result;  &#125;   //看房   public void seeHouse()&#123;       System.out.println(&quot;带房客看房&quot;);  &#125;   //收中介费   public void fare()&#123;       System.out.println(&quot;收中介费&quot;);  &#125;&#125;\n\nClient - 租客\n//租客public class Client &#123;   public static void main(String[] args) &#123;       //真实角色       Host host = new Host();       //代理实例的调用处理程序       ProxyInvocationHandler pih = new ProxyInvocationHandler();       pih.setRent(host); //将真实角色放置进去！       Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！       proxy.rent();  &#125;&#125;\n\n核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！\n动态代理的好处：\n\n可以使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 ；\n公共的业务由代理来完成 ，实现了业务的分工 ；\n公共业务发生扩展时变得更加集中和方便 ；\n一个动态代理 , 一般代理某一类业务；\n一个动态代理可以代理多个类，代理的是接口。\n\n10 AOPAOP（Aspect Oriented Programming），即面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\nAOP的相关概念：\n\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….\n切面（ASPECT）：横切关注点，被模块化的特殊对象。即，它是一个类。\n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。\n目标（Target）：被通知对象。\n代理（Proxy）：向目标对象应用通知之后创建的对象。\n切入点（PointCut）：切面通知 执行的“地点”的定义。\n连接点（JointPoint）：与切入点匹配的执行点。\n\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice。\n\n使用Spring实现Aop\n使用AOP织入，需要导入一个依赖包！\n&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n业务接口和实现类\npublic interface UserService &#123;   public void add();   public void delete();   public void update();   public void search();&#125;public class UserServiceImpl implements UserService&#123;   @Override   public void add() &#123;       System.out.println(&quot;增加用户&quot;);  &#125;   @Override   public void delete() &#123;       System.out.println(&quot;删除用户&quot;);  &#125;   @Override   public void update() &#123;       System.out.println(&quot;更新用户&quot;);  &#125;   @Override   public void search() &#123;       System.out.println(&quot;查询用户&quot;);  &#125;&#125;\n\n10.1 Spring API实现增强类：前置增强和后置增强\npublic class Log implements MethodBeforeAdvice &#123;   //method : 要执行的目标对象的方法   //objects : 被调用的方法的参数   //Object : 目标对象   @Override   public void before(Method method, Object[] objects, Object o) throws Throwable &#123;       System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);  &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123;   //returnValue 返回值   //method被调用的方法   //args 被调用的方法的对象的参数   //target 被调用的目标对象   @Override   public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable &#123;       System.out.println(&quot;执行了&quot; + target.getClass().getName()       +&quot;的&quot;+method.getName()+&quot;方法,&quot;       +&quot;返回值：&quot;+returnValue);  &#125;&#125;\n\nspring的文件中注册bean , 并实现aop切入实现 , 注意导入约束 。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;   &lt;!--注册bean--&gt;   &lt;bean id=&quot;userService&quot; class=&quot;com.zhg.service.UserServiceImpl&quot;/&gt;   &lt;bean id=&quot;log&quot; class=&quot;com.zhg.log.Log&quot;/&gt;   &lt;bean id=&quot;afterLog&quot; class=&quot;com.zhg.log.AfterLog&quot;/&gt;   &lt;!--aop的配置--&gt;   &lt;aop:config&gt;       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;   &lt;/aop:config&gt;&lt;/beans&gt;\n\n测试\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;); // 接口！！！       userService.search();  &#125;&#125;\n\nSpring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来，实现公共业务的重复利用 。领域业务更纯粹，程序猿专注领域业务，其本质还是动态代理。\n10.2 自定义类实现自定义切入类\npublic class DiyPointcut &#123;   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   &#125;\n\nspring配置\n&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.zhg.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt;   &lt;!--第二种方式：使用AOP的标签实现--&gt;   &lt;aop:aspect ref=&quot;diy&quot;&gt;       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;/&gt;       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;   &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n测试：\npublic class MyTest &#123;   @Test   public void test()&#123;       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);       UserService userService = (UserService) context.getBean(&quot;userService&quot;);       userService.add();  &#125;&#125;\n\n10.3 注解实现注解实现的增强类\npackage com.zhg.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123;   @Before(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void before()&#123;       System.out.println(&quot;---------方法执行前---------&quot;);  &#125;   @After(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void after()&#123;       System.out.println(&quot;---------方法执行后---------&quot;);  &#125;   @Around(&quot;execution(* com.zhg.service.UserServiceImpl.*(..))&quot;)   public void around(ProceedingJoinPoint jp) throws Throwable &#123;       System.out.println(&quot;环绕前&quot;);       System.out.println(&quot;签名:&quot;+jp.getSignature());       //执行目标方法proceed       Object proceed = jp.proceed();       System.out.println(&quot;环绕后&quot;);       System.out.println(proceed);  &#125;&#125;\n\nSpring配置文件中注册bean并增加支持注解的配置\n&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.zhg.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt;\n\n&lt;aop:aspectj-autoproxy/&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。其中有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当该属性为true时，表示使用CGLib动态代理技术织入增强。\n11 整合MyBatismaven导入相关jar包\n&lt;!--MyBatis和MySQL--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;   &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring相关--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectJ AOP 织入器--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-spring整合包--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;   &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--其他--&gt;&lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;\n\nmaven静态资源过滤配置\n&lt;build&gt;   &lt;resources&gt;       &lt;resource&gt;           &lt;directory&gt;src/main/java&lt;/directory&gt;           &lt;includes&gt;               &lt;include&gt;**/*.properties&lt;/include&gt;               &lt;include&gt;**/*.xml&lt;/include&gt;           &lt;/includes&gt;           &lt;filtering&gt;true&lt;/filtering&gt;       &lt;/resource&gt;   &lt;/resources&gt;&lt;/build&gt;\n\nmybatis-spring文档地址：http://mybatis.org/spring/zh/index.html\n11.1 整合实现一要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。\n\n使用SqlSessionFactoryBean创建SqlSessionFactory\n&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;   &lt;!--关联Mybatis--&gt;   &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;   &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/zhg/dao/*.xml&quot;/&gt;&lt;/bean&gt;\n\n配置数据源替换mybaits的数据源\n&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;   &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;\n\n注册sqlSessionTemplate\n&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;   &lt;!--利用构造器注入--&gt;   &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n增加Dao接口的实现类\npublic class UserDaoImpl implements UserMapper &#123;   //sqlSession不用我们自己创建了，Spring来管理   private SqlSessionTemplate sqlSession;   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;       this.sqlSession = sqlSession;  &#125;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = sqlSession.getMapper(UserMapper.class);       return mapper.selectUser();  &#125; &#125;\n\n注册bean实现\n&lt;bean id=&quot;userDao&quot; class=&quot;com.zhg.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\n测试\n@Testpublic void test()&#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);    List&lt;User&gt; user = mapper.selectUser();    System.out.println(user);&#125;\n\n\n\nmybatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;typeAliases&gt;       &lt;package name=&quot;com.zhg.pojo&quot;/&gt;   &lt;/typeAliases&gt;&lt;/configuration&gt;\n\n11.2 整合实现二第二种整合实现方法，mybatis-spring需要1.2.3版以上。\ndao继承Support类，直接利用 getSqlSession() 获得，然后直接注入SqlSessionFactory。比起方式1，不需要管理SqlSessionTemplate , 而且对事务的支持更加友好。\n将上文的UserDaoImpl修改一下\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123;   public List&lt;User&gt; selectUser() &#123;       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);       return mapper.selectUser();  &#125;&#125;\n\n修改bean的配置\n&lt;bean id=&quot;userDao&quot; class=&quot;com.zhg.dao.UserDaoImpl&quot;&gt;   &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;\n\n12 声明式事务事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用，用来确保数据的完整性和一致性。\n事务满足四个属性ACID（原子性，一致性，隔离性，持久性）\nSpring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式事务管理（AOP）。\n头文件tx**约束导入\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n事务管理器\n&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;\n\n事务的通知（Advice）配置\n&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;   &lt;tx:attributes&gt;       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;   &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n配置AOP\n&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt;   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.zhg.dao.*.*(..))&quot;/&gt;   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt;\n\n事务传播行为（propagation）是指多个事务方法相互调用时，事务在这些方法间的传播方式。Spring 支持 7 种事务传播行为（Transaction Propagation Behavior）：\n\n\n\n传播行为\n描述\n\n\n\nPROPAGATION_REQUIRED\n如果没有，就开启一个事务；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）\n\n\nRROPAGATION_REQUIRES_NEW\n如果没有，就开启一个事务；如果有，就将当前事务挂起。（方法A所在的事务就会挂起，方法B会起一个新的事务，等待方法B的事务完成以后，方法A才继续执行）\n\n\nPROPAGATION_NESTED\n如果没有，就开启一个事务；如果有，就在当前事务中嵌套其他事务\n\n\nPROPAGATION_SUPPORTS\n如果没有，就以非事务方式执行；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）\n\n\nPROPAGATION_NOT_SUPPORTED\n如果没有，就以非事务方式执行；如果有，就将当前事务挂起，（方法A所在的事务就会挂起，而方法B以非事务的状态运行完，再继续方法A的事务）\n\n\nPROPAGATION_NEVER\n如果没有，就以非事务方式执行；如果有，就抛出异常。\n\n\nPROPAGATION_MANDATORY\n如果没有，就抛出异常；如果有，就使用当前事务\n\n\n","tags":["Java","SSM框架","Spring"]},{"title":"Vue入门","url":"/2020/12/09/Vue%E5%85%A5%E9%97%A8/","content":"HTML+CSS+JS 视图：给用户看，刷新后台给的数据\n网络通信：axios\n页面跳转：vue-router\n状态管理：vuex\nVue-UI：ICE\n官网：https://cn.vuejs.org/\nVM：数据双向绑定\n虚拟DOM：利用内存\nVue集大成者：MVVM+DOM\nvue-element-admin：https://panjiachen.github.io/vue-element-admin-site/zh/\nVue下载地址\n开发版本：\nhttps://vuejs.org/js/vue.js\nhttps://vuejs.org/js/vue.min.js\nCDN：\nhttps://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\nhttps://cdn.bootcss.com/vue/2.5.16/vue.min.js\n1 Vue基础语法v-bind attribute 被称为指令，指令带有前缀v-\n条件：v-if\n循环：v-for\n事件：v-on\n组件：Vue.component\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app-7&quot;&gt;        &lt;ol&gt;            &lt;!--              现在我们为每个 todo-item 提供 todo 对象              todo 对象是变量，即其内容可以是动态的。            --&gt;            &lt;todo-item                    v-for=&quot;item in groceryList&quot;                    v-bind:todo=&quot;item&quot;                    v-bind:key=&quot;item.id&quot;            &gt;&lt;/todo-item&gt;        &lt;/ol&gt;    &lt;/div&gt;    &lt;script&gt;        Vue.component(&#x27;todo-item&#x27;, &#123;            props: [&#x27;todo&#x27;],            template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;        &#125;)            var app7 = new Vue(&#123;            el: &#x27;#app-7&#x27;,            data: &#123;                groceryList: [                    &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                    &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                    &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;                ]            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n2 网络通信JQuery，Ajax\nAxios 文档地址：http://www.axios-js.com/\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;vue&quot;&gt;        &lt;div&gt;&#123;&#123;info.name&#125;&#125;&lt;/div&gt;        &lt;div&gt;&#123;&#123;info.address.street&#125;&#125;&lt;/div&gt;        &lt;a v-bind:href=&quot;info.url&quot;&gt;点我&lt;/a&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue(&#123;            el: &#x27;#vue&#x27;,            data()&#123;                return &#123;                    info: &#123;                        name: null,                        address: &#123;                            country: null,                            city: null,                            street: null                        &#125;,                        url: null                    &#125;                &#125;            &#125;,            mounted()&#123;                axios                    .get(&#x27;data.json&#x27;)                    .then(response =&gt; (this.info = response.data))            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\ndata.json\n&#123;  &quot;name&quot;:&quot;XXX&quot;,  &quot;url&quot;: &quot;http://baidu.com&quot;,  &quot;page&quot;: &quot;1&quot;,  &quot;isNonProfit&quot;:&quot;true&quot;,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;含光门&quot;,    &quot;city&quot;:&quot;陕西西安&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;,  &quot;links&quot;: [    &#123;      &quot;name&quot;: &quot;B站&quot;,      &quot;url&quot;: &quot;https://www.bilibili.com/&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;4399&quot;,      &quot;url&quot;: &quot;https://www.4399.com/&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;百度&quot;,      &quot;url&quot;: &quot;https://www.baidu.com/&quot;    &#125;  ]&#125;\n\n3 计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，应当使用计算属性。\n计算属性缓存 vs 方法\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;example&quot;&gt;        &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessageF() &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Timestamp now:&quot;&#123;&#123; nowF() &#125;&#125;&quot;&lt;/p&gt;        &lt;p&gt;Computed timestamp now:&quot;&#123;&#123; now &#125;&#125;&quot;&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue(&#123;            el: &#x27;#example&#x27;,            data: &#123;                message: &#x27;Hello&#x27;            &#125;,            // 在组件中            methods: &#123;                reversedMessageF: function () &#123;                    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;,                nowF: function () &#123;                    return Date.now()                &#125;            &#125;,            computed: &#123;                // 计算属性的 getter                reversedMessage: function () &#123;                    // `this` 指向 vm 实例                    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;,                now: function () &#123;                    return Date.now()                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。每当触发重新渲染时，调用方法将总会再次执行函数。\n为什么需要缓存？假设有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。可能有其他的计算属性依赖于 A。如果没有缓存，将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n4 插槽slotVue 实现了一套内容分发的 API，将 &lt;slot&gt; 元素作为承载分发内容的出口。可以把 slot 理解成一个占位符，当在子组件定义好一个 slot 标签，父组件传值时就会替换该标签内容。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;list&gt;        &lt;h1&gt;该数据不会被显示&lt;/h1&gt;        &lt;listname slot=&quot;listname&quot; v-bind:tit=&quot;tit&quot;&gt;&lt;/listname&gt;        &lt;item slot=&quot;item&quot; v-for=&quot;item in groceryList&quot; v-bind:item=&quot;item&quot;&gt;&lt;/item&gt;    &lt;/list&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;list&#x27;, &#123;        template: &#x27;&lt;div&gt;\\                    &lt;slot name=&quot;listname&quot;&gt;&lt;/slot&gt;\\                    &lt;ul&gt;\\                        &lt;slot name=&quot;item&quot;&gt;&lt;/slot&gt;\\                    &lt;/ul&gt;\\                    &lt;/div&gt;&#x27;    &#125;);    Vue.component(&#x27;item&#x27;, &#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&#x27;    &#125;)    Vue.component(&#x27;listname&#x27;, &#123;        props: [&#x27;tit&#x27;],        template: &#x27;&lt;p&gt;&#123;&#123; tit &#125;&#125;&lt;/p&gt;&#x27;    &#125;);    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            groceryList: [                &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;            ],            tit: &#x27;购物清单&#x27;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n如果&lt;list&gt;的template中没有包含一个&lt;slot&gt;元素,则该组件起始标签和结束标签之间的任何内容都会被抛弃。\n5 自定义事件组件内方法要操作Vue实例中的数据，可以在Vue实例中创建方法操作数据，通过HTML视图将实例中的方法赋给一个中间值（自定义事件），在组件内可以通过.$emit(eventName, […args])调用自定义事件。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;list&gt;        &lt;listname slot=&quot;listname&quot; :tit=&quot;tit&quot;&gt;&lt;/listname&gt;        &lt;item slot=&quot;item&quot; v-for=&quot;item in groceryList&quot; :item=&quot;item&quot; @remove=&quot;removeItem(item.id)&quot;&gt;&lt;/item&gt;    &lt;/list&gt;&lt;/div&gt;&lt;script&gt;    Vue.component(&#x27;list&#x27;, &#123;        template: `&lt;div&gt;                    &lt;slot name=&quot;listname&quot;&gt;&lt;/slot&gt;                    &lt;ul&gt;                        &lt;slot name=&quot;item&quot;&gt;&lt;/slot&gt;                    &lt;/ul&gt;                    &lt;/div&gt;`    &#125;);    Vue.component(&#x27;item&#x27;, &#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123;&#123;item.id&#125;&#125;---&#123;&#123; item.text &#125;&#125; &lt;button @click=&quot;rm&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            rm:function (index) &#123;                this.$emit(&#x27;remove&#x27;,index);            &#125;        &#125;    &#125;)    Vue.component(&#x27;listname&#x27;, &#123;        props: [&#x27;tit&#x27;],        template: &#x27;&lt;p&gt;&#123;&#123; tit &#125;&#125;&lt;/p&gt;&#x27;    &#125;);    var app = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            groceryList: [                &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,                &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,                &#123; id: 2, text: &#x27;其它&#x27; &#125;            ],            tit: &#x27;购物清单&#x27;        &#125;,        methods:&#123;            removeItem:function (index) &#123;                console.log(&quot;删除了&quot;+this.groceryList[index]);                this.groceryList.splice(index,1);            &#125;        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n6 Vue-CliVue-cli 是一个官方提供的脚手架，用于快速生成一个Vue的项目模板。\n主要功能：\n\n统一的目录结构\n本地调试\n热部署\n单元测试\n集成打包上线\n\n需要提前下载安装Node.js以及淘宝镜像加速器（cnpm）\nnpm install cnpm -g# 或者npm install cnpm -g --registry=https://registry.npm.taobao.org\n\n项目搭建：在Vue项目文件夹下创建一个基于webpack模板的vue应用程序\n# myvue是项目名vue init webpack myvue\n\n然后一路选no即可；\n初始化并运行项目：\ncd myvuenpm install # 可使用cnpm加快速度npm run dev\n\n7 WebpackWebpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。\n安装webpack\nnpm install webpack -gnpm install webpack-cli -g\n\n使用webpack\n\n新建项目并在项目下创建modules文件夹，用于放置JS模块等资源文件；\n项目目录\n\n\n在modules文件夹下创建模块文件（hello.js，main.js）；\nhello.js\n//exports暴露一个方法exports.sayHi = function()&#123;    document.write(&quot;&lt;h1&gt;Webpack test&lt;/h1&gt;&quot;)&#125;\n\nmain.js\n//require导入一个模块var hello = require(&quot;./hello&quot;);hello.sayHi();\n\n在项目目录下创建webpack.config.js配置文件，使用webpack命令打包；\nwebpack.config.js\nmodule.exports = &#123;    entry:&#x27;./modules/main.js&#x27;,    output:&#123;        filename:&#x27;./js/bundle.js&#x27;    &#125;&#125;\n\nwebpack打包\n\n\n在项目目录下创建HTML页面（index.html）,导入webpack打包后的js文件。\nindex.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--前端的模块化开发--&gt;&lt;script src=&quot;dist/js/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n8 Vue-Router\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。\n\nVue-Router包含的功能有：\n\n嵌套的路由/视图表\n模块化的、基于组件的路由配置\n路由参数、查询、通配符\n基于 Vue.js 过渡系统的视图过渡效果\n细粒度的导航控制\n带有自动激活的 CSS class 的链接\nHTML5 历史模式或 hash 模式，在 IE9 中自动降级\n自定义的滚动条行为\n\n使用步骤：\n\n使用vue-cli搭建一个基于webpack模板的vue应用程序；\n\n新建components目录，存放编写的组件（Content.vue）；\nContent.vue\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;内容页&lt;&#x2F;h1&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Content&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n在项目目录下使用cnpm install vue-router --save-dev命令安装vue-router；\n\n\n在src目录下新建一个文件夹router，专门存放路由；\nindex.js\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;//导入组件import Content from &#x27;../components/Content&#x27;//安装路由Vue.use(Router);//配置路由export default new Router(&#123;  routes:[    &#123;      path:&#x27;/content&#x27;,      component:Content    &#125;  ]&#125;)\n\n在main.js文件中导入并配置路由；\nmain.js\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import VueRouter from &#x27;vue-router&#x27;import  router from &#x27;./router&#x27;Vue.config.productionTip = false//显示声明使用VueRouterVue.use(VueRouter);new Vue(&#123;  el: &#x27;#app&#x27;,  //配置路由  router,  components: &#123; App &#125;,  template: &#x27;&lt;App/&gt;&#x27;&#125;)\n\n在App.vue中使用路由。\nApp.vue\n&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h1&gt;Hi&lt;&#x2F;h1&gt;    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容页&lt;&#x2F;router-link&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;,&#125;&lt;&#x2F;script&gt;&lt;style&gt;#app &#123;  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;&#x2F;style&gt;\n\n\n\n参数传递\n前端URL提交数据：\n&lt;!-- 命名的路由 --&gt;&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;this.$router.push(&quot;&#x2F;user&#x2F;&quot;+this.form.userid);\n\n参数传递路由配置（接受参数）：\nroutes:[    &#123;        path:&#x27;/user/:userId&#x27;，        name:&#x27;user&#x27;,        component:User,        props:true    &#125;]\n\n前端展示数据：\n&lt;template&gt;\t&#123;&#123;$router.params.userId&#125;&#125;\t&#123;&#123;userId&#125;&#125; &lt;&#x2F;template&gt;&lt;sript&gt;\texports default&#123;    \tprops:[&#39;userId&#39;],    \tname:&quot;User&quot;    \t    &#125;&lt;&#x2F;sript&gt;\n\n路由模式\n路由模式有两种：\n\nhash：路径带”#“（http://localhost/#/login）\nhistory：路径不带”#“（http://localhost/login）\n\n修改配置路由\nexport default new Router(    &#123;        mode:&#x27;history&#x27;,        routes:[                    ]    &#125;);\n\n\n\n重定向\nroutes:[    &#123;        path:&#x27;/goHome&#x27;，        redirect:&#x27;/main&#x27;    &#125;]\n\n404\nroutes:[    ...,    &#123;        path:*，        redirect:&#x27;/NotFound&#x27;    &#125;]\n\n嵌套路由：URL 中各段动态路径也按某种结构对应嵌套的各层组件。\n/user/foo/profile                     /user/foo/posts+------------------+                  +-----------------+| User             |                  | User            || +--------------+ |                  | +-------------+ || | Profile      | |  +------------&gt;  | | Posts       | || |              | |                  | |             | || +--------------+ |                  | +-------------+ |+------------------+                  +-----------------+\n\n配置嵌套路由（children属性）\nexport default new Router(&#123;   routes: [    &#123; path: &#x27;/user/:id&#x27;, component: User,      children: [        &#123;          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中          path: &#x27;profile&#x27;,          component: UserProfile        &#125;,        &#123;          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中          path: &#x27;posts&#x27;,          component: UserPosts        &#125;      ]    &#125;  ]&#125;);\n\n9 ElementUIElementUI是由饿了么开发的一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。\n测试：\n\n使用vue-cli搭建一个基于webpack模板的vue应用程序（vue init webpack 项目名）；\n\n安装依赖，安装需要的插件（vue-router, element-ui, sass-loader, node-sass）；\ncd 项目名cnpm install vue-router --save-devcnpm i element-ui -Scnpm install #安装依赖cnpm install sass-loader node-sass --save-devnpm run dev\n\n新建views目录，存放编写的视图（Main.vue，Login.vue）；\nLogin.vue\n&lt;template&gt;  &lt;div&gt;      &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;        &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;        &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;          &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;          &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item&gt;          &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;        &lt;&#x2F;el-form-item&gt;      &lt;&#x2F;el-form&gt;    &lt;el-dialog      title&#x3D;&quot;温馨提示&quot;      :visible.sync&#x3D;&quot;dialogVisible&quot;      width&#x3D;&quot;30%&quot;      :before-close&#x3D;&quot;handleClose&quot;&gt;      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;      &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export  default &#123;        name:&quot;Login&quot;,        data()&#123;            return &#123;                form:&#123;                    username: &#39;&#39;,                    password: &#39;&#39;                &#125;,                &#x2F;&#x2F;表单验证，需要再el-form-item 元素中增加prop属性                rules:&#123;                    username:[            &#123;required:true,message:&#39;账号不能为空&#39;,trigger:&#39;blur&#39;&#125;          ],            password:[            &#123;required: true,message: &#39;密码不能为空&#39;,trigger:&#39;blur&#39;&#125;          ]        &#125;,            &#x2F;&#x2F;对话框显示和隐藏            dialogVisible:false        &#125;        &#125;,        methods:&#123;            handleClose: function () &#123; console.log(&quot;Handle Close，空函数&quot;); &#125;,            onSubmit(formName) &#123;                &#x2F;&#x2F;为表单绑定验证功能                this.$refs[formName].validate((valid) &#x3D;&gt;&#123;                    if (valid)&#123;                        &#x2F;&#x2F;使用 vue-router路由到指定页面，该方式称之为编程式导航                        this.$router.push(&quot;&#x2F;main&quot;);                    &#125; else &#123;                        this.dialogVisible &#x3D; true;                        return false;                    &#125;                &#125;);            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;  .login-box&#123;    border: 1px solid #DCDFE6;    width: 350px;    margin:180px auto;    padding:35px 35px 15px 35px;    border-radius: 5px;    -webkit-border-radius: 5px;    -moz-border-radius: 5px;    box-shadow:0 0 25px #909399;  &#125;  .login-title&#123;    text-align:center;    margin:0 auto 40px auto;    color:#303133;  &#125;&lt;&#x2F;style&gt;\n\nMain.vue\n&lt;template&gt;    &lt;h1&gt;首页&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Main&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n新建router目录，存放配置的路由（index.js）;\nindex.js\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Main from &#x27;../views/Main&#x27;import Login from &#x27;../views/Login&#x27;Vue.use(Router);export default new Router(&#123;  routes:[    &#123;      path:&#x27;/main&#x27;,      component:Main    &#125;,    &#123;      path:&#x27;/login&#x27;,      component:Login    &#125;,  ]&#125;);\n\n在main.js文件中导入并配置路由。\nmain.js\n// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(router)Vue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123;  el: &#x27;#app&#x27;,  router,  render: h =&gt; h(App) //ElementUI&#125;)\n\n注意：遇到问题，可以考虑将sass降级：sass-loader:&quot;7.0.3&quot;，node-sass:&quot;4.7.2&quot;！\n\n\n10 路由钩子Vue的生命周期以及钩子函数\n\n路由钩子\nbeforeRouterEnter：进入路由前执行\nbeforeRouterEnter：进入路由后执行\nexport default&#123;\tprops:[&#39;id&#39;],\tname:&quot;UserProfile&quot;,\tbeforeRouteEnter:(to,from,next)&#x3D;&gt;&#123;\t\tconsole.log(&quot;准备进入个人信息页&quot;);\t\tnext();\t&#125;,\tbeforeRouterLeave:(to,from,next)&#x3D;&gt;&#123;\t\tconsole.log(&quot;准备离开个人信息页&quot;);\t\tnext();\t&#125;&#125;\n\n参数说明：\n\nto：路由将要跳转的路径信息\nfrom：路径跳转前的路径信息\nnext：路由的控制参数\nnext() 跳入下一页面\nnext(‘/path’) 改变路由的跳转方向，使其跳到另一路由\nnext(false) 返回原来的页面\nnext((vm)=&gt;{})仅在beforeRouterEnter中可用，vm是组件实例\n\n\n\n在钩子函数中使用异步请求\n安装并引用Axios\n入口文件main.js中\nimport Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios)\n\n使用路由钩子获取数据\n&lt;script&gt;    export  default &#123;        name:&quot;Login&quot;,        beforeRouteEnter:(to,from,next)&#x3D;&gt;&#123;            console.log(&quot;准备进入个人信息页&quot;);            next(vm&#x3D;&gt;&#123;                vm.getData();            &#125;);        &#125;,        beforeRouterLeave:(to,from,next)&#x3D;&gt;&#123;            console.log(&quot;准备离开个人信息页&quot;);            next();        &#125;,        methods:&#123;            getData:function()&#123;                this.axios(&#123;                    method:&#39;get&#39;,                    url:&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;                &#125;).then(function(response)&#123;                    console.log(response)                &#125;);            &#125;                  &#125;    &#125;&lt;&#x2F;script&gt;\n\n","tags":["前端","Vue"]}]